.\" generated by cd2nroff 0.1 from CURLOPT_HEADERDATA.md
.TH CURLOPT_HEADERDATA 3 "March 12 2024" libcurl
.SH NAME
CURLOPT_HEADERDATA \- pointer to pass to header callback
.SH SYNOPSIS
.nf
#include <curl/curl.h>

CURLcode curl_easy_setopt(CURL *handle, CURLOPT_HEADERDATA, void *pointer);
.fi
.SH DESCRIPTION
Pass a \fIpointer\fP to be used to write the header part of the received data
to.

If \fICURLOPT_WRITEFUNCTION(3)\fP or \fICURLOPT_HEADERFUNCTION(3)\fP is used,
\fIpointer\fP is passed in to the respective callback.

If neither of those options are set, \fIpointer\fP must be a valid FILE * and
it is used by a plain fwrite() to write headers to.

If you are using libcurl as a win32 DLL, you \fBMUST\fP use a
\fICURLOPT_WRITEFUNCTION(3)\fP or \fICURLOPT_HEADERFUNCTION(3)\fP if you set
this option or you might experience crashes.
.SH DEFAULT
NULL
.SH PROTOCOLS
All
.SH EXAMPLE
.nf
struct my_info {
  int shoesize;
  char *secret;
};

static size_t header_callback(char *buffer, size_t size,
                              size_t nitems, void *userdata)
{
  struct my_info *i = userdata;
  printf("shoe size: %d\\n", i->shoesize);
  /* now this callback can access the my_info struct */

  return nitems * size;
}

int main(void)
{
  CURL *curl = curl_easy_init();
  if(curl) {
    struct my_info my = { 10, "the cookies are in the cupboard" };
    curl_easy_setopt(curl, CURLOPT_URL, "https://example.com");

    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, header_callback);

    /* pass in custom data to the callback */
    curl_easy_setopt(curl, CURLOPT_HEADERDATA, &my);

    curl_easy_perform(curl);
  }
}
.fi
.SH AVAILABILITY
Always
.SH RETURN VALUE
Returns CURLE_OK
.SH SEE ALSO
.BR CURLOPT_HEADERFUNCTION (3),
.BR CURLOPT_WRITEFUNCTION (3),
.BR curl_easy_header (3)
