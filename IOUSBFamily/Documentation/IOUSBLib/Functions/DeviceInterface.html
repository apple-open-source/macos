<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>Functions</title>	</head>	<body bgcolor="white">		<h1><font face="Geneva,Arial,Helvtica">IOUSBDeviceInterface Functions</font></h1>		<p>The function pointers described here are accessed using any of the IOUSBDeviceInterface structures. This includes the original IOUSBDeviceInterface structure which shipped with the original Mac OS X, as well as IOUSBDeviceInterface182 structure which shipped with Mac OS X 10.0.4 (available as a Software Update). Functions which were <i><b>not</b></i> available in the original API will be documented as such.</p>		<p>		<hr>		<h3><a name="CreateDeviceAsyncEventSource"></a>CreateDeviceAsyncEventSource</h3>		<p><b>Abstract:</b> Create a run loop source for delivery of all asynchronous notifications on this device.		<pre><blockquote><tt> <b>IOReturn</b>(*CreateDeviceAsyncEventSource)(void *self, CFRunLoopSourceRef *source);</tt></blockquote></pre>		<p>The Mac OS X kernel does not spawn a thread to callback to the client. Instead it deliveres completion notifications on a mach port (see createInterfaceAsyncPort below). This routine wraps that port with the appropriate routing code so that the completion notifications can be automatically routed through the clients CFRunLoop.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>source</tt></td>					<td>Pointer to a CFRunLoopSourceRef to return the newly created run loop event source.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful or a kern_return_t if failed.		<hr>		<h3><a name="CreateDeviceAsyncPort"></a>CreateDeviceAsyncPort</h3>		<p><b>Abstract:</b> Create and register a mach_port_t for asynchronous communications.		<pre><blockquote><tt> <b>IOReturn</b>(*CreateDeviceAsyncPort)(void *self, mach_port_t *port);</tt><br></blockquote></pre>		<p>The Mac OS X kernel does not spawn a thread to callback to the client. Instead it deliveres completion notifications on this mach port. After receiving a message on this port the client is obliged to call the IOKitLib.h: IODispatchCalloutFromMessage() function for decoding the notification message.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>port</tt></td>					<td>Pointer to a mach_port_t to return the newly created port.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful or a kern_return_t if failed.		<hr>		<h3><a name="CreateInterfaceIterator"></a>CreateInterfaceIterator</h3>		<p><b>Abstract:</b> Creates an iterator to iterate over some or all of the interfaces of a device.		<pre><blockquote><tt> <b>IOReturn</b>(*CreateInterfaceIterator)(void *self, IOUSBFindInterfaceRequest *req, io_iterator_t *iter);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>req</tt></td>					<td>Pointer an IOUSBFindInterfaceRequest structure describing the desired interfaces.</td>				</tr>				<tr>					<td align="center"><tt>iter</tt></td>					<td>Pointer to a an io_iterator_t to contain the new iterator.</td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful or kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3>		<h3><a name="DeviceRequest"></a>DeviceRequest</h3>		</h3>		<p><b>Abstract:</b> Sends a USB request on the default control pipe.		<pre><blockquote><tt> <b>IOReturn</b>(*DeviceRequest)(void *self, IOUSBDevRequest *req);</tt></blockquote></pre>		<p>The device must be open to issue this call. Care should be taken when issuing a device request which changes the state of the device. Use the API, for example, to change the configuration of the device or to select an alternate setting on an interface.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>req</tt></td>					<td>Pointer to an IOUSBDevRequest containing the request.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful or kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnNotOpen if the device is not open for exclusive access.		<hr>		<h3><a name="DeviceRequestAsync"></a>DeviceRequestAsync</h3>		<p><b>Abstract:</b> Sends an asyncronous USB request on the default control pipe.		<pre><blockquote><tt> <b>IOReturn</b>(*DeviceRequestAsync)(void *self, IOUSBDevRequest *req, IOAsyncCallback1 callback, void *refCon);</tt></blockquote></pre>		<p>The device must be open to issue this command. Care should be taken when issuing a device request which changes the state of the device. Use the API, for example, to change the configuration of the device or to select an alternate setting on an interface.		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>req</tt></td>					<td>Pointer to an IOUSBDevRequest containing the request.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>callback</tt></td>					<td>An IOAsyncCallback1 method. A message addressed to this callback is posted to the Async port upon completion.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>refCon</tt></td>					<td>Arbitrary pointer which is passed as a parameter to the callback routine.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, kIOReturnNotOpen if the device is not open for exclusive access, or kIOUSBNoAsyncPortErr if no Async port has been created for this interface.		<hr>		<h3><a name="DeviceRequestAsyncTO"></a>DeviceRequestAsyncTO</h3>		<p><b>Note: This function is only available with IOUSBDeviceInterface182 and above.</b></p>		<p><b>Abstract:</b> Sends an asyncronous USB request on the default control pipe. The IOUSBDevRequestTO structure allows the client to specify timeout values for this request.		<pre><blockquote><tt> <b>IOReturn</b>(*DeviceRequestAsyncTO)(void *self, IOUSBDevRequestTO *req, IOAsyncCallback1 callback, void *refCon);</tt></blockquote></pre>		<p>The device must be open to issue this command. Care should be taken when issuing a device request which changes the state of the device. Use the API, for example, to change the configuration of the device or to select an alternate setting on an interface.		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>req</tt></td>					<td>Pointer to an IOUSBDevRequestTO containing the request.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>callback</tt></td>					<td>An IOAsyncCallback1 method. A message addressed to this callback is posted to the Async port upon completion.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>refCon</tt></td>					<td>Arbitrary pointer which is passed as a parameter to the callback routine.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, kIOReturnNotOpen if the device is not open for exclusive access, or kIOUSBNoAsyncPortErr if no Async port has been created for this interface.		<hr>		<h3><a name="DeviceRequestTO"></a>DeviceRequestTO</h3>		<p><b>Note: This function is only available with IOUSBDeviceInterface182 and above.</b></p>		<p><b>Abstract:</b> Sends a USB request on the default control pipe. The IOUSBDevRequestTO structure allows the client to specify timeout values for this request.		<pre><blockquote><tt> <b>IOReturn</b>(*DeviceRequestTO)(void *self, IOUSBDevRequestTO *req);</tt></blockquote></pre>		<p>The device must be open to issue this command. Care should be taken when issuing a device request which changes the state of the device. Use the API, for example, to change the configuration of the device or to select an alternate setting on an interface.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>req</tt></td>					<td>Pointer to an IOUSBDevRequestTO containing the request.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnNotOpen if the device is not open for exclusive access.		<hr>		<h3><a name="GetBusFrameNumber"></a>GetBusFrameNumber</h3>		<p><b>Abstract:</b> Gets the current frame number of the bus to which the device is attached.		<pre><blockquote><tt> <b>IOReturn</b>(*GetBusFrameNumber)(void *self, UInt64 *frame, AbsoluteTime *atTime);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>frame</tt></td>					<td>Pointer to UInt64 to hold the frame number.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>atTime</tt></td>					<td>Pointer to a returned AbsoluteTime, which should be within 1ms of the time when the bus frame number was attained.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="GetConfiguration"></a>GetConfiguration</h3>		<p><b>Abstract:</b> Return the currently selected configuration in the device.		<pre><blockquote><tt> <b>IOReturn</b>(*GetConfiguration)(void *self, UInt8 *configNum);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>configNum</tt></td>					<td>Pointer to UInt8 to hold the configuration value.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3>		<h3><a name="GetConfigurationDescriptorPtr"></a>GetConfigurationDescriptorPtr</h3>		</h3>		<p><b>Abstract:</b> Return a pointer to a configuration descriptor for a given index.		<pre><blockquote><tt> <b>IOReturn</b>(*GetConfigurationDescriptorPtr)(void *self, UInt8 configIndex, IOUSBConfigurationDescriptorPtr *desc);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>configIndex</tt></td>					<td>The index (zero based) of the desired config descriptor.</td>				</tr>				<tr>					<td align="center"><tt>desc</tt></td>					<td>Pointer to an <tt>IOUSBConfigurationDescriptorPtr</tt> to hold the result.</td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="GetDeviceAddress"></a>GetDeviceAddress</h3>		<p><b>Abstract:</b> Return the address of the device on its bus.		<pre><blockquote><tt> <b>IOReturn</b>(*GetDeviceAddress)(void *self, USBDeviceAddress *addr);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>addr</tt></td>					<td>Pointer to USBDeviceAddress to hold the result.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="GetDeviceAsyncEventSource"></a>GetDeviceAsyncEventSource</h3>		<p><b>Abstract:</b> Return the CFRunLoopSourceRef for this IOService instance.		<pre><blockquote><tt> <b>CFRunLoopSourceRef</b>(*GetDeviceAsyncEventSource)(void *self);</tt></blockquote></pre>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns the run loop source if one has been created, 0 otherwise.		<hr>		<h3><a name="GetDeviceAsyncPort"></a>GetDeviceAsyncPort</h3>		<p><b>Abstract:</b> Return the mach_port_t port for this IOService instance.		<pre><blockquote><tt> <b>mach_port_t</b>(*GetDeviceAsyncPort)(void *self);</tt></blockquote></pre>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns the port if one exists, 0 otherwise.		<hr>		<h3><a name="GetDeviceBusPowerAvailable"></a>GetDeviceBusPowerAvailable</h3>		<p><b>Abstract:</b> Return the power available to the device.		<pre><blockquote><tt> <b>IOReturn</b>(*GetDeviceBusPowerAvailable)(void *self, UInt32 *powerAvailable);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>powerAvailable</tt></td>					<td>Pointer to UInt32 to hold the power available (in 2 mA increments).</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3>		<h3><a name="GetDeviceClass"></a>GetDeviceClass</h3>		</h3>		<p><b>Abstract:</b> Return the USB Class of the device.		<pre><blockquote><tt> <b>IOReturn</b>(*GetDeviceClass)(void *self, UInt8 *devClass);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>devClass</tt></td>					<td>Pointer to UInt8 to hold the device Class</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3>		<h3><a name="GetDeviceProduct"></a>GetDeviceProduct</h3>		</h3>		<p><b>Abstract:</b> Return the ProductID of the device.		<pre><blockquote><tt> <b>IOReturn</b>(*GetDeviceProduct)(void *self, UInt16 *devProduct);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>devProduct</tt></td>					<td>Pointer to UInt16 to hold the ProductID</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="GetDeviceProtocol"></a>GetDeviceProtocol</h3>		<p><b>Abstract:</b> Return the USB Protocol of the interface.		<pre><blockquote><tt> <b>IOReturn</b>(*GetDeviceProtocol)(void *self, UInt8 *devProtocol);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>devProtocol</tt></td>					<td>Pointer to UInt8 to hold the device Protocol</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3>&nbsp;</h3>		<h3><a name="GetDeviceReleaseNumber"></a>GetDeviceReleaseNumber</h3>		<p><b>Abstract:</b> Return the Release Number of the device.		<pre><blockquote><tt> <b>IOReturn</b>(*GetDeviceReleaseNumber)(void *self, UInt16 *devRelNum);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>devRelNum</tt></td>					<td>Pointer to UInt16 to hold the Release Number</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="GetDeviceSpeed"></a>GetDeviceSpeed</h3>		<p><b>Abstract:</b> Return the speed of the device.		<pre><blockquote><tt> <b>IOReturn</b>(*GetDeviceSpeed)(void *self, UInt8 *devSpeed);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>devSpeed</tt></td>					<td>Pointer to UInt8 to hold the speed (kUSBDeviceSpeedLow or kUSBDeviceSpeedFull)</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="GetDeviceSubClass"></a>GetDeviceSubClass</h3>		<p><b>Abstract:</b> Return the USB Subclass of the device.		<pre><blockquote><tt> <b>IOReturn</b>(*GetDeviceSubClass)(void *self, UInt8 *devSubClass);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>devSubClass</tt></td>					<td>Pointer to UInt8 to hold the device Subclass</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3>		<h3><a name="GetDeviceVendor"></a>GetDeviceVendor</h3>		</h3>		<p><b>Abstract:</b> Return the VendorID of the device.		<pre><blockquote><tt> <b>IOReturn</b>(*GetDeviceVendor)(void *self, UInt16 *devVendor);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>devVendor</tt></td>					<td>Pointer to UInt16 to hold the vendorID</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="GetLocationID"></a>GetLocationID</h3>		<p><b>Abstract:</b> Return the location ID. This is a 32 bit number which is unique among all USB devices in the system, andwhich will not change on a system reboot unless the topology of the bus itself changes.		<pre><blockquote><tt> <b>IOReturn</b>(*GetLocationID)(void *self, UInt32 *locationID);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>locationID</tt></td>					<td>Pointer to UInt32 to hold the location ID.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="GetNumberOfConfigurations"></a>GetNumberOfConfigurations</h3>		<p><b>Abstract:</b> Return the number of supported configurations in this device.		<pre><blockquote><tt> <b>IOReturn</b>(*GetNumberOfConfigurations)(void *self, UInt8 *numConfig);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>numConfig</tt></td>					<td>Pointer to UInt8 to hold the number of configurations.</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="ResetDevice"></a>ResetDevice</h3>		<p><b>Abstract:</b> Tells the IOUSBFamily to issue a reset to the device.  It will not reenumerate the device, which means that the cached device descriptor values will not be updated after the reset. (If you want the IOUSBFamily to reload the cached values, use the call <a href="#USBDeviceReEnumerate">USBDeviceReEnumerate</a>). Prior to version 1.8.5 of the IOUSBFamily, this call also sent a message to all clients of the IOUSBDevice (IOUSBInterfaces and their drivers).  This behavior was eliminated with version 1.8.5 of the IOUSBFamily.		<pre><blockquote><tt> <b>IOReturn</b>(*ResetDevice)(void *self);</tt></blockquote></pre>		<p>The device must be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnNotOpen if the device is not open for exclusive access.		<hr>		<h3><a name="SetConfiguration"></a>SetConfiguration</h3>		<p><b>Abstract:</b> Sets the configuration in the device. Note that setting the configuration causes any existing IOUSBInterface objects attached to the IOUSBDevice to be destroyed, and all of the interfaces in the new configuration to be instantiated as new IOUSBInterface objects.		<pre><blockquote><tt> <b>IOReturn</b>(*SetConfiguration)(void *self, UInt8 configNum);</tt></blockquote></pre>		<p>The device must be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>configNum</tt></td>					<td>The value of the desired configuration (from IOUSBConfigurationDescriptor.bConfigurationValue).</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnNotOpen if the device is not open for exclusive access.		<hr>		<h3><a name="USBDeviceAbortPipeZero"></a>USBDeviceAbortPipeZero</h3>		<p><b>Note: This function is only available with IOUSBDeviceInterface182 and above.</b></p>		<p><b>Abstract:</b> Abort a transaction on the default control pipe.		<pre><blockquote><tt> <b>IOReturn</b>(*USBDeviceAbortPipeZero)(void *self);</tt></blockquote></pre>		<p>The device must be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnNotOpen if the device is not open for exclusive access.		<hr>		<h3>		<h3><a name="USBDeviceClose"></a>USBDeviceClose</h3>		</h3>		<p><b>Abstract:</b> Close the task's connection to the IOUSBDevice.		<pre><blockquote><tt> <b>IOReturn</b>(*USBDeviceClose)(void *self);</tt></blockquote></pre>		<p>Release the clients exclusive access to the IOUSBDevice.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, some other mach error if the connection is no longer valid.		<hr>		<h3><a name="USBDeviceOpen"></a>USBDeviceOpen</h3>		<p><b>Abstract:</b> Open up the IOUSBDevice for exclusive access.		<pre><blockquote><tt> <b>IOReturn</b>(*USBDeviceOpen)(void *self);</tt></blockquote></pre>		<p>Before the client can issue commands which change the state of the device, it must have succeeded in opening the device. This establishes an exclusive link between the clients task and the actual device.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnExclusiveAccess if some other task has the device opened already, kIOReturnError if the connection with the kernel can not be established or kIOReturnSuccess if successful.		<hr><h3><a name="USBDeviceOpenSeize"></a>USBDeviceOpenSeize</h3><p><b>Note: This function is only available with IOUSBDeviceInterface182 and above.</b></p><p><b>Abstract:</b> Open up the IOUSBDevice for exclusive access. If another client   has the device opened, an attempt is made to get that client to close it before   returning. <pre><blockquote><tt> <b>IOReturn</b>(*USBDeviceOpenSeize)(void *self);</tt></blockquote></pre><p>Before the client can issue commands which change the state of the device,   it must have succeeded in opening the device. This establishes an exclusive   link between the clients task and the actual device.</p><h4>Parameters</h4><blockquote>   <table border="1" width="90%">    <thead>     <tr>       <th>Name</th>      <th>Description</th>    </tr>    </thead>     <tr>       <td align="center"><tt>self</tt></td>      <td>Pointer to the IOUSBDeviceInterface</td>    </tr>    <tr>       <td></td>      <td></td>    </tr>  </table></blockquote><p><b>Result:</b> Returns kIOReturnExclusiveAccess if some other task has the   device opened already and refuses to close it, kIOReturnError if the connection   with the kernel can not be established or kIOReturnSuccess if successful. <hr><p></p><h3><a name="USBDeviceReEnumerate"></a>USBDeviceReEnumerate</h3><p><b>Note: This function is only available with IOUSBDeviceInterface187 and above.</b></p><p><b>Abstract:</b> Tells the IOUSBFamily to reenumerate the device. This will   send a terminate message to all clients of the IOUSBDevice (such as IOUSBInterfaces   and their drivers, as well as the current User Client), emulating an unplug   of the device. The IOUSBFamily will then enumerate the device as if it had just   been plugged in. This call should be used by clients wishing to take advantage   of the Device Firmware Update Class specification. </p><pre><blockquote><tt> <b>IOReturn</b>(*USBDeviceReEnumerate)(void *self,UInt32 options);</tt></blockquote></pre><p>The device must be open.</p><p><b>Parameters</b></p><blockquote>   <p>   <table border="1" width="90%">    <thead>     <tr>       <th>Name</th>      <th>Description</th>    </tr>    </thead>     <tr>       <td align="center"><tt>self</tt></td>      <td>Pointer to the IOUSBDeviceInterface</td>    </tr>    <tr>       <td align="center"><tt>options</tt></td>      <td>A UInt32 reserved for future use. Ignored in current implementation.         Set to zero.</td>    </tr>  </table>  <p></p></blockquote><p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if   there is no connection to an IOService, or kIOReturnNotOpen if the device is   not open for exclusive access. <hr>		<h3><a name="USBDeviceSuspend"></a>USBDeviceSuspend</h3>		<p><b>Note: This function is only available with IOUSBDeviceInterface182 and above.</b></p>		<p><b>Abstract:</b> Tell the USB Family to either suspend or resume the port to which a device is attached.		<pre><blockquote><tt> <b>IOReturn</b>(*USBDeviceSuspend)(void *self, Boolean suspend);</tt></blockquote></pre>		<p>The device must be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td align="center"><tt>suspend</tt></td>					<td>TRUE to cause the port to be suspended, FALSE to cause it to be resumed</td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService, or kIOReturnNotOpen if the device is not open for exclusive access.		<hr>		<h3>		<h3><a name="USBGetManufacturerStringIndex"></a>USBGetManufacturerStringIndex</h3>		</h3>		<p><b>Note: This function is only available with IOUSBDeviceInterface182 and above.</b></p>		<p><b>Abstract:</b> Return the manufacturer string index in the device descriptor.		<pre><blockquote><tt> <b>IOReturn</b>(*USBGetManufacturerStringIndex)(void *self, UInt8 *msi);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>msi</tt></td>					<td>Pointer to UInt8 to hold the string index</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<h3><a name="USBGetProductStringIndex"></a>USBGetProductStringIndex</h3>		<p><b>Note: This function is only available with IOUSBDeviceInterface182 and above.</b></p>		<p><b>Abstract:</b> Return the product string index in the device descriptor.		<pre><blockquote><tt> <b>IOReturn</b>(*USBGetProductStringIndex)(void *self, UInt8 *psi);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>psi</tt></td>					<td>Pointer to UInt8 to hold the string index</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<hr>		<p></p>		<h3><a name="USBGetSerialNumberStringIndex"></a>USBGetSerialNumberStringIndex</h3>		<p><b>Note: This function is only available with IOUSBDeviceInterface182 and above.</b></p>		<p><b>Abstract:</b> Return the serial number string index in the device descriptor.</p>		<pre><blockquote><tt> <b>IOReturn</b>(*USBGetSerialNumberStringIndex)(void *self, UInt8 *snsi);</tt></blockquote></pre>		<p>The device does not have to be open.</p>		<h4>Parameters</h4>		<blockquote>			<p>			<table border="1" width="90%">				<thead>					<tr>						<th>Name</th>						<th>Description</th>					</tr>				</thead>				<tr>					<td align="center"><tt>self</tt></td>					<td>Pointer to the IOUSBDeviceInterface</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>				<tr>					<td align="center"><tt>snsi</tt></td>					<td>Pointer to UInt8 to hold the string index</td>				</tr>				<tr>					<td></td>					<td></td>				</tr>			</table>			<p></p>		</blockquote>		<p><b>Result:</b> Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.		<p>&nbsp;<hr>		<p></p>		<h3>		<p>&copy; 2001 Apple Computer, Inc. &#151; (Last Updated Nov 7, 2001)</h3>	</body></html>