// This file was automatically generated by protocompiler
// DO NOT EDIT!
// Compiled from SecDbKeychainSerializedMetadataKey.proto

#import "SecDbKeychainSerializedMetadataKey.h"
#import <ProtocolBuffer/PBConstants.h>
#import <ProtocolBuffer/PBHashUtil.h>
#import <ProtocolBuffer/PBDataReader.h>

#if !__has_feature(objc_arc)
# error This generated file depends on ARC but it is not enabled; turn on ARC, or use 'objc_use_arc' option to generate non-ARC code.
#endif

@implementation SecDbKeychainSerializedMetadataKey

@synthesize keyclass = _keyclass;
- (void)setKeyclass:(int32_t)v
{
    _has.keyclass = YES;
    _keyclass = v;
}
- (void)setHasKeyclass:(BOOL)f
{
    _has.keyclass = f;
}
- (BOOL)hasKeyclass
{
    return _has.keyclass != 0;
}
@synthesize actualKeyclass = _actualKeyclass;
- (void)setActualKeyclass:(int32_t)v
{
    _has.actualKeyclass = YES;
    _actualKeyclass = v;
}
- (void)setHasActualKeyclass:(BOOL)f
{
    _has.actualKeyclass = f;
}
- (BOOL)hasActualKeyclass
{
    return _has.actualKeyclass != 0;
}
- (BOOL)hasBaguuid
{
    return _baguuid != nil;
}
@synthesize baguuid = _baguuid;
- (BOOL)hasAkswrappedkey
{
    return _akswrappedkey != nil;
}
@synthesize akswrappedkey = _akswrappedkey;
- (BOOL)hasBackupwrappedkey
{
    return _backupwrappedkey != nil;
}
@synthesize backupwrappedkey = _backupwrappedkey;

- (NSString *)description
{
    return [NSString stringWithFormat:@"%@ %@", [super description], [self dictionaryRepresentation]];
}

- (NSDictionary *)dictionaryRepresentation
{
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    if (self->_has.keyclass)
    {
        [dict setObject:[NSNumber numberWithInt:self->_keyclass] forKey:@"keyclass"];
    }
    if (self->_has.actualKeyclass)
    {
        [dict setObject:[NSNumber numberWithInt:self->_actualKeyclass] forKey:@"actualKeyclass"];
    }
    if (self->_baguuid)
    {
        [dict setObject:self->_baguuid forKey:@"baguuid"];
    }
    if (self->_akswrappedkey)
    {
        [dict setObject:self->_akswrappedkey forKey:@"akswrappedkey"];
    }
    if (self->_backupwrappedkey)
    {
        [dict setObject:self->_backupwrappedkey forKey:@"backupwrappedkey"];
    }
    return dict;
}

BOOL SecDbKeychainSerializedMetadataKeyReadFrom(__unsafe_unretained SecDbKeychainSerializedMetadataKey *self, __unsafe_unretained PBDataReader *reader) {
    while (PBReaderHasMoreData(reader)) {
        uint32_t tag = 0;
        uint8_t aType = 0;

        PBReaderReadTag32AndType(reader, &tag, &aType);

        if (PBReaderHasError(reader))
            break;

        if (aType == TYPE_END_GROUP) {
            break;
        }

        switch (tag) {

            case 1 /* keyclass */:
            {
                self->_has.keyclass = YES;
                self->_keyclass = PBReaderReadInt32(reader);
            }
            break;
            case 2 /* actualKeyclass */:
            {
                self->_has.actualKeyclass = YES;
                self->_actualKeyclass = PBReaderReadInt32(reader);
            }
            break;
            case 3 /* baguuid */:
            {
                NSData *new_baguuid = PBReaderReadData(reader);
                self->_baguuid = new_baguuid;
            }
            break;
            case 4 /* akswrappedkey */:
            {
                NSData *new_akswrappedkey = PBReaderReadData(reader);
                self->_akswrappedkey = new_akswrappedkey;
            }
            break;
            case 5 /* backupwrappedkey */:
            {
                NSData *new_backupwrappedkey = PBReaderReadData(reader);
                self->_backupwrappedkey = new_backupwrappedkey;
            }
            break;
            default:
                if (!PBReaderSkipValueWithTag(reader, tag, aType))
                    return NO;
                break;
        }
    }
    return !PBReaderHasError(reader);
}

- (BOOL)readFrom:(PBDataReader *)reader
{
    return SecDbKeychainSerializedMetadataKeyReadFrom(self, reader);
}
- (void)writeTo:(PBDataWriter *)writer
{
    /* keyclass */
    {
        if (self->_has.keyclass)
        {
            PBDataWriterWriteInt32Field(writer, self->_keyclass, 1);
        }
    }
    /* actualKeyclass */
    {
        if (self->_has.actualKeyclass)
        {
            PBDataWriterWriteInt32Field(writer, self->_actualKeyclass, 2);
        }
    }
    /* baguuid */
    {
        if (self->_baguuid)
        {
            PBDataWriterWriteDataField(writer, self->_baguuid, 3);
        }
    }
    /* akswrappedkey */
    {
        if (self->_akswrappedkey)
        {
            PBDataWriterWriteDataField(writer, self->_akswrappedkey, 4);
        }
    }
    /* backupwrappedkey */
    {
        if (self->_backupwrappedkey)
        {
            PBDataWriterWriteDataField(writer, self->_backupwrappedkey, 5);
        }
    }
}

- (void)copyTo:(SecDbKeychainSerializedMetadataKey *)other
{
    if (self->_has.keyclass)
    {
        other->_keyclass = _keyclass;
        other->_has.keyclass = YES;
    }
    if (self->_has.actualKeyclass)
    {
        other->_actualKeyclass = _actualKeyclass;
        other->_has.actualKeyclass = YES;
    }
    if (_baguuid)
    {
        other.baguuid = _baguuid;
    }
    if (_akswrappedkey)
    {
        other.akswrappedkey = _akswrappedkey;
    }
    if (_backupwrappedkey)
    {
        other.backupwrappedkey = _backupwrappedkey;
    }
}

- (id)copyWithZone:(NSZone *)zone
{
    SecDbKeychainSerializedMetadataKey *copy = [[[self class] allocWithZone:zone] init];
    if (self->_has.keyclass)
    {
        copy->_keyclass = _keyclass;
        copy->_has.keyclass = YES;
    }
    if (self->_has.actualKeyclass)
    {
        copy->_actualKeyclass = _actualKeyclass;
        copy->_has.actualKeyclass = YES;
    }
    copy->_baguuid = [_baguuid copyWithZone:zone];
    copy->_akswrappedkey = [_akswrappedkey copyWithZone:zone];
    copy->_backupwrappedkey = [_backupwrappedkey copyWithZone:zone];
    return copy;
}

- (BOOL)isEqual:(id)object
{
    SecDbKeychainSerializedMetadataKey *other = (SecDbKeychainSerializedMetadataKey *)object;
    return [other isMemberOfClass:[self class]]
    &&
    ((self->_has.keyclass && other->_has.keyclass && self->_keyclass == other->_keyclass) || (!self->_has.keyclass && !other->_has.keyclass))
    &&
    ((self->_has.actualKeyclass && other->_has.actualKeyclass && self->_actualKeyclass == other->_actualKeyclass) || (!self->_has.actualKeyclass && !other->_has.actualKeyclass))
    &&
    ((!self->_baguuid && !other->_baguuid) || [self->_baguuid isEqual:other->_baguuid])
    &&
    ((!self->_akswrappedkey && !other->_akswrappedkey) || [self->_akswrappedkey isEqual:other->_akswrappedkey])
    &&
    ((!self->_backupwrappedkey && !other->_backupwrappedkey) || [self->_backupwrappedkey isEqual:other->_backupwrappedkey])
    ;
}

- (NSUInteger)hash
{
    return 0
    ^
    (self->_has.keyclass ? PBHashInt((NSUInteger)self->_keyclass) : 0)
    ^
    (self->_has.actualKeyclass ? PBHashInt((NSUInteger)self->_actualKeyclass) : 0)
    ^
    [self->_baguuid hash]
    ^
    [self->_akswrappedkey hash]
    ^
    [self->_backupwrappedkey hash]
    ;
}

- (void)mergeFrom:(SecDbKeychainSerializedMetadataKey *)other
{
    if (other->_has.keyclass)
    {
        self->_keyclass = other->_keyclass;
        self->_has.keyclass = YES;
    }
    if (other->_has.actualKeyclass)
    {
        self->_actualKeyclass = other->_actualKeyclass;
        self->_has.actualKeyclass = YES;
    }
    if (other->_baguuid)
    {
        [self setBaguuid:other->_baguuid];
    }
    if (other->_akswrappedkey)
    {
        [self setAkswrappedkey:other->_akswrappedkey];
    }
    if (other->_backupwrappedkey)
    {
        [self setBackupwrappedkey:other->_backupwrappedkey];
    }
}

@end

