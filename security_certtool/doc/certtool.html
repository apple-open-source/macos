<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
    
  <meta name="GENERATOR"
 content="Mozilla/4.75C-CCK-MCD {C-UDP; EBM-APPLE} (Macintosh; U; PPC) [Netscape]">
  <title>CertTool.html</title>
</head>
  <body>
  
<center> 
<h2> <b>CertTool</b></h2>
</center>
  
<center> 
<h2> <b>Last Update 10/10/02</b></h2>
</center>
  
<h2> Table Of Contents</h2>
 1. <a href="#Introduction">Introduction</a> <br>
2. <a href="#Generating%20a%20Self-Signed%20Certificate">Generating a Self-Signed 
Certificate</a> <br>
3. <a
 href="#Generating%20a%20Certificate%20Signing%20Request%20%28CSR%29">Generating 
a Certificate Signing Request (CSR)</a> <br>
4. <a href="#Verifying%20a%20CSR">Verifying a CSR</a> <br>
5. <a
 href="#Importing%20a%20Certificate%20from%20a%20Certificate%20Authority">Importing 
a Certificate from a Certificate Authority</a> <br>
6. <a href="#Displaying%20a%20Certificate">Displaying a Certificate</a> <br>
7. <a href="#Certificate%20Authorities%20and%20CSRs">Certificate Authorities 
and CSRs</a> <br>
<h2> 1.&nbsp;<a name="Introduction"></a>Introduction</h2>
  
<blockquote>CertTool is a UNIX command-line program which is used to create 
key pairs, certificates, and certificate signing requests; to import externally 
generated certificates into a Keychain, and to display the contents of certificates.
Currently. the primary use of CertTool is to perform the certificate-related
administration required to configure an SSL server based on Mac OS X's SecureTransport
library. Each supported CertTool operation is described below in detail. 
  <p>The reader of this document, and the user of CertTool, is assumed to 
be familiar with the following: </p>
  <ul>
 <li> General principles of public key cryptography</li>
  <li> The concepts of certificates and trust</li>
  <li> General operation of the Secure Socket Layer (SSL) protocol</li>
  <li> General operation of the Mac OS X Keychain</li>
  <li> The Mac OS X SecureTransport library</li>
 
  </ul>
 No programming knowledge is assumed or required. An excellent primer on the
topics of public key cryptography, certificates, and SSL can be found at
  <a href="http://httpd.apache.org/docs-2.0/ssl/ssl_intro.html">http://httpd.apache.org/docs-2.0/ssl/ssl_intro.html.</a> 
  <p>Note: in all examples of usage of the command line tool which follow, 
the user's input is shown in <b>bold</b>. Running CertTool with no command-line 
arguments results in usage info being displayed. <br>
&nbsp;</p>
</blockquote>
  
<h2> 2.&nbsp;<a name="Generating a Self-Signed Certificate"></a>Generating
a Self-Signed Certificate</h2>
  
<blockquote>This command generates a key pair and a self-signed (root) certificate
and places them in a keychain. The root cert is signed by the private key
generated during this command. The cert generated by this command is totally
untrustworth and cannot be used in the "real world"; the primary use of this
command is to facilitate early development of SSL server applications based
on SecureTransport. In particular, "real world" SSL clients (e.g., web browsers)
will complain to varying degrees when they attempt to connect to an SSL server
which presents a cert which is generated by this command. Some broswers,
after a fair amount of handholding, will allow you to conditionally "trust"
this cert. 
  <p>The format of this command is </p>
  <p># <b>CertTool c [options]</b> </p>
  <p>The available options are: </p>
  <blockquote>k=keyChainName 
    <blockquote>Where "KeyChainName" is the name of the keychain into which 
keys and the cert will be added. If no keychain is specified, keys and certs
are added to the default keychain. The specified keychain must exist unless
you specify the 'c' option.</blockquote>
 c 
    <blockquote>Specifies that the designated keychain is to be created.</blockquote>
 </blockquote>
 This an interactive command; you will be prompted for a number of different 
items which are used to generate the keypair and the cert. A sample sesion 
follows. <br>
&nbsp; 
  <blockquote># <b>CertTool k=certkc</b> <br>
Enter key and certificate label: <b>testCert</b> 
    <p>Please specify parameters for the key pair you will generate. </p>
    <p>&nbsp; r&nbsp; RSA <br>
&nbsp; d&nbsp; DSA <br>
&nbsp; f&nbsp; FEE </p>
    <p>Select key algorithm by letter: <b><font size="+1">r</font></b> </p>
    <p>Valid key sizes for RSA are 512..2048; default is 512 <br>
Enter key size in bits or CR for default: <b><font size="+1">512</font></b> 
    </p>
    <p>You have selected algorithm RSA, key size 512 bits. <br>
OK (y/anything)? <b><font size="+1">y</font></b> <br>
Enter cert/key usage (s=signing, b=signing AND encrypting): b <br>
...Generating key pair... </p>
    <p><i>&lt;&lt;Note: you will be prompted for the Keychain's passphrase 
by the Keychain system at this point if the specified keychain is not open.&gt;&gt;</i> 
    </p>
    <p>Please specify the algorithm with which your certificate will be signed. 
    </p>
    <p>&nbsp; 5&nbsp; RSA with MD5 <br>
&nbsp; s&nbsp; RSA with SHA1 </p>
    <p>Select signature algorithm by letter:<b><font size="+1"> s</font></b> 
    </p>
    <p>You have selected algorithm RSA with SHA1. <br>
OK (y/anything)? <b><font size="+1">y</font></b> <br>
...creating certificate... </p>
    <p>You will now specify the various components of the certificate's <br>
Relative Distinguished Name (RDN). An RDN has a number of <br>
components, all of which are optional, but at least one of <br>
which must be present. </p>
    <p>Note that if you are creating a certificate for use in an <br>
SSL/TLS server, the Common Name component of the RDN must match <br>
exactly the host name of the server. This must not be an IP <br>
address, but the actual domain name, e.g. www.apple.com. </p>
    <p>Entering a CR for a given RDN component results in no value for <br>
that component. </p>
    <p>Common Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (e.g, www.apple.com) 
: <b><font size="+1">10.0.61.5</font></b> <br>
Country&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
(e.g, US) : <br>
Organization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
(e.g, Apple Computer, Inc.) : <b><font size="+1">Apple</font></b> <br>
Organization Unit&nbsp;&nbsp;&nbsp;&nbsp; (e.g, Apple Data Security) : <br>
State/Province&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (e.g.,
California) : <b><font size="+1">California</font></b> </p>
    <p>You have specified: <br>
&nbsp; Common Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : 10.0.61.5 <br>
&nbsp; Organization&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
: Apple <br>
&nbsp; State/Province&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : California 
    <br>
Is this OK (y/anything)? <b><font size="+1">y</font></b> <br>
..cert stored in Keychain. <br>
#</p>
  </blockquote>
 The "Common Name" portion of the RDN - in the above case, "10.0.61.5" - MUST
match the host name of the machine you'll running sslServer on. (In this
case the test machine doesn't have an actual hostname; it's DHCP'd behind
a firewall which is why "10.0.61.5" was specified for Common Name.) This
is part of SSL's certificate verification; it prevents an attack using DNS
spoofing. 
  <p>A brief note about cert/key usage: the normal configuration of SecureTransport 
is that the server cert specified in SSLSetCertificate() is capable of both
signing and encryption. If this cert is only capable of signing, then you
must create a second keychain ontaining a cert which is capable of encryption,
and pass that to SSLSetEncryptionCertificate(). <br>
&nbsp; <br>
&nbsp;</p>
</blockquote>
  
<h2> 3.&nbsp;<a name="Generating a Certificate Signing Request (CSR)"></a>Generating 
a Certificate Signing Request (CSR)</h2>
  
<blockquote>A CSR is the standard means by which an administrator of a web
server provides information to a Certificate Authority (CA) in order to obtain
a valid certificate which is signed by the CA. This type of cert is used
in the real world; certs signed by CAs such as Verisign or Thawte are recognized
by all web browsers when performing SSL transactions. 
  <p>The general procedure for obtaining a "real" cert is: <br>
&nbsp; </p>
  <ul>
 <li> Generate a key pair</li>
  <li> Generate a CSR</li>
  <li> Provide the CSR and some other information and/or documentation to
the CA</li>
  <li> CA sends you a certificate which is signed by the CA.</li>
  <li> You import that certificate, obtained from the CA, into your keychain. 
The items in that keychain can now be used in SecureTranspoert's SSLSetCertificate() 
call.</li>
 
  </ul>
 This command performs the first two steps in the above procedure. See <a
 href="#Importing%20a%20Certificate%20from%20a%20Certificate%20Authority">Section 
5</a> for information on importing the resulting certificate into your keychain. 
  <p>The format of this command is </p>
  <p># <b>CertTool r outFileName [options]</b> </p>
  <p>The resulting CSR will be written to "outFileName". </p>
  <p>The available options are: </p>
  <p>k=keyChainName </p>
  <blockquote>Where "KeyChainName" is the name of the keychain into which 
keys and the cert will be added. If no keychain is specified, keys and certs
are added to the default keychain. The specified keychain must exist unless
you specify the 'c' option.</blockquote>
 d 
  <blockquote>The 'd' option tells CertTool to create the CSR in DER-encoded 
format. The default is PEM-encoded, which is what most CAs expect. PEM encoded
data consists of printable ASCII text which can, for example, be pasted into
an email message. DER-encoded data is nonprintable binary data.</blockquote>
 c 
  <blockquote>Specifies that the designated keychain is to be created.</blockquote>
 This an interactive command; you will be prompted for a number of different 
items which are used to generate the keypair and the CSR. The prompts given, 
and the format of the data you must supply, are identical to the data shown 
in the sample session in Section 2. 
  <p>See Section 7 for more information on using CSRs and about CAs. <br>
&nbsp; <br>
&nbsp;</p>
</blockquote>
  
<h2> 4.&nbsp;<a name="Verifying a CSR"></a>Verifying a CSR</h2>
  
<blockquote>A CSR contains, among other things, the public key which was generated
in <a
 href="#Generating%20a%20Certificate%20Signing%20Request%20%28CSR%29">Section 
3</a>. The CSR is signed with the associated private key. Thus the inteegrity 
of a CSR can be verified by extracting its public key and verifying the signature
of the CSR. This command performs this integrity check. 
  <p>The format of this command is </p>
  <p># <b>CertTool v inFileName [options]</b> </p>
  <p>The resulting CSR will be written to "outFileName". </p>
  <p>The only available option is the 'd' flag, which as described in <a
 href="#Generating%20a%20Certificate%20Signing%20Request%20%28CSR%29">Section 
3</a>, indiciates that the CSR is in DER format rather than the default PEM
format. </p>
  <p>A typical (successful) run of this command is like so: </p>
  <p># <b>CertTool v myCsr.pem</b> <br>
...CSR verified successfully. </p>
  <p>A large number of things can go wrong of the verification fails; suffice 
it to say that if you see anything other than the above success message, you
have a bad or corrupted CSR. <br>
&nbsp; </p>
  <blockquote>&nbsp;</blockquote>
 </blockquote>
  
<h2> 5.&nbsp;<a
 name="Importing a Certificate from a Certificate Authority"></a>Importing 
a Certificate from a Certificate Authority</h2>
  
<blockquote>Once you have negotiated with your CA, and provided them with 
the CSR generated in <a
 href="#Generating%20a%20Certificate%20Signing%20Request%20%28CSR%29">Section 
3</a> as well as any other information, documentation, and payment thay require,
the CA will provide you with a certificate. Use this command to add that
certificate to the keychain containing the keypair you generated in <a
 href="#Generating%20a%20Certificate%20Signing%20Request%20%28CSR%29">Section
3</a>.&nbsp;<i></i> 
  <p>The format of this command is </p>
  <p># <b>CertTool i inFileName&nbsp; [options]</b> </p>
  <p>The cert to import is obtained from "inFileName". </p>
  <p>The available options are: </p>
  <p>k=keyChainName </p>
  <blockquote>Where "KeyChainName" is the name of the keychain to which the 
cert will be added. If no keychain is specified, the cert is added to the 
default keychain. The specified keychain should contain the keypair you generated
in <a
 href="#Generating%20a%20Certificate%20Signing%20Request%20%28CSR%29">Section 
3</a>. (Note you can import a certificate into a keychain which does not
contain keys you generated but there will be no linkage between the imported
certificate and a private key if you do this.) If the keychain is not open
when this command is executed, you will be prompted by the Keychain system
for its passphrase.</blockquote>
 d 
  <blockquote>Specifies DER format as described above. The default is PEM 
format.<br>
    <br>
  </blockquote>
 c 
  <blockquote>Specifies that the designated keychain is to be created.<br>
 <br>
  </blockquote>
 </blockquote>
  
<h2> 6.&nbsp;<a name="Displaying a Certificate"></a>Displaying a Certificate</h2>
  
<blockquote>This displays the contents of an existing certificate, obtained 
from a file. 
  <p>The format of this command is </p>
  <p># <b>CertTool d inFileName [options]</b> </p>
  <p>The cert to display is obtained from "inFileName". </p>
  <p>The only available option is the 'd' flag, specifying DER format as described
above. The default is PEM format <br>
&nbsp;</p>
</blockquote>
  
<h2> 7.&nbsp;<a name="Certificate Authorities and CSRs"></a>Certificate Authorities 
and CSRs</h2>
  
<blockquote>As mentioned above, the general procedure for obtaining a "real" 
cert is: 
  <ul>
 <li> Generate a key pair</li>
  <li> Generate a CSR</li>
  <li> Provide the CSR and some other information and/or documentation to
the CA</li>
  <li> CA sends you a certificate which is signed by the CA.</li>
  <li> You import that certificate, obtained from the CA, into your keychain. 
The items in that keychain can now be used in SecureTranspoert's SSLSetCertificate() 
call.</li>
 
  </ul>
 </blockquote>
  
<blockquote>One CA with an excellent web-based interface for obtaining a
cert is Verisign (<a
 href="http://www.verisign.com/products/site/index.html">http://www.verisign.com/products/site/index.html</a>). 
You can get a free 14-day trial certificate using nothing but CertTool, Verisign's
web site, and email. You need to provide some personal information; then
you paste in the CSR generated in <a
 href="#Generating%20a%20Certificate%20Signing%20Request%20%28CSR%29">Section 
3</a> into a form on the web site. A few minutes later Verisign emails you
a certificate, which you import into your keychain per <a
 href="#Importing%20a%20Certificate%20from%20a%20Certificate%20Authority">Section 
5</a>.&nbsp; The whole process takes less than 10 minutes. The free certificate 
obtained in this manner is signed by a temporary root cert which is not recognized
by any browsers, but Verisign also provides a measn of installing this temporary
root cert into your browser, directly from their web site. Typically one
would use the free, temporary cert to perform initial configuration of a
server and to ring out the general SSL infrastructure. Once you feel comfortable
with the operation of the server, then it's time to buy a "real" certificate
which will allow your web server to be recognized by any browser. 
  <p>Thawte has a similar, very friendly service at <a
 href="http://www.thawte.com">http://www.thawte.com/.</a></p>
</blockquote>
  
<blockquote>Note that, for early web server development and/or testing, you
can skip the entire procedure described above and just generate your own
self-signed root cert as described in section 1. No CA is involved; no CSR
is generated; no cert needs to be imported - CertTool generates a cert for
you and immediately adds it to your keychain. Bear in mind that this option
requires tolerance of the various SSL clients you'll be testing with, none
of whom recognize your root cert.</blockquote>
  
<blockquote>&nbsp;</blockquote>
   
<br>
</body>
</html>
