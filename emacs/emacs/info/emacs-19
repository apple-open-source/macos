This is ../info/emacs, produced by makeinfo version 4.0f from
emacs.texi.

   This is the Fourteenth edition of the `GNU Emacs Manual', updated
for Emacs version 21.2.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C)
1985,1986,1987,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002
Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto", "Distribution" and "GNU
GENERAL PUBLIC LICENSE", with the Front-Cover texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: emacs,  Node: Combining in Emerge,  Next: Fine Points of Emerge,  Prev: Exiting Emerge,  Up: Emerge

Combining the Two Versions
--------------------------

   Sometimes you want to keep _both_ alternatives for a particular
difference.  To do this, use `x c', which edits the merge buffer like
this:

     #ifdef NEW
     VERSION FROM A BUFFER
     #else /* not NEW */
     VERSION FROM B BUFFER
     #endif /* not NEW */

While this example shows C preprocessor conditionals delimiting the two
alternative versions, you can specify the strings to use by setting the
variable `emerge-combine-versions-template' to a string of your choice.
In the string, `%a' says where to put version A, and `%b' says where
to put version B.  The default setting, which produces the results
shown above, looks like this:

     "#ifdef NEW\n%a#else /* not NEW */\n%b#endif /* not NEW */\n"


File: emacs,  Node: Fine Points of Emerge,  Prev: Combining in Emerge,  Up: Emerge

Fine Points of Emerge
---------------------

   During the merge, you mustn't try to edit the A and B buffers
yourself.  Emerge modifies them temporarily, but ultimately puts them
back the way they were.

   You can have any number of merges going at once--just don't use any
one buffer as input to more than one merge at once, since the temporary
changes made in these buffers would get in each other's way.

   Starting Emerge can take a long time because it needs to compare the
files fully.  Emacs can't do anything else until `diff' finishes.
Perhaps in the future someone will change Emerge to do the comparison in
the background when the input files are large--then you could keep on
doing other things with Emacs until Emerge is ready to accept commands.

   After setting up the merge, Emerge runs the hook
`emerge-startup-hook' (*note Hooks::).


File: emacs,  Node: Abbrevs,  Next: Picture,  Prev: Maintaining,  Up: Top

Abbrevs
*******

   A defined "abbrev" is a word which "expands", if you insert it, into
some different text.  Abbrevs are defined by the user to expand in
specific ways.  For example, you might define `foo' as an abbrev
expanding to `find outer otter'.  Then you would be able to insert
`find outer otter ' into the buffer by typing `f o o <SPC>'.

   A second kind of abbreviation facility is called "dynamic abbrev
expansion".  You use dynamic abbrev expansion with an explicit command
to expand the letters in the buffer before point by looking for other
words in the buffer that start with those letters.  *Note Dynamic
Abbrevs::.

   "Hippie" expansion generalizes abbreviation expansion.  *Note Hippie
Expansion: (autotype)Hippie Expand.

* Menu:

* Abbrev Concepts::   Fundamentals of defined abbrevs.
* Defining Abbrevs::  Defining an abbrev, so it will expand when typed.
* Expanding Abbrevs:: Controlling expansion: prefixes, canceling expansion.
* Editing Abbrevs::   Viewing or editing the entire list of defined abbrevs.
* Saving Abbrevs::    Saving the entire list of abbrevs for another session.
* Dynamic Abbrevs::   Abbreviations for words already in the buffer.
* Dabbrev Customization:: What is a word, for dynamic abbrevs.  Case handling.


File: emacs,  Node: Abbrev Concepts,  Next: Defining Abbrevs,  Up: Abbrevs

Abbrev Concepts
===============

   An "abbrev" is a word which has been defined to "expand" into a
specified "expansion".  When you insert a word-separator character
following the abbrev, that expands the abbrev--replacing the abbrev
with its expansion.  For example, if `foo' is defined as an abbrev
expanding to `find outer otter', then you can insert `find outer
otter.' into the buffer by typing `f o o .'.

   Abbrevs expand only when Abbrev mode (a minor mode) is enabled.
Disabling Abbrev mode does not cause abbrev definitions to be forgotten,
but they do not expand until Abbrev mode is enabled again.  The command
`M-x abbrev-mode' toggles Abbrev mode; with a numeric argument, it
turns Abbrev mode on if the argument is positive, off otherwise.  *Note
Minor Modes::.  `abbrev-mode' is also a variable; Abbrev mode is on
when the variable is non-`nil'.  The variable `abbrev-mode'
automatically becomes local to the current buffer when it is set.

   Abbrev definitions can be "mode-specific"--active only in one major
mode.  Abbrevs can also have "global" definitions that are active in
all major modes.  The same abbrev can have a global definition and
various mode-specific definitions for different major modes.  A
mode-specific definition for the current major mode overrides a global
definition.

   Abbrevs can be defined interactively during the editing session.
Lists of abbrev definitions can also be saved in files and reloaded in
later sessions.  Some users keep extensive lists of abbrevs that they
load in every session.


File: emacs,  Node: Defining Abbrevs,  Next: Expanding Abbrevs,  Prev: Abbrev Concepts,  Up: Abbrevs

Defining Abbrevs
================

`C-x a g'
     Define an abbrev, using one or more words before point as its
     expansion (`add-global-abbrev').

`C-x a l'
     Similar, but define an abbrev specific to the current major mode
     (`add-mode-abbrev').

`C-x a i g'
     Define a word in the buffer as an abbrev
     (`inverse-add-global-abbrev').

`C-x a i l'
     Define a word in the buffer as a mode-specific abbrev
     (`inverse-add-mode-abbrev').

`M-x kill-all-abbrevs'
     This command discards all abbrev definitions currently in effect,
     leaving a blank slate.

   The usual way to define an abbrev is to enter the text you want the
abbrev to expand to, position point after it, and type `C-x a g'
(`add-global-abbrev').  This reads the abbrev itself using the
minibuffer, and then defines it as an abbrev for one or more words
before point.  Use a numeric argument to say how many words before
point should be taken as the expansion.  For example, to define the
abbrev `foo' as mentioned above, insert the text `find outer otter' and
then type `C-u 3 C-x a g f o o <RET>'.

   An argument of zero to `C-x a g' means to use the contents of the
region as the expansion of the abbrev being defined.

   The command `C-x a l' (`add-mode-abbrev') is similar, but defines a
mode-specific abbrev.  Mode-specific abbrevs are active only in a
particular major mode.  `C-x a l' defines an abbrev for the major mode
in effect at the time `C-x a l' is typed.  The arguments work the same
as for `C-x a g'.

   If the text already in the buffer is the abbrev, rather than its
expansion, use command `C-x a i g' (`inverse-add-global-abbrev')
instead of `C-x a g', or use `C-x a i l' (`inverse-add-mode-abbrev')
instead of `C-x a l'.  These commands are called "inverse" because they
invert the meaning of the two text strings they use (one from the
buffer and one read with the minibuffer).

   To change the definition of an abbrev, just define a new definition.
When the abbrev has a prior definition, the abbrev definition commands
ask for confirmation before replacing it.

   To remove an abbrev definition, give a negative argument to the
abbrev definition command: `C-u - C-x a g' or `C-u - C-x a l'.  The
former removes a global definition, while the latter removes a
mode-specific definition.

   `M-x kill-all-abbrevs' removes all the abbrev definitions there are,
both global and local.


File: emacs,  Node: Expanding Abbrevs,  Next: Editing Abbrevs,  Prev: Defining Abbrevs,  Up: Abbrevs

Controlling Abbrev Expansion
============================

   An abbrev expands whenever it is present in the buffer just before
point and you type a self-inserting whitespace or punctuation character
(<SPC>, comma, etc.).  More precisely, any character that is not a word
constituent expands an abbrev, and any word-constituent character can
be part of an abbrev.  The most common way to use an abbrev is to
insert it and then insert a punctuation character to expand it.

   Abbrev expansion preserves case; thus, `foo' expands into `find
outer otter'; `Foo' into `Find outer otter', and `FOO' into `FIND OUTER
OTTER' or `Find Outer Otter' according to the variable
`abbrev-all-caps' (a non-`nil' value chooses the first of the two
expansions).

   These commands are used to control abbrev expansion:

`M-''
     Separate a prefix from a following abbrev to be expanded
     (`abbrev-prefix-mark').

`C-x a e'
     Expand the abbrev before point (`expand-abbrev').  This is
     effective even when Abbrev mode is not enabled.

`M-x expand-region-abbrevs'
     Expand some or all abbrevs found in the region.

   You may wish to expand an abbrev with a prefix attached; for example,
if `cnst' expands into `construction', you might want to use it to
enter `reconstruction'.  It does not work to type `recnst', because
that is not necessarily a defined abbrev.  What you can do is use the
command `M-'' (`abbrev-prefix-mark') in between the prefix `re' and the
abbrev `cnst'.  First, insert `re'.  Then type `M-''; this inserts a
hyphen in the buffer to indicate that it has done its work.  Then
insert the abbrev `cnst'; the buffer now contains `re-cnst'.  Now
insert a non-word character to expand the abbrev `cnst' into
`construction'.  This expansion step also deletes the hyphen that
indicated `M-'' had been used.  The result is the desired
`reconstruction'.

   If you actually want the text of the abbrev in the buffer, rather
than its expansion, you can accomplish this by inserting the following
punctuation with `C-q'.  Thus, `foo C-q ,' leaves `foo,' in the buffer.

   If you expand an abbrev by mistake, you can undo the expansion and
bring back the abbrev itself by typing `C-_' to undo (*note Undo::).
This also undoes the insertion of the non-word character that expanded
the abbrev.  If the result you want is the terminating non-word
character plus the unexpanded abbrev, you must reinsert the terminating
character, quoting it with `C-q'.  You can also use the command `M-x
unexpand-abbrev' to cancel the last expansion without deleting the
terminating character.

   `M-x expand-region-abbrevs' searches through the region for defined
abbrevs, and for each one found offers to replace it with its expansion.
This command is useful if you have typed in text using abbrevs but
forgot to turn on Abbrev mode first.  It may also be useful together
with a special set of abbrev definitions for making several global
replacements at once.  This command is effective even if Abbrev mode is
not enabled.

   Expanding an abbrev runs the hook `pre-abbrev-expand-hook' (*note
Hooks::).


File: emacs,  Node: Editing Abbrevs,  Next: Saving Abbrevs,  Prev: Expanding Abbrevs,  Up: Abbrevs

Examining and Editing Abbrevs
=============================

`M-x list-abbrevs'
     Display a list of all abbrev definitions.  With a numeric
     argument, list only local abbrevs.

`M-x edit-abbrevs'
     Edit a list of abbrevs; you can add, alter or remove definitions.

   The output from `M-x list-abbrevs' looks like this:

     (lisp-mode-abbrev-table)
     "dk"	       0    "define-key"
     (global-abbrev-table)
     "dfn"	       0    "definition"

(Some blank lines of no semantic significance, and some other abbrev
tables, have been omitted.)

   A line containing a name in parentheses is the header for abbrevs in
a particular abbrev table; `global-abbrev-table' contains all the global
abbrevs, and the other abbrev tables that are named after major modes
contain the mode-specific abbrevs.

   Within each abbrev table, each nonblank line defines one abbrev.  The
word at the beginning of the line is the abbrev.  The number that
follows is the number of times the abbrev has been expanded.  Emacs
keeps track of this to help you see which abbrevs you actually use, so
that you can eliminate those that you don't use often.  The string at
the end of the line is the expansion.

   `M-x edit-abbrevs' allows you to add, change or kill abbrev
definitions by editing a list of them in an Emacs buffer.  The list has
the same format described above.  The buffer of abbrevs is called
`*Abbrevs*', and is in Edit-Abbrevs mode.  Type `C-c C-c' in this
buffer to install the abbrev definitions as specified in the
buffer--and delete any abbrev definitions not listed.

   The command `edit-abbrevs' is actually the same as `list-abbrevs'
except that it selects the buffer `*Abbrevs*' whereas `list-abbrevs'
merely displays it in another window.


File: emacs,  Node: Saving Abbrevs,  Next: Dynamic Abbrevs,  Prev: Editing Abbrevs,  Up: Abbrevs

Saving Abbrevs
==============

   These commands allow you to keep abbrev definitions between editing
sessions.

`M-x write-abbrev-file <RET> FILE <RET>'
     Write a file FILE describing all defined abbrevs.

`M-x read-abbrev-file <RET> FILE <RET>'
     Read the file FILE and define abbrevs as specified therein.

`M-x quietly-read-abbrev-file <RET> FILE <RET>'
     Similar but do not display a message about what is going on.

`M-x define-abbrevs'
     Define abbrevs from definitions in current buffer.

`M-x insert-abbrevs'
     Insert all abbrevs and their expansions into current buffer.

   `M-x write-abbrev-file' reads a file name using the minibuffer and
then writes a description of all current abbrev definitions into that
file.  This is used to save abbrev definitions for use in a later
session.  The text stored in the file is a series of Lisp expressions
that, when executed, define the same abbrevs that you currently have.

   `M-x read-abbrev-file' reads a file name using the minibuffer and
then reads the file, defining abbrevs according to the contents of the
file.  `M-x quietly-read-abbrev-file' is the same except that it does
not display a message in the echo area saying that it is doing its
work; it is actually useful primarily in the `.emacs' file.  If an
empty argument is given to either of these functions, they use the file
name specified in the variable `abbrev-file-name', which is by default
`"~/.abbrev_defs"'.

   Emacs will offer to save abbrevs automatically if you have changed
any of them, whenever it offers to save all files (for `C-x s' or `C-x
C-c').  This feature can be inhibited by setting the variable
`save-abbrevs' to `nil'.

   The commands `M-x insert-abbrevs' and `M-x define-abbrevs' are
similar to the previous commands but work on text in an Emacs buffer.
`M-x insert-abbrevs' inserts text into the current buffer before point,
describing all current abbrev definitions; `M-x define-abbrevs' parses
the entire current buffer and defines abbrevs accordingly.


File: emacs,  Node: Dynamic Abbrevs,  Next: Dabbrev Customization,  Prev: Saving Abbrevs,  Up: Abbrevs

Dynamic Abbrev Expansion
========================

   The abbrev facility described above operates automatically as you
insert text, but all abbrevs must be defined explicitly.  By contrast,
"dynamic abbrevs" allow the meanings of abbrevs to be determined
automatically from the contents of the buffer, but dynamic abbrev
expansion happens only when you request it explicitly.

`M-/'
     Expand the word in the buffer before point as a "dynamic abbrev",
     by searching in the buffer for words starting with that
     abbreviation (`dabbrev-expand').

`C-M-/'
     Complete the word before point as a dynamic abbrev
     (`dabbrev-completion').

   For example, if the buffer contains `does this follow ' and you type
`f o M-/', the effect is to insert `follow' because that is the last
word in the buffer that starts with `fo'.  A numeric argument to `M-/'
says to take the second, third, etc. distinct expansion found looking
backward from point.  Repeating `M-/' searches for an alternative
expansion by looking farther back.  After scanning all the text before
point, it searches the text after point.  The variable `dabbrev-limit',
if non-`nil', specifies how far in the buffer to search for an
expansion.

   After scanning the current buffer, `M-/' normally searches other
buffers, unless you have set `dabbrev-check-all-buffers' to `nil'.

   For finer control over which buffers to scan, customize the variable
`dabbrev-ignored-buffer-regexps'.  Its value is a list of regular
expressions.  If a buffer's name matches any of these regular
expressions, dynamic abbrev expansion skips that buffer.

   A negative argument to `M-/', as in `C-u - M-/', says to search
first for expansions after point, and second for expansions before
point.  If you repeat the `M-/' to look for another expansion, do not
specify an argument.  This tries all the expansions after point and
then the expansions before point.

   After you have expanded a dynamic abbrev, you can copy additional
words that follow the expansion in its original context.  Simply type
`<SPC> M-/' for each word you want to copy.  The spacing and
punctuation between words is copied along with the words.

   The command `C-M-/' (`dabbrev-completion') performs completion of a
dynamic abbreviation.  Instead of trying the possible expansions one by
one, it finds all of them, then inserts the text that they have in
common.  If they have nothing in common, `C-M-/' displays a list of
completions, from which you can select a choice in the usual manner.
*Note Completion::.

   Dynamic abbrev expansion is completely independent of Abbrev mode;
the expansion of a word with `M-/' is completely independent of whether
it has a definition as an ordinary abbrev.


File: emacs,  Node: Dabbrev Customization,  Prev: Dynamic Abbrevs,  Up: Abbrevs

Customizing Dynamic Abbreviation
================================

   Normally, dynamic abbrev expansion ignores case when searching for
expansions.  That is, the expansion need not agree in case with the word
you are expanding.

   This feature is controlled by the variable
`dabbrev-case-fold-search'.  If it is `t', case is ignored in this
search; if it is `nil', the word and the expansion must match in case.
If the value of `dabbrev-case-fold-search' is `case-fold-search', which
is true by default, then the variable `case-fold-search' controls
whether to ignore case while searching for expansions.

   Normally, dynamic abbrev expansion preserves the case pattern _of
the abbrev you have typed_, by converting the expansion to that case
pattern.

   The variable `dabbrev-case-replace' controls whether to preserve the
case pattern of the abbrev.  If it is `t', the abbrev's case pattern is
preserved in most cases; if it is `nil', the expansion is always copied
verbatim.  If the value of `dabbrev-case-replace' is `case-replace',
which is true by default, then the variable `case-replace' controls
whether to copy the expansion verbatim.

   However, if the expansion contains a complex mixed case pattern, and
the abbrev matches this pattern as far as it goes, then the expansion is
always copied verbatim, regardless of those variables.  Thus, for
example, if the buffer contains `variableWithSillyCasePattern', and you
type `v a M-/', it copies the expansion verbatim including its case
pattern.

   The variable `dabbrev-abbrev-char-regexp', if non-`nil', controls
which characters are considered part of a word, for dynamic expansion
purposes.  The regular expression must match just one character, never
two or more.  The same regular expression also determines which
characters are part of an expansion.  The value `nil' has a special
meaning: abbreviations are made of word characters, but expansions are
made of word and symbol characters.

   In shell scripts and makefiles, a variable name is sometimes prefixed
with `$' and sometimes not.  Major modes for this kind of text can
customize dynamic abbreviation to handle optional prefixes by setting
the variable `dabbrev-abbrev-skip-leading-regexp'.  Its value should be
a regular expression that matches the optional prefix that dynamic
abbreviation should ignore.


File: emacs,  Node: Picture,  Next: Sending Mail,  Prev: Abbrevs,  Up: Top

Editing Pictures
****************

   To edit a picture made out of text characters (for example, a picture
of the division of a register into fields, as a comment in a program),
use the command `M-x edit-picture' to enter Picture mode.

   In Picture mode, editing is based on the "quarter-plane" model of
text, according to which the text characters lie studded on an area that
stretches infinitely far to the right and downward.  The concept of the
end of a line does not exist in this model; the most you can say is
where the last nonblank character on the line is found.

   Of course, Emacs really always considers text as a sequence of
characters, and lines really do have ends.  But Picture mode replaces
the most frequently-used commands with variants that simulate the
quarter-plane model of text.  They do this by inserting spaces or by
converting tabs to spaces.

   Most of the basic editing commands of Emacs are redefined by Picture
mode to do essentially the same thing but in a quarter-plane way.  In
addition, Picture mode defines various keys starting with the `C-c'
prefix to run special picture editing commands.

   One of these keys, `C-c C-c', is pretty important.  Often a picture
is part of a larger file that is usually edited in some other major
mode.  `M-x edit-picture' records the name of the previous major mode
so you can use the `C-c C-c' command (`picture-mode-exit') later to go
back to that mode.  `C-c C-c' also deletes spaces from the ends of
lines, unless given a numeric argument.

   The special commands of Picture mode all work in other modes
(provided the `picture' library is loaded), but are not bound to keys
except in Picture mode.  The descriptions below talk of moving "one
column" and so on, but all the picture mode commands handle numeric
arguments as their normal equivalents do.

   Turning on Picture mode runs the hook `picture-mode-hook' (*note
Hooks::).

* Menu:

* Basic Picture::         Basic concepts and simple commands of Picture Mode.
* Insert in Picture::     Controlling direction of cursor motion
                            after "self-inserting" characters.
* Tabs in Picture::       Various features for tab stops and indentation.
* Rectangles in Picture:: Clearing and superimposing rectangles.


File: emacs,  Node: Basic Picture,  Next: Insert in Picture,  Prev: Picture,  Up: Picture

Basic Editing in Picture Mode
=============================

   Most keys do the same thing in Picture mode that they usually do, but
do it in a quarter-plane style.  For example, `C-f' is rebound to run
`picture-forward-column', a command which moves point one column to the
right, inserting a space if necessary so that the actual end of the
line makes no difference.  `C-b' is rebound to run
`picture-backward-column', which always moves point left one column,
converting a tab to multiple spaces if necessary.  `C-n' and `C-p' are
rebound to run `picture-move-down' and `picture-move-up', which can
either insert spaces or convert tabs as necessary to make sure that
point stays in exactly the same column.  `C-e' runs
`picture-end-of-line', which moves to after the last nonblank character
on the line.  There is no need to change `C-a', as the choice of screen
model does not affect beginnings of lines.

   Insertion of text is adapted to the quarter-plane screen model
through the use of Overwrite mode (*note Minor Modes::).
Self-inserting characters replace existing text, column by column,
rather than pushing existing text to the right.  <RET> runs
`picture-newline', which just moves to the beginning of the following
line so that new text will replace that line.

   Picture mode provides erasure instead of deletion and killing of
text.  <DEL> (`picture-backward-clear-column') replaces the preceding
character with a space rather than removing it; this moves point
backwards.  `C-d' (`picture-clear-column') replaces the next character
or characters with spaces, but does not move point.  (If you want to
clear characters to spaces and move forward over them, use <SPC>.)
`C-k' (`picture-clear-line') really kills the contents of lines, but
does not delete the newlines from the buffer.

   To do actual insertion, you must use special commands.  `C-o'
(`picture-open-line') creates a blank line after the current line; it
never splits a line.  `C-M-o' (`split-line') makes sense in Picture
mode, so it is not changed.  `C-j' (`picture-duplicate-line') inserts
below the current line another line with the same contents.

   To do actual deletion in Picture mode, use `C-w', `C-c C-d' (which
is defined as `delete-char', as `C-d' is in other modes), or one of the
picture rectangle commands (*note Rectangles in Picture::).


File: emacs,  Node: Insert in Picture,  Next: Tabs in Picture,  Prev: Basic Picture,  Up: Picture

Controlling Motion after Insert
===============================

   Since "self-inserting" characters in Picture mode overwrite and move
point, there is no essential restriction on how point should be moved.
Normally point moves right, but you can specify any of the eight
orthogonal or diagonal directions for motion after a "self-inserting"
character.  This is useful for drawing lines in the buffer.

`C-c <'
     Move left after insertion (`picture-movement-left').

`C-c >'
     Move right after insertion (`picture-movement-right').

`C-c ^'
     Move up after insertion (`picture-movement-up').

`C-c .'
     Move down after insertion (`picture-movement-down').

`C-c `'
     Move up and left ("northwest") after insertion
     (`picture-movement-nw').

`C-c ''
     Move up and right ("northeast") after insertion
     (`picture-movement-ne').

`C-c /'
     Move down and left ("southwest") after insertion
     (`picture-movement-sw').

`C-c \'
     Move down and right ("southeast") after insertion
     (`picture-movement-se').

   Two motion commands move based on the current Picture insertion
direction.  The command `C-c C-f' (`picture-motion') moves in the same
direction as motion after "insertion" currently does, while `C-c C-b'
(`picture-motion-reverse') moves in the opposite direction.


File: emacs,  Node: Tabs in Picture,  Next: Rectangles in Picture,  Prev: Insert in Picture,  Up: Picture

Picture Mode Tabs
=================

   Two kinds of tab-like action are provided in Picture mode.  Use
`M-<TAB>' (`picture-tab-search') for context-based tabbing.  With no
argument, it moves to a point underneath the next "interesting"
character that follows whitespace in the previous nonblank line.
"Next" here means "appearing at a horizontal position greater than the
one point starts out at."  With an argument, as in `C-u M-<TAB>', this
command moves to the next such interesting character in the current
line.  `M-<TAB>' does not change the text; it only moves point.
"Interesting" characters are defined by the variable
`picture-tab-chars', which should define a set of characters.  The
syntax for this variable is like the syntax used inside of `[...]' in a
regular expression--but without the `[' and the `]'.  Its default value
is `"!-~"'.

   <TAB> itself runs `picture-tab', which operates based on the current
tab stop settings; it is the Picture mode equivalent of
`tab-to-tab-stop'.  Normally it just moves point, but with a numeric
argument it clears the text that it moves over.

   The context-based and tab-stop-based forms of tabbing are brought
together by the command `C-c <TAB>' (`picture-set-tab-stops').  This
command sets the tab stops to the positions which `M-<TAB>' would
consider significant in the current line.  The use of this command,
together with <TAB>, can get the effect of context-based tabbing.  But
`M-<TAB>' is more convenient in the cases where it is sufficient.

   It may be convenient to prevent use of actual tab characters in
pictures.  For example, this prevents `C-x <TAB>' from messing up the
picture.  You can do this by setting the variable `indent-tabs-mode' to
`nil'.  *Note Just Spaces::.


File: emacs,  Node: Rectangles in Picture,  Prev: Tabs in Picture,  Up: Picture

Picture Mode Rectangle Commands
===============================

   Picture mode defines commands for working on rectangular pieces of
the text in ways that fit with the quarter-plane model.  The standard
rectangle commands may also be useful (*note Rectangles::).

`C-c C-k'
     Clear out the region-rectangle with spaces
     (`picture-clear-rectangle').  With argument, delete the text.

`C-c C-w R'
     Similar, but save rectangle contents in register R first
     (`picture-clear-rectangle-to-register').

`C-c C-y'
     Copy last killed rectangle into the buffer by overwriting, with
     upper left corner at point (`picture-yank-rectangle').  With
     argument, insert instead.

`C-c C-x R'
     Similar, but use the rectangle in register R
     (`picture-yank-rectangle-from-register').

   The picture rectangle commands `C-c C-k' (`picture-clear-rectangle')
and `C-c C-w' (`picture-clear-rectangle-to-register') differ from the
standard rectangle commands in that they normally clear the rectangle
instead of deleting it; this is analogous with the way `C-d' is changed
in Picture mode.

   However, deletion of rectangles can be useful in Picture mode, so
these commands delete the rectangle if given a numeric argument.  `C-c
C-k' either with or without a numeric argument saves the rectangle for
`C-c C-y'.

   The Picture mode commands for yanking rectangles differ from the
standard ones in that they overwrite instead of inserting.  This is the
same way that Picture mode insertion of other text differs from other
modes.  `C-c C-y' (`picture-yank-rectangle') inserts (by overwriting)
the rectangle that was most recently killed, while `C-c C-x'
(`picture-yank-rectangle-from-register') does likewise for the
rectangle found in a specified register.


File: emacs,  Node: Sending Mail,  Next: Rmail,  Prev: Picture,  Up: Top

Sending Mail
************

   To send a message in Emacs, you start by typing a command (`C-x m')
to select and initialize the `*mail*' buffer.  Then you edit the text
and headers of the message in this buffer, and type another command
(`C-c C-s' or `C-c C-c') to send the message.

`C-x m'
     Begin composing a message to send (`compose-mail').

`C-x 4 m'
     Likewise, but display the message in another window
     (`compose-mail-other-window').

`C-x 5 m'
     Likewise, but make a new frame (`compose-mail-other-frame').

`C-c C-s'
     In Mail mode, send the message (`mail-send').

`C-c C-c'
     Send the message and bury the mail buffer (`mail-send-and-exit').

   The command `C-x m' (`compose-mail') selects a buffer named `*mail*'
and initializes it with the skeleton of an outgoing message.  `C-x 4 m'
(`compose-mail-other-window') selects the `*mail*' buffer in a
different window, leaving the previous current buffer visible.  `C-x 5
m' (`compose-mail-other-frame') creates a new frame to select the
`*mail*' buffer.

   Because the mail-composition buffer is an ordinary Emacs buffer, you
can switch to other buffers while in the middle of composing mail, and
switch back later (or never).  If you use the `C-x m' command again
when you have been composing another message but have not sent it, you
are asked to confirm before the old message is erased.  If you answer
`n', the `*mail*' buffer is left selected with its old contents, so you
can finish the old message and send it.  `C-u C-x m' is another way to
do this.  Sending the message marks the `*mail*' buffer "unmodified,"
which avoids the need for confirmation when `C-x m' is next used.

   If you are composing a message in the `*mail*' buffer and want to
send another message before finishing the first, rename the `*mail*'
buffer using `M-x rename-uniquely' (*note Misc Buffer::).  Then you can
use `C-x m' or its variants described above to make a new `*mail*'
buffer.  Once you've done that, you can work with each mail buffer
independently.

* Menu:

* Format: Mail Format.	     Format of the mail being composed.
* Headers: Mail Headers.     Details of permitted mail header fields.
* Aliases: Mail Aliases.     Abbreviating and grouping mail addresses.
* Mode: Mail Mode.	     Special commands for editing mail being composed.
* Amuse: Mail Amusements.    Distracting the NSA; adding fortune messages.
* Methods: Mail Methods.     Using alternative mail-composition methods.


File: emacs,  Node: Mail Format,  Next: Mail Headers,  Up: Sending Mail

The Format of the Mail Buffer
=============================

   In addition to the "text" or "body", a message has "header fields"
which say who sent it, when, to whom, why, and so on.  Some header
fields, such as `Date' and `Sender', are created automatically when you
send the message.  Others, such as the recipient names, must be
specified by you in order to send the message properly.

   Mail mode provides a few commands to help you edit some header
fields, and some are preinitialized in the buffer automatically at
times.  You can insert and edit header fields using ordinary editing
commands.

   The line in the buffer that says

     --text follows this line--

is a special delimiter that separates the headers you have specified
from the text.  Whatever follows this line is the text of the message;
the headers precede it.  The delimiter line itself does not appear in
the message actually sent.  The text used for the delimiter line is
controlled by the variable `mail-header-separator'.

   Here is an example of what the headers and text in the mail buffer
might look like.

     To: gnu@gnu.org
     CC: lungfish@spam.org, byob@spam.org
     Subject: The Emacs Manual
     --Text follows this line--
     Please ignore this message.


File: emacs,  Node: Mail Headers,  Next: Mail Aliases,  Prev: Mail Format,  Up: Sending Mail

Mail Header Fields
==================

   A header field in the mail buffer starts with a field name at the
beginning of a line, terminated by a colon.  Upper and lower case are
equivalent in field names (and in mailing addresses also).  After the
colon and optional whitespace comes the contents of the field.

   You can use any name you like for a header field, but normally people
use only standard field names with accepted meanings.  Here is a table
of fields commonly used in outgoing messages.

`To'
     This field contains the mailing addresses to which the message is
     addressed.  If you list more than one address, use commas, not
     spaces, to separate them.

`Subject'
     The contents of the `Subject' field should be a piece of text that
     says what the message is about.  The reason `Subject' fields are
     useful is that most mail-reading programs can provide a summary of
     messages, listing the subject of each message but not its text.

`CC'
     This field contains additional mailing addresses to send the
     message to, like `To' except that these readers should not regard
     the message as directed at them.

`BCC'
     This field contains additional mailing addresses to send the
     message to, which should not appear in the header of the message
     actually sent.  Copies sent this way are called "blind carbon
     copies".

     To send a blind carbon copy of every outgoing message to yourself,
     set the variable `mail-self-blind' to `t'.  To send a blind carbon
     copy of every message to some other ADDRESS, set the variable
     `mail-default-headers' to `"Bcc: ADDRESS\n"'.

`FCC'
     This field contains the name of one file and directs Emacs to
     append a copy of the message to that file when you send the
     message.  If the file is in Rmail format, Emacs writes the message
     in Rmail format; otherwise, Emacs writes the message in system
     mail file format.  To specify more than one file, use several
     `FCC' fields, with one file name in each field.

     To put a fixed file name in the `FCC' field each time you start
     editing an outgoing message, set the variable
     `mail-archive-file-name' to that file name.  Unless you remove the
     `FCC' field before sending, the message will be written into that
     file when it is sent.

`From'
     Use the `From' field to say who you are, when the account you are
     using to send the mail is not your own.  The contents of the `From'
     field should be a valid mailing address, since replies will
     normally go there.  If you don't specify the `From' field
     yourself, Emacs uses the value of `user-mail-address' as the
     default.

`Reply-to'
     Use this field to direct replies to a different address.  Most
     mail-reading programs (including Rmail) automatically send replies
     to the `Reply-to' address in preference to the `From' address.  By
     adding a `Reply-to' field to your header, you can work around any
     problems your `From' address may cause for replies.

     To put a fixed `Reply-to' address into every outgoing message, set
     the variable `mail-default-reply-to' to that address (as a string).
     Then `mail' initializes the message with a `Reply-to' field as
     specified.  You can delete or alter that header field before you
     send the message, if you wish.  When Emacs starts up, if the
     environment variable `REPLYTO' is set, `mail-default-reply-to' is
     initialized from that environment variable.

`In-reply-to'
     This field contains a piece of text describing the message you are
     replying to.  Some mail systems can use this information to
     correlate related pieces of mail.  Normally this field is filled
     in by Rmail when you reply to a message in Rmail, and you never
     need to think about it (*note Rmail::).

`References'
     This field lists the message IDs of related previous messages.
     Rmail sets up this field automatically when you reply to a message.

   The `To', `CC', and `BCC' header fields can appear any number of
times, and each such header field can contain multiple addresses,
separated by commas.  This way, you can specify any number of places to
send the message.  These fields can also have continuation lines: one
or more lines starting with whitespace, following the starting line of
the field, are considered part of the field.  Here's an example of a
`To' field with a continuation line:

     To: foo@here.net, this@there.net,
       me@gnu.cambridge.mass.usa.earth.spiral3281

   When you send the message, if you didn't write a `From' field
yourself, Emacs puts in one for you.  The variable `mail-from-style'
controls the format:

`nil'
     Use just the email address, as in `king@grassland.com'.

`parens'
     Use both email address and full name, as in `king@grassland.com
     (Elvis Parsley)'.

`angles'
     Use both email address and full name, as in `Elvis Parsley
     <king@grassland.com>'.

`system-default'
     Allow the system to insert the `From' field.

   You can direct Emacs to insert certain default headers into the
outgoing message by setting the variable `mail-default-headers' to a
string.  Then `C-x m' inserts this string into the message headers.  If
the default header fields are not appropriate for a particular message,
edit them as appropriate before sending the message.


File: emacs,  Node: Mail Aliases,  Next: Mail Mode,  Prev: Mail Headers,  Up: Sending Mail

Mail Aliases
============

   You can define "mail aliases" in a file named `~/.mailrc'.  These
are short mnemonic names which stand for mail addresses or groups of
mail addresses.  Like many other mail programs, Emacs expands aliases
when they occur in the `To', `From', `CC', `BCC', and `Reply-to'
fields, plus their `Resent-' variants.

   To define an alias in `~/.mailrc', write a line in the following
format:

     alias SHORTADDRESS FULLADDRESSES

Here FULLADDRESSES stands for one or more mail addresses for
SHORTADDRESS to expand into.  Separate multiple addresses with spaces;
if an address contains a space, quote the whole address with a pair of
double-quotes.

   For instance, to make `maingnu' stand for `gnu@gnu.org' plus a local
address of your own, put in this line:

     alias maingnu gnu@gnu.org local-gnu

   Emacs also recognizes include commands in `.mailrc' files.  They
look like this:

     source FILENAME

The file `~/.mailrc' is used primarily by other mail-reading programs;
it can contain various other commands.  Emacs ignores everything in it
except for alias definitions and include commands.

   Another way to define a mail alias, within Emacs alone, is with the
`define-mail-alias' command.  It prompts for the alias and then the
full address.  You can use it to define aliases in your `.emacs' file,
like this:

     (define-mail-alias "maingnu" "gnu@gnu.org")

   `define-mail-alias' records aliases by adding them to a variable
named `mail-aliases'.  If you are comfortable with manipulating Lisp
lists, you can set `mail-aliases' directly.  The initial value of
`mail-aliases' is `t', which means that Emacs should read `.mailrc' to
get the proper value.

   You can specify a different file name to use instead of `~/.mailrc'
by setting the variable `mail-personal-alias-file'.

   Normally, Emacs expands aliases when you send the message.  You do
not need to expand mail aliases before sending the message, but you can
expand them if you want to see where the mail will actually go.  To do
this, use the command `M-x expand-mail-aliases'; it expands all mail
aliases currently present in the mail headers that hold addresses.

   If you like, you can have mail aliases expand as abbrevs, as soon as
you type them in (*note Abbrevs::).  To enable this feature, execute the
following:

     (add-hook 'mail-mode-hook 'mail-abbrevs-setup)

This can go in your `.emacs' file.  *Note Hooks::.  If you use this
feature, you must use `define-mail-abbrev' instead of
`define-mail-alias'; the latter does not work with this package.  Note
that the mail abbreviation package uses the variable `mail-abbrevs'
instead of `mail-aliases', and that all alias names are converted to
lower case.

   The mail abbreviation package also provides the `C-c C-a'
(`mail-interactive-insert-alias') command, which reads an alias name
(with completion) and inserts its definition at point.  This is useful
when editing the message text itself or a header field such as
`Subject' in which Emacs does not normally expand aliases.

   Note that abbrevs expand only if you insert a word-separator
character afterward.  However, you can rebind `C-n' and `M->' to cause
expansion as well.  Here's how to do that:

     (add-hook 'mail-mode-hook
               (lambda ()
                 (substitute-key-definition
                   'next-line 'mail-abbrev-next-line
                   mail-mode-map global-map)
                 (substitute-key-definition
                   'end-of-buffer 'mail-abbrev-end-of-buffer
                   mail-mode-map global-map)))


File: emacs,  Node: Mail Mode,  Next: Mail Amusements,  Prev: Mail Aliases,  Up: Sending Mail

Mail Mode
=========

   The major mode used in the mail buffer is Mail mode, which is much
like Text mode except that various special commands are provided on the
`C-c' prefix.  These commands all have to do specifically with editing
or sending the message.  In addition, Mail mode defines the character
`%' as a word separator; this is helpful for using the word commands to
edit mail addresses.

   Mail mode is normally used in buffers set up automatically by the
`mail' command and related commands.  However, you can also switch to
Mail mode in a file-visiting buffer.  This is a useful thing to do if
you have saved the text of a draft message in a file.

* Menu:

* Mail Sending::        Commands to send the message.
* Header Editing::      Commands to move to header fields and edit them.
* Citing Mail::         Copying all or part of a message you are replying to.
* Mail Mode Misc::      Spell checking, signatures, etc.


File: emacs,  Node: Mail Sending,  Next: Header Editing,  Up: Mail Mode

Mail Sending
------------

   Mail mode has two commands for sending the message you have been
editing:

`C-c C-s'
     Send the message, and leave the mail buffer selected (`mail-send').

`C-c C-c'
     Send the message, and select some other buffer
     (`mail-send-and-exit').

   `C-c C-s' (`mail-send') sends the message and marks the mail buffer
unmodified, but leaves that buffer selected so that you can modify the
message (perhaps with new recipients) and send it again.  `C-c C-c'
(`mail-send-and-exit') sends and then deletes the window or switches to
another buffer.  It puts the mail buffer at the lowest priority for
reselection by default, since you are finished with using it.  This is
the usual way to send the message.

   In a file-visiting buffer, sending the message does not clear the
modified flag, because only saving the file should do that.  As a
result, you don't get a warning if you try to send the same message
twice.

   When you send a message that contains non-ASCII characters, they need
to be encoded with a coding system (*note Coding Systems::).  Usually
the coding system is specified automatically by your chosen language
environment (*note Language Environments::).  You can explicitly specify
the coding system for outgoing mail by setting the variable
`sendmail-coding-system' (*note Recognize Coding::).

   If the coding system thus determined does not handle the characters
in a particular message, Emacs asks you to select the coding system to
use, showing a list of possible coding systems.


File: emacs,  Node: Header Editing,  Next: Citing Mail,  Prev: Mail Sending,  Up: Mail Mode

Mail Header Editing
-------------------

   Mail mode provides special commands to move to particular header
fields and to complete addresses in headers.

`C-c C-f C-t'
     Move to the `To' header field, creating one if there is none
     (`mail-to').

`C-c C-f C-s'
     Move to the `Subject' header field, creating one if there is none
     (`mail-subject').

`C-c C-f C-c'
     Move to the `CC' header field, creating one if there is none
     (`mail-cc').

`C-c C-f C-b'
     Move to the `BCC' header field, creating one if there is none
     (`mail-bcc').

`C-c C-f C-f'
     Move to the `FCC' header field, creating one if there is none
     (`mail-fcc').

`M-<TAB>'
     Complete a mailing address (`mail-complete').

   There are five commands to move point to particular header fields,
all based on the prefix `C-c C-f' (`C-f' is for "field").  They are
listed in the table above.  If the field in question does not exist,
these commands create one.  We provide special motion commands for these
particular fields because they are the fields users most often want to
edit.

   While editing a header field that contains mailing addresses, such as
`To:', `CC:' and `BCC:', you can complete a mailing address by typing
`M-<TAB>' (`mail-complete').  It inserts the full name corresponding to
the address, if it can determine the full name.  The variable
`mail-complete-style' controls whether to insert the full name, and
what style to use, as in `mail-from-style' (*note Mail Headers::).

   For completion purposes, the valid mailing addresses are taken to be
the local users' names plus your personal mail aliases.  You can
specify additional sources of valid addresses; look at the customization
group `mailalias' to see the options for this (*note Customization
Groups::).

   If you type `M-<TAB>' in the body of the message, `mail-complete'
invokes `ispell-complete-word', as in Text mode.


File: emacs,  Node: Citing Mail,  Next: Mail Mode Misc,  Prev: Header Editing,  Up: Mail Mode

Citing Mail
-----------

   Mail mode also has commands for yanking or "citing" all or part of a
message that you are replying to.  These commands are active only when
you started sending a message using an Rmail command.

`C-c C-y'
     Yank the selected message from Rmail (`mail-yank-original').

`C-c C-r'
     Yank the region from the Rmail buffer (`mail-yank-region').

`C-c C-q'
     Fill each paragraph cited from another message
     (`mail-fill-yanked-message').

   When mail sending is invoked from the Rmail mail reader using an
Rmail command, `C-c C-y' can be used inside the mail buffer to insert
the text of the message you are replying to.  Normally it indents each
line of that message three spaces and eliminates most header fields.  A
numeric argument specifies the number of spaces to indent.  An argument
of just `C-u' says not to indent at all and not to eliminate anything.
`C-c C-y' always uses the current message from the Rmail buffer, so you
can insert several old messages by selecting one in Rmail, switching to
`*mail*' and yanking it, then switching back to Rmail to select another.

   You can specify the text for `C-c C-y' to insert at the beginning of
each line: set `mail-yank-prefix' to the desired string.  (A value of
`nil' means to use indentation; this is the default.)  However, `C-u
C-c C-y' never adds anything at the beginning of the inserted lines,
regardless of the value of `mail-yank-prefix'.

   To yank just a part of an incoming message, set the region in Rmail
to the part you want; then go to the `*Mail*' message and type `C-c
C-r' (`mail-yank-region').  Each line that is copied is indented or
prefixed according to `mail-yank-prefix'.

   After using `C-c C-y' or `C-c C-r', you can type `C-c C-q'
(`mail-fill-yanked-message') to fill the paragraphs of the yanked old
message or messages.  One use of `C-c C-q' fills all such paragraphs,
each one individually.  To fill a single paragraph of the quoted
message, use `M-q'.  If filling does not automatically handle the type
of citation prefix you use, try setting the fill prefix explicitly.
*Note Filling::.

