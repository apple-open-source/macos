This is ../info/emacs, produced by makeinfo version 4.0f from
emacs.texi.

   This is the Fourteenth edition of the `GNU Emacs Manual', updated
for Emacs version 21.2.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C)
1985,1986,1987,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002
Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto", "Distribution" and "GNU
GENERAL PUBLIC LICENSE", with the Front-Cover texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: emacs,  Node: Sorting,  Next: Narrowing,  Prev: PostScript Variables,  Up: Top

Sorting Text
============

   Emacs provides several commands for sorting text in the buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
into the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numeric sorting, in
numeric order.  In alphabetic sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accord with the ASCII
character sequence.

   The various sort commands differ in how they divide the text into
sort records and in which part of each record is used as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines, and sort by comparing the entire
     text of a line.  A numeric argument means sort into descending
     order.

`M-x sort-paragraphs'
     Divide the region into paragraphs, and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A numeric
     argument means sort into descending order.

`M-x sort-pages'
     Divide the region into pages, and sort by comparing the entire
     text of a page (except for leading blank lines).  A numeric
     argument means sort into descending order.

`M-x sort-fields'
     Divide the region into lines, and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     Specify which field to sort by with a numeric argument: 1 to sort
     by field 1, etc.  A negative argument means count fields from the
     right instead of from the left; thus, minus 1 means sort by the
     last field.  If several lines have identical contents in the field
     being sorted, they keep the same relative order that they had in
     the original buffer.

`M-x sort-numeric-fields'
     Like `M-x sort-fields' except the specified field is converted to
     an integer for each line, and the numbers are compared.  `10'
     comes before `2' when considered as text, but after it when
     considered as a number.  By default, numbers are interpreted
     according to `sort-numeric-base', but numbers beginning with `0x'
     or `0' are interpreted as hexadecimal and octal, respectively.

`M-x sort-columns'
     Like `M-x sort-fields' except that the text within each line used
     for comparison comes from a fixed range of columns.  See below for
     an explanation.

`M-x reverse-region'
     Reverse the order of the lines in the region.  This is useful for
     sorting into descending order by fields or columns, since those
     sort commands do not have a feature for doing that.

   For example, if the buffer contains this:

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

applying `M-x sort-lines' to the entire buffer produces this:

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper-case `O' sorts before all lower-case letters.  If you
use `C-u 2 M-x sort-fields' instead, you get this:

     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `Emacs', `If', `buffer', `systems' and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line of the text you want to sort, this command
uses an unusual definition of "region": all of the line point is in is
considered part of the region, and so is all of the line the mark is in,
as well as all the lines in between.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then run
`sort-columns'.  Equivalently, you could run it with the mark on column
15 in the first line and point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

   Many of the sort commands ignore case differences when comparing, if
`sort-fold-case' is non-`nil'.


File: emacs,  Node: Narrowing,  Next: Two-Column,  Prev: Sorting,  Up: Top

Narrowing
=========

   "Narrowing" means focusing in on some portion of the buffer, making
the rest temporarily inaccessible.  The portion which you can still get
to is called the "accessible portion".  Canceling the narrowing, which
makes the entire buffer once again accessible, is called "widening".
The amount of narrowing in effect in a buffer at any time is called the
buffer's "restriction".

   Narrowing can make it easier to concentrate on a single subroutine or
paragraph by eliminating clutter.  It can also be used to restrict the
range of operation of a replace command or repeating keyboard macro.

`C-x n n'
     Narrow down to between point and mark (`narrow-to-region').

`C-x n w'
     Widen to make the entire buffer accessible again (`widen').

`C-x n p'
     Narrow down to the current page (`narrow-to-page').

`C-x n d'
     Narrow down to the current defun (`narrow-to-defun').

   When you have narrowed down to a part of the buffer, that part
appears to be all there is.  You can't see the rest, you can't move
into it (motion commands won't go outside the accessible part), you
can't change it in any way.  However, it is not gone, and if you save
the file all the inaccessible text will be saved.  The word `Narrow'
appears in the mode line whenever narrowing is in effect.

   The primary narrowing command is `C-x n n' (`narrow-to-region').  It
sets the current buffer's restrictions so that the text in the current
region remains accessible, but all text before the region or after the
region is inaccessible.  Point and mark do not change.

   Alternatively, use `C-x n p' (`narrow-to-page') to narrow down to
the current page.  *Note Pages::, for the definition of a page.  `C-x n
d' (`narrow-to-defun') narrows down to the defun containing point
(*note Defuns::).

   The way to cancel narrowing is to widen with `C-x n w' (`widen').
This makes all text in the buffer accessible again.

   You can get information on what part of the buffer you are narrowed
down to using the `C-x =' command.  *Note Position Info::.

   Because narrowing can easily confuse users who do not understand it,
`narrow-to-region' is normally a disabled command.  Attempting to use
this command asks for confirmation and gives you the option of enabling
it; if you enable the command, confirmation will no longer be required
for it.  *Note Disabling::.


File: emacs,  Node: Two-Column,  Next: Editing Binary Files,  Prev: Narrowing,  Up: Top

Two-Column Editing
==================

   Two-column mode lets you conveniently edit two side-by-side columns
of text.  It uses two side-by-side windows, each showing its own buffer.

   There are three ways to enter two-column mode:

`<F2> 2' or `C-x 6 2'
     Enter two-column mode with the current buffer on the left, and on
     the right, a buffer whose name is based on the current buffer's
     name (`2C-two-columns').  If the right-hand buffer doesn't already
     exist, it starts out empty; the current buffer's contents are not
     changed.

     This command is appropriate when the current buffer is empty or
     contains just one column and you want to add another column.

`<F2> s' or `C-x 6 s'
     Split the current buffer, which contains two-column text, into two
     buffers, and display them side by side (`2C-split').  The current
     buffer becomes the left-hand buffer, but the text in the right-hand
     column is moved into the right-hand buffer.  The current column
     specifies the split point.  Splitting starts with the current line
     and continues to the end of the buffer.

     This command is appropriate when you have a buffer that already
     contains two-column text, and you wish to separate the columns
     temporarily.

`<F2> b BUFFER <RET>'
`C-x 6 b BUFFER <RET>'
     Enter two-column mode using the current buffer as the left-hand
     buffer, and using buffer BUFFER as the right-hand buffer
     (`2C-associate-buffer').

   `<F2> s' or `C-x 6 s' looks for a column separator, which is a
string that appears on each line between the two columns.  You can
specify the width of the separator with a numeric argument to `<F2> s';
that many characters, before point, constitute the separator string.
By default, the width is 1, so the column separator is the character
before point.

   When a line has the separator at the proper place, `<F2> s' puts the
text after the separator into the right-hand buffer, and deletes the
separator.  Lines that don't have the column separator at the proper
place remain unsplit; they stay in the left-hand buffer, and the
right-hand buffer gets an empty line to correspond.  (This is the way
to write a line that "spans both columns while in two-column mode":
write it in the left-hand buffer, and put an empty line in the
right-hand buffer.)

   The command `C-x 6 <RET>' or `<F2> <RET>' (`2C-newline') inserts a
newline in each of the two buffers at corresponding positions.  This is
the easiest way to add a new line to the two-column text while editing
it in split buffers.

   When you have edited both buffers as you wish, merge them with `<F2>
1' or `C-x 6 1' (`2C-merge').  This copies the text from the right-hand
buffer as a second column in the other buffer.  To go back to
two-column editing, use `<F2> s'.

   Use `<F2> d' or `C-x 6 d' to dissociate the two buffers, leaving
each as it stands (`2C-dissociate').  If the other buffer, the one not
current when you type `<F2> d', is empty, `<F2> d' kills it.


File: emacs,  Node: Editing Binary Files,  Next: Saving Emacs Sessions,  Prev: Two-Column,  Up: Top

Editing Binary Files
====================

   There is a special major mode for editing binary files: Hexl mode.
To use it, use `M-x hexl-find-file' instead of `C-x C-f' to visit the
file.  This command converts the file's contents to hexadecimal and
lets you edit the translation.  When you save the file, it is converted
automatically back to binary.

   You can also use `M-x hexl-mode' to translate an existing buffer
into hex.  This is useful if you visit a file normally and then discover
it is a binary file.

   Ordinary text characters overwrite in Hexl mode.  This is to reduce
the risk of accidentally spoiling the alignment of data in the file.
There are special commands for insertion.  Here is a list of the
commands of Hexl mode:

`C-M-d'
     Insert a byte with a code typed in decimal.

`C-M-o'
     Insert a byte with a code typed in octal.

`C-M-x'
     Insert a byte with a code typed in hex.

`C-x ['
     Move to the beginning of a 1k-byte "page."

`C-x ]'
     Move to the end of a 1k-byte "page."

`M-g'
     Move to an address specified in hex.

`M-j'
     Move to an address specified in decimal.

`C-c C-c'
     Leave Hexl mode, going back to the major mode this buffer had
     before you invoked `hexl-mode'.

Other Hexl commands let you insert strings (sequences) of binary bytes,
move by `short's or `int's, etc.; type `C-h a hexl-<RET>' for details.


File: emacs,  Node: Saving Emacs Sessions,  Next: Recursive Edit,  Prev: Editing Binary Files,  Up: Top

Saving Emacs Sessions
=====================

   You can use the Desktop library to save the state of Emacs from one
session to another.  Saving the state means that Emacs starts up with
the same set of buffers, major modes, buffer positions, and so on that
the previous Emacs session had.

   To use Desktop, you should use the Customization buffer (*note Easy
Customization::) to set `desktop-enable' to a non-`nil' value, or add
these lines at the end of your `.emacs' file:

     (desktop-load-default)
     (desktop-read)

The first time you save the state of the Emacs session, you must do it
manually, with the command `M-x desktop-save'.  Once you have done
that, exiting Emacs will save the state again--not only the present
Emacs session, but also subsequent sessions.  You can also save the
state at any time, without exiting Emacs, by typing `M-x desktop-save'
again.

   In order for Emacs to recover the state from a previous session, you
must start it with the same current directory as you used when you
started the previous session.  This is because `desktop-read' looks in
the current directory for the file to read.  This means that you can
have separate saved sessions in different directories; the directory in
which you start Emacs will control which saved session to use.

   The variable `desktop-files-not-to-save' controls which files are
excluded from state saving.  Its value is a regular expression that
matches the files to exclude.  By default, remote (ftp-accessed) files
are excluded; this is because visiting them again in the subsequent
session would be slow.  If you want to include these files in state
saving, set `desktop-files-not-to-save' to `"^$"'.  *Note Remote
Files::.

   The Saveplace library provides a simpler feature that records your
position in each file when you kill its buffer (or kill Emacs), and
jumps to the same position when you visit the file again (even in
another Emacs session).  Use `M-x toggle-save-place' to turn on
place-saving in a given file.  Customize the option `save-place' to
turn it on for all files in each session.


File: emacs,  Node: Recursive Edit,  Next: Emulation,  Prev: Saving Emacs Sessions,  Up: Top

Recursive Editing Levels
========================

   A "recursive edit" is a situation in which you are using Emacs
commands to perform arbitrary editing while in the middle of another
Emacs command.  For example, when you type `C-r' inside of a
`query-replace', you enter a recursive edit in which you can change the
current buffer.  On exiting from the recursive edit, you go back to the
`query-replace'.

   "Exiting" the recursive edit means returning to the unfinished
command, which continues execution.  The command to exit is `C-M-c'
(`exit-recursive-edit').

   You can also "abort" the recursive edit.  This is like exiting, but
also quits the unfinished command immediately.  Use the command `C-]'
(`abort-recursive-edit') to do this.  *Note Quitting::.

   The mode line shows you when you are in a recursive edit by
displaying square brackets around the parentheses that always surround
the major and minor mode names.  Every window's mode line shows this in
the same way, since being in a recursive edit is true of Emacs as a
whole rather than any particular window or buffer.

   It is possible to be in recursive edits within recursive edits.  For
example, after typing `C-r' in a `query-replace', you may type a
command that enters the debugger.  This begins a recursive editing level
for the debugger, within the recursive editing level for `C-r'.  Mode
lines display a pair of square brackets for each recursive editing
level currently in progress.

   Exiting the inner recursive edit (such as, with the debugger `c'
command) resumes the command running in the next level up.  When that
command finishes, you can then use `C-M-c' to exit another recursive
editing level, and so on.  Exiting applies to the innermost level only.
Aborting also gets out of only one level of recursive edit; it returns
immediately to the command level of the previous recursive edit.  If you
wish, you can then abort the next recursive editing level.

   Alternatively, the command `M-x top-level' aborts all levels of
recursive edits, returning immediately to the top-level command reader.

   The text being edited inside the recursive edit need not be the same
text that you were editing at top level.  It depends on what the
recursive edit is for.  If the command that invokes the recursive edit
selects a different buffer first, that is the buffer you will edit
recursively.  In any case, you can switch buffers within the recursive
edit in the normal manner (as long as the buffer-switching keys have
not been rebound).  You could probably do all the rest of your editing
inside the recursive edit, visiting files and all.  But this could have
surprising effects (such as stack overflow) from time to time.  So
remember to exit or abort the recursive edit when you no longer need it.

   In general, we try to minimize the use of recursive editing levels in
GNU Emacs.  This is because they constrain you to "go back" in a
particular order--from the innermost level toward the top level.  When
possible, we present different activities in separate buffers so that
you can switch between them as you please.  Some commands switch to a
new major mode which provides a command to switch back.  These
approaches give you more flexibility to go back to unfinished tasks in
the order you choose.


File: emacs,  Node: Emulation,  Next: Hyperlinking,  Prev: Recursive Edit,  Up: Top

Emulation
=========

   GNU Emacs can be programmed to emulate (more or less) most other
editors.  Standard facilities can emulate these:

CRiSP/Brief (PC editor)
     You can turn on key bindings to emulate the CRiSP/Brief editor with
     `M-x crisp-mode'.  Note that this rebinds `M-x' to exit Emacs
     unless you change the user option `crisp-override-meta-x'.  You can
     also use the command `M-x scroll-all-mode' or set the user option
     `crisp-load-scroll-all' to emulate CRiSP's scroll-all feature
     (scrolling all windows together).

EDT (DEC VMS editor)
     Turn on EDT emulation with `M-x edt-emulation-on'.  `M-x
     edt-emulation-off' restores normal Emacs command bindings.

     Most of the EDT emulation commands are keypad keys, and most
     standard Emacs key bindings are still available.  The EDT
     emulation rebindings are done in the global keymap, so there is no
     problem switching buffers or major modes while in EDT emulation.

"PC" bindings
     The command `M-x pc-bindings-mode' sets up certain key bindings
     for "PC compatibility"--what people are often used to on PCs--as
     follows: `Delete' and its variants delete forward instead of
     backward, `C-Backspace' kills backward a word (as `C-Delete'
     normally would), `M-Backspace' does undo, `Home' and `End' move to
     beginning and end of line, `C-Home' and `C-End' move to beginning
     and end of buffer and `C-Escape' does `list-buffers'.

PC Selection mode
     The command `M-x pc-selection-mode' enables a global minor mode
     that emulates the mark, copy, cut and paste commands of various
     other systems--an interface known as CUA.  It establishes the key
     bindings of PC mode, and also modifies the bindings of the cursor
     keys and the `next', `prior', `home' and `end' keys.  It does not
     provide the full set of CUA key bindings--the fundamental Emacs
     keys `C-c', `C-v' and `C-x' are not changed.

     The standard keys for moving around (`right', `left', `up',
     `down', `home', `end', `prior', `next', called "move-keys")
     deactivate the mark in PC selection mode.  However, using `Shift'
     together with the "move keys" activates the region over which they
     move.  The copy, cut and paste functions are available on
     `C-insert', `S-delete' and `S-insert' respectively.

     The `s-region' package provides similar, but less complete,
     facilities.

TPU (DEC VMS editor)
     `M-x tpu-edt-on' turns on emulation of the TPU editor emulating
     EDT.

vi (Berkeley editor)
     Viper is the newest emulator for vi.  It implements several levels
     of emulation; level 1 is closest to vi itself, while level 5
     departs somewhat from strict emulation to take advantage of the
     capabilities of Emacs.  To invoke Viper, type `M-x viper-mode'; it
     will guide you the rest of the way and ask for the emulation
     level.  *note Viper: (viper)Top.

vi (another emulator)
     `M-x vi-mode' enters a major mode that replaces the previously
     established major mode.  All of the vi commands that, in real vi,
     enter "input" mode are programmed instead to return to the
     previous major mode.  Thus, ordinary Emacs serves as vi's "input"
     mode.

     Because vi emulation works through major modes, it does not work
     to switch buffers during emulation.  Return to normal Emacs first.

     If you plan to use vi emulation much, you probably want to bind a
     key to the `vi-mode' command.

vi (alternate emulator)
     `M-x vip-mode' invokes another vi emulator, said to resemble real
     vi more thoroughly than `M-x vi-mode'.  "Input" mode in this
     emulator is changed from ordinary Emacs so you can use <ESC> to go
     back to emulated vi command mode.  To get from emulated vi command
     mode back to ordinary Emacs, type `C-z'.

     This emulation does not work through major modes, and it is
     possible to switch buffers in various ways within the emulator.
     It is not so necessary to assign a key to the command `vip-mode' as
     it is with `vi-mode' because terminating insert mode does not use
     it.

     *note VIP: (vip)Top, for full information.

WordStar (old wordprocessor)
     `M-x wordstar-mode' provides a major mode with WordStar-like key
     bindings.


File: emacs,  Node: Hyperlinking,  Next: Dissociated Press,  Prev: Emulation,  Up: Top

Hyperlinking and Navigation Features
====================================

   Various modes documented elsewhere have hypertext features so that
you can follow links, usually by clicking `Mouse-2' on the link or
typing <RET> while point is on the link.  Info mode, Help mode and the
Dired-like modes are examples.  The Tags facility links between uses
and definitions in source files, see *Note Tags::.  Imenu provides
navigation amongst items indexed in the current buffer, see *Note
Imenu::.  Info-lookup provides mode-specific lookup of definitions in
Info indexes, see *Note Documentation::.  Speedbar maintains a frame in
which links to files, and locations in files are displayed, see *Note
Speedbar::.

   Other non-mode-specific facilities described in this section enable
following links from the current buffer in a context-sensitive fashion.

* Menu:

* Browse-URL::                  Following URLs.
* Goto-address::                Activating URLs.
* FFAP::                        Finding files etc. at point.
* Find-func::                   Finding function and variable definitions.


File: emacs,  Node: Browse-URL,  Next: Goto-address,  Up: Hyperlinking

Following URLs
--------------

`M-x browse-url <RET> URL <RET>'
     Load a URL into a Web browser.

   The Browse-URL package provides facilities for following URLs
specifying links on the World Wide Web.  Usually this works by invoking
a web browser, but you can, for instance, arrange to invoke
`compose-mail' from `mailto:' URLs.

   The general way to use this feature is to type `M-x browse-url',
which displays a specified URL.  If point is located near a plausible
URL, that URL is used as the default.  Other commands are available
which you might like to bind to keys, such as `browse-url-at-point' and
`browse-url-at-mouse'.

   You can customize Browse-URL's behavior via various options in the
`browse-url' Customize group, particularly
`browse-url-browser-function'.  You can invoke actions dependent on the
type of URL by defining `browse-url-browser-function' as an association
list.  The package's commentary available via `C-h p' provides more
information.  Packages with facilities for following URLs should always
go through Browse-URL, so that the customization options for Browse-URL
will affect all browsing in Emacs.


File: emacs,  Node: Goto-address,  Next: FFAP,  Prev: Browse-URL,  Up: Hyperlinking

Activating URLs
---------------

`M-x goto-address'
     Activate URLs and e-mail addresses in the current buffer.

   You can make URLs in the current buffer active with `M-x
goto-address'.  This finds all the URLs in the buffer, and establishes
bindings for `Mouse-2' and `C-c <RET>' on them.  After activation, if
you click on a URL with `Mouse-2', or move to a URL and type `C-c
<RET>', that will display the web page that the URL specifies.  For a
`mailto' URL, it sends mail instead, using your selected
mail-composition method (*note Mail Methods::).

   It can be useful to add `goto-address' to mode hooks and the hooks
used to display an incoming message.  `rmail-show-message-hook' is the
appropriate hook for Rmail, and `mh-show-mode-hook' for MH-E.  This is
not needed for Gnus, which has a similar feature of its own.


File: emacs,  Node: FFAP,  Next: Find-func,  Prev: Goto-address,  Up: Hyperlinking

Finding Files and URLs at Point
-------------------------------

   FFAP mode replaces certain key bindings for finding files, including
`C-x C-f', with commands that provide more sensitive defaults.  These
commands behave like the ordinary ones when given a prefix argument.
Otherwise, they get the default file name or URL from the text around
point.  If what is found in the buffer has the form of a URL rather
than a file name, the commands use `browse-url' to view it.

   This feature is useful for following references in mail or news
buffers, `README' files, `MANIFEST' files, and so on.  The `ffap'
package's commentary available via `C-h p' and the `ffap' Custom group
provide details.

   You can turn on FFAP minor mode to make the following key bindings
and to install hooks for using `ffap' in Rmail, Gnus and VM article
buffers.

`C-x C-f FILENAME <RET>'
     Find FILENAME, guessing a default from text around point
     (`find-file-at-point').

`C-x 4 f'
     `ffap-other-window', analogous to `find-file-other-window'.

`C-x 5 f'
     `ffap-other-frame', analogous to `find-file-other-frame'.

`M-x ffap-next'
     Search buffer for next file name or URL, then find that file or
     URL.

`C-x d DIRECTORY <RET>'
     Start Dired on DIRECTORY, defaulting to the directory name at
     point (`ffap-dired-at-point').

`S-Mouse-3'
     `ffap-at-mouse' finds the file guessed from text around the
     position of a mouse click.

`C-S-Mouse-3'
     Display a menu of files and URLs mentioned in current buffer, then
     find the one you select (`ffap-menu').


File: emacs,  Node: Find-func,  Prev: FFAP,  Up: Hyperlinking

Finding Function and Variable Definitions
-----------------------------------------

`M-x find-function <RET> FUNCTION <RET>'
     Find the definition of FUNCTION in its source file.

`M-x find-variable <RET> VARIABLE <RET>'
     Find the definition of VARIABLE in its source file.

`M-x find-function-on-key <RET> KEY'
     Find the definition of the function that KEY invokes.

   These commands provide an easy way to find the definitions of Emacs
Lisp functions and variables.  They are similar in purpose to the Tags
facility (*note Tags::), but don't require a tags table; on the other
hand, they only work for function and variable definitions that are
already loaded in the Emacs session.

   To find the definition of a function, use `M-x find-function'.  `M-x
find-variable' finds the definition of a specified variable.  `M-x
find-function-on-key' finds the definition of the function bound to a
specified key.

   To use these commands, you must have the Lisp source (`.el') files
available along with the compiled (`.elc') files, in directories in
`load-path'.  You can use compressed source files if you enable Auto
Compression mode.  These commands only handle definitions written in
Lisp, not primitive functions or variables defined in the C code of
Emacs.


File: emacs,  Node: Dissociated Press,  Next: Amusements,  Prev: Hyperlinking,  Up: Top

Dissociated Press
=================

   `M-x dissociated-press' is a command for scrambling a file of text
either word by word or character by character.  Starting from a buffer
of straight English, it produces extremely amusing output.  The input
comes from the current Emacs buffer.  Dissociated Press writes its
output in a buffer named `*Dissociation*', and redisplays that buffer
after every couple of lines (approximately) so you can read the output
as it comes out.

   Dissociated Press asks every so often whether to continue generating
output.  Answer `n' to stop it.  You can also stop at any time by
typing `C-g'.  The dissociation output remains in the `*Dissociation*'
buffer for you to copy elsewhere if you wish.

   Dissociated Press operates by jumping at random from one point in the
buffer to another.  In order to produce plausible output rather than
gibberish, it insists on a certain amount of overlap between the end of
one run of consecutive words or characters and the start of the next.
That is, if it has just output `president' and then decides to jump to
a different point in the file, it might spot the `ent' in `pentagon'
and continue from there, producing `presidentagon'.(1)  Long sample
texts produce the best results.

   A positive argument to `M-x dissociated-press' tells it to operate
character by character, and specifies the number of overlap characters.
A negative argument tells it to operate word by word and specifies the
number of overlap words.  In this mode, whole words are treated as the
elements to be permuted, rather than characters.  No argument is
equivalent to an argument of two.  For your againformation, the output
goes only into the buffer `*Dissociation*'.  The buffer you start with
is not changed.

   Dissociated Press produces nearly the same results as a Markov chain
based on a frequency table constructed from the sample text.  It is,
however, an independent, ignoriginal invention.  Dissociated Press
techniquitously copies several consecutive characters from the sample
between random choices, whereas a Markov chain would choose randomly for
each word or character.  This makes for more plausible sounding results,
and runs faster.

   It is a mustatement that too much use of Dissociated Press can be a
developediment to your real work.  Sometimes to the point of outragedy.
And keep dissociwords out of your documentation, if you want it to be
well userenced and properbose.  Have fun.  Your buggestions are welcome.

   ---------- Footnotes ----------

   (1) This dissociword actually appeared during the Vietnam War, when
it was very appropriate.


File: emacs,  Node: Amusements,  Next: Customization,  Prev: Dissociated Press,  Up: Top

Other Amusements
================

   If you are a little bit bored, you can try `M-x hanoi'.  If you are
considerably bored, give it a numeric argument.  If you are very, very
bored, try an argument of 9.  Sit back and watch.

   If you want a little more personal involvement, try `M-x gomoku',
which plays the game Go Moku with you.

   `M-x blackbox', `M-x mpuz' and `M-x 5x5' are kinds of puzzles.
`blackbox' challenges you to determine the location of objects inside a
box by tomography.  `mpuz' displays a multiplication puzzle with
letters standing for digits in a code that you must guess--to guess a
value, type a letter and then the digit you think it stands for.  The
aim of `5x5' is to fill in all the squares.

   `M-x decipher' helps you to cryptanalyze a buffer which is encrypted
in a simple monoalphabetic substitution cipher.

   `M-x dunnet' runs an adventure-style exploration game, which is a
bigger sort of puzzle.

   `M-x lm' runs a relatively non-participatory game in which a robot
attempts to maneuver towards a tree at the center of the window based on
unique olfactory cues from each of the four directions.

   `M-x life' runs Conway's "Life" cellular automaton.

   `M-x morse-region' converts text in a region to Morse code and `M-x
unmorse-region' converts it back.  No cause for remorse.

   `M-x pong' plays a Pong-like game, bouncing the ball off opposing
bats.

   `M-x solitaire' plays a game of solitaire in which you jump pegs
across other pegs.

   `M-x studlify-region' studlify-cases the region, producing text like
this:

     M-x stUdlIfY-RegioN stUdlIfY-CaSeS thE region.

   `M-x tetris' runs an implementation of the well-known Tetris game.
Likewise, `M-x snake' provides an implementation of Snake.

   When you are frustrated, try the famous Eliza program.  Just do `M-x
doctor'.  End each input by typing <RET> twice.

   When you are feeling strange, type `M-x yow'.

   The command `M-x zone' plays games with the display when Emacs is
idle.


File: emacs,  Node: Customization,  Next: Quitting,  Prev: Amusements,  Up: Top

Customization
*************

   This chapter talks about various topics relevant to adapting the
behavior of Emacs in minor ways.  See `The Emacs Lisp Reference Manual'
for how to make more far-reaching changes.

   Customization that you do within Emacs normally affects only the
particular Emacs session that you do it in-it does not persist between
sessions unless you save the customization in a file such as `.emacs'
or `.Xdefaults' that will affect future sessions.  *Note Init File::.
In the customization buffer, when you save customizations for future
sessions, this actually works by editing `.emacs' for you.

* Menu:

* Minor Modes::		Each minor mode is one feature you can turn on
			  independently of any others.
* Variables::		Many Emacs commands examine Emacs variables
			  to decide what to do; by setting variables,
			  you can control their functioning.
* Keyboard Macros::	A keyboard macro records a sequence of
			  keystrokes to be replayed with a single
			  command.
* Key Bindings::	The keymaps say what command each key runs.
			  By changing them, you can "redefine keys".
* Keyboard Translations::
                        If your keyboard passes an undesired code
			   for a key, you can tell Emacs to
			   substitute another code.
* Syntax::		The syntax table controls how words and
			   expressions are parsed.
* Init File::		How to write common customizations in the
			  `.emacs' file.


File: emacs,  Node: Minor Modes,  Next: Variables,  Up: Customization

Minor Modes
===========

   Minor modes are optional features which you can turn on or off.  For
example, Auto Fill mode is a minor mode in which <SPC> breaks lines
between words as you type.  All the minor modes are independent of each
other and of the selected major mode.  Most minor modes say in the mode
line when they are on; for example, `Fill' in the mode line means that
Auto Fill mode is on.

   Append `-mode' to the name of a minor mode to get the name of a
command function that turns the mode on or off.  Thus, the command to
enable or disable Auto Fill mode is called `M-x auto-fill-mode'.  These
commands are usually invoked with `M-x', but you can bind keys to them
if you wish.  With no argument, the function turns the mode on if it was
off and off if it was on.  This is known as "toggling".  A positive
argument always turns the mode on, and an explicit zero argument or a
negative argument always turns it off.

   Some minor modes are global: while enabled, they affect everything
you do in the Emacs session, in all buffers.  Other minor modes are
buffer-local; they apply only to the current buffer, so you can enable
the mode in certain buffers and not others.

   For most minor modes, the command name is also the name of a
variable which directly controls the mode.  The mode is enabled
whenever this variable's value is non-`nil', and the minor-mode command
works by setting the variable.  For example, the command
`outline-minor-mode' works by setting the value of `outline-minor-mode'
as a variable; it is this variable that directly turns Outline minor
mode on and off.  To check whether a given minor mode works this way,
use `C-h v' to ask for documentation on the variable name.

   These minor-mode variables provide a good way for Lisp programs to
turn minor modes on and off; they are also useful in a file's local
variables list.  But please think twice before setting minor modes with
a local variables list, because most minor modes are matter of user
preference--other users editing the same file might not want the same
minor modes you prefer.

   The buffer-local minor modes include Abbrev mode, Auto Fill mode,
Auto Save mode, Font-Lock mode, Glasses mode, ISO Accents mode, Outline
minor mode, Overwrite mode, and Binary Overwrite mode.

   Abbrev mode allows you to define abbreviations that automatically
expand as you type them.  For example, `amd' might expand to `abbrev
mode'.  *Note Abbrevs::, for full information.

   Auto Fill mode allows you to enter filled text without breaking lines
explicitly.  Emacs inserts newlines as necessary to prevent lines from
becoming too long.  *Note Filling::.

   Auto Save mode causes the contents of a buffer to be saved
periodically to reduce the amount of work you can lose in case of a
system crash.  *Note Auto Save::.

   Enriched mode enables editing and saving of formatted text.  *Note
Formatted Text::.

   Flyspell mode automatically highlights misspelled words.  *Note
Spelling::.

   Font-Lock mode automatically highlights certain textual units found
in programs, such as comments, strings, and function names being
defined.  This requires a window system that can display multiple fonts.
*Note Faces::.

   ISO Accents mode makes the characters ``', `'', `"', `^', `/' and
`~' combine with the following letter, to produce an accented letter in
the ISO Latin-1 character set.  The newer and more general feature of
input methods more or less supersedes ISO Accents mode.  *Note
Single-Byte Character Support::.

   Outline minor mode provides the same facilities as the major mode
called Outline mode; but since it is a minor mode instead, you can
combine it with any major mode.  *Note Outline Mode::.

   Overwrite mode causes ordinary printing characters to replace
existing text instead of shoving it to the right.  For example, if
point is in front of the `B' in `FOOBAR', then in Overwrite mode typing
a `G' changes it to `FOOGAR', instead of producing `FOOGBAR' as usual.
In Overwrite mode, the command `C-q' inserts the next character
whatever it may be, even if it is a digit--this gives you a way to
insert a character instead of replacing an existing character.

   The command `overwrite-mode' is an exception to the rule that
commands which toggle minor modes are normally not bound to keys: it is
bound to the <INSERT> function key.  This is because many other
programs bind <INSERT> to similar functions.

   Binary Overwrite mode is a variant of Overwrite mode for editing
binary files; it treats newlines and tabs like other characters, so that
they overwrite other characters and can be overwritten by them.  In
Binary Overwrite mode, digits after `C-q' specify an octal character
code, as usual.

   The following minor modes normally apply to all buffers at once.
Since each is enabled or disabled by the value of a variable, you _can_
set them differently for particular buffers, by explicitly making the
corresponding variables local in those buffers.  *Note Locals::.

   Icomplete mode displays an indication of available completions when
you are in the minibuffer and completion is active.  *Note Completion
Options::.

   Line Number mode enables continuous display in the mode line of the
line number of point, and Column Number mode enables display of the
column number.  *Note Mode Line::.

   Scroll Bar mode gives each window a scroll bar (*note Scroll Bars::).
Menu Bar mode gives each frame a menu bar (*note Menu Bars::).  Both of
these modes are enabled by default when you use the X Window System.

   In Transient Mark mode, every change in the buffer contents
"deactivates" the mark, so that commands that operate on the region
will get an error.  This means you must either set the mark, or
explicitly "reactivate" it, before each command that uses the region.
The advantage of Transient Mark mode is that Emacs can display the
region highlighted (currently only when using X).  *Note Mark::.


File: emacs,  Node: Variables,  Next: Keyboard Macros,  Prev: Minor Modes,  Up: Customization

Variables
=========

   A "variable" is a Lisp symbol which has a value.  The symbol's name
is also called the name of the variable.  A variable name can contain
any characters that can appear in a file, but conventionally variable
names consist of words separated by hyphens.  A variable can have a
documentation string which describes what kind of value it should have
and how the value will be used.

   Lisp allows any variable to have any kind of value, but most
variables that Emacs uses require a value of a certain type.  Often the
value should always be a string, or should always be a number.
Sometimes we say that a certain feature is turned on if a variable is
"non-`nil'," meaning that if the variable's value is `nil', the feature
is off, but the feature is on for _any_ other value.  The conventional
value to use to turn on the feature--since you have to pick one
particular value when you set the variable--is `t'.

   Emacs uses many Lisp variables for internal record keeping, as any
Lisp program must, but the most interesting variables for you are the
ones that exist for the sake of customization.  Emacs does not (usually)
change the values of these variables; instead, you set the values, and
thereby alter and control the behavior of certain Emacs commands.  These
variables are called "user options".  Most user options are documented
in this manual, and appear in the Variable Index (*note Variable
Index::).

   One example of a variable which is a user option is `fill-column',
which specifies the position of the right margin (as a number of
characters from the left margin) to be used by the fill commands (*note
Filling::).

* Menu:

* Examining::	        Examining or setting one variable's value.
* Easy Customization::
                        Convenient and easy customization of variables.
* Hooks::	        Hook variables let you specify programs for parts
		          of Emacs to run on particular occasions.
* Locals::	        Per-buffer values of variables.
* File Variables::      How files can specify variable values.


File: emacs,  Node: Examining,  Next: Easy Customization,  Up: Variables

Examining and Setting Variables
-------------------------------

`C-h v VAR <RET>'
     Display the value and documentation of variable VAR
     (`describe-variable').

`M-x set-variable <RET> VAR <RET> VALUE <RET>'
     Change the value of variable VAR to VALUE.

   To examine the value of a single variable, use `C-h v'
(`describe-variable'), which reads a variable name using the
minibuffer, with completion.  It displays both the value and the
documentation of the variable.  For example,

     C-h v fill-column <RET>

displays something like this:

     fill-column's value is 70
     
     Documentation:
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes buffer-local when set in any fashion.

The star at the beginning of the documentation indicates that this
variable is a user option.  `C-h v' is not restricted to user options;
it allows any variable name.

   The most convenient way to set a specific user option is with `M-x
set-variable'.  This reads the variable name with the minibuffer (with
completion), and then reads a Lisp expression for the new value using
the minibuffer a second time.  For example,

     M-x set-variable <RET> fill-column <RET> 75 <RET>

sets `fill-column' to 75.

   `M-x set-variable' is limited to user option variables, but you can
set any variable with a Lisp expression, using the function `setq'.
Here is a `setq' expression to set `fill-column':

     (setq fill-column 75)

   To execute an expression like this one, go to the `*scratch*'
buffer, type in the expression, and then type `C-j'.  *Note Lisp
Interaction::.

   Setting variables, like all means of customizing Emacs except where
otherwise stated, affects only the current Emacs session.


File: emacs,  Node: Easy Customization,  Next: Hooks,  Prev: Examining,  Up: Variables

Easy Customization Interface
----------------------------

   A convenient way to find the user option variables that you want to
change, and then change them, is with `M-x customize'.  This command
creates a "customization buffer" with which you can browse through the
Emacs user options in a logically organized structure, then edit and
set their values.  You can also use the customization buffer to save
settings permanently.  (Not all Emacs user options are included in this
structure as of yet, but we are adding the rest.)

   The appearance of the example buffers in the following is typically
different under a window system where faces can be used to indicate the
active fields and other features.

* Menu:

* Groups: Customization Groups.
                             How options are classified in a structure.
* Changing an Option::       How to edit a value and set an option.
* Face Customization::       How to edit the attributes of a face.
* Specific Customization::   Making a customization buffer for specific
                                options, faces, or groups.


File: emacs,  Node: Customization Groups,  Next: Changing an Option,  Up: Easy Customization

Customization Groups
....................

   For customization purposes, user options are organized into "groups"
to help you find them.  Groups are collected into bigger groups, all
the way up to a master group called `Emacs'.

   `M-x customize' creates a customization buffer that shows the
top-level `Emacs' group and the second-level groups immediately under
it.  It looks like this, in part:

     /- Emacs group: ---------------------------------------------------\
           [State]: visible group members are all at standard settings.
        Customization of the One True Editor.
        See also [Manual].
     
     Confirm Kill Emacs: [Hide] [Value Menu] Don't confirm
        [State]: this option is unchanged from its standard setting.
     How to ask for confirmation when leaving Emacs. [More]
     
     Editing group: [Go to Group]
     Basic text editing facilities.
     
     External group: [Go to Group]
     Interfacing to external utilities.
     
     MORE SECOND-LEVEL GROUPS
     
     \- Emacs group end ------------------------------------------------/

This says that the buffer displays the contents of the `Emacs' group.
The other groups are listed because they are its contents.  But they
are listed differently, without indentation and dashes, because _their_
contents are not included.  Each group has a single-line documentation
string; the `Emacs' group also has a `[State]' line.

   Most of the text in the customization buffer is read-only, but it
typically includes some "editable fields" that you can edit.  There are
also "active fields"; this means a field that does something when you
"invoke" it.  To invoke an active field, either click on it with
`Mouse-1', or move point to it and type <RET>.

   For example, the phrase `[Go to Group]' that appears in a
second-level group is an active field.  Invoking the `[Go to Group]'
field for a group creates a new customization buffer, which shows that
group and its contents.  This field is a kind of hypertext link to
another group.

   The `Emacs' group includes a few user options itself, but mainly it
contains other groups, which contain more groups, which contain the
user options.  By browsing the hierarchy of groups, you will eventually
find the feature you are interested in customizing.  Then you can use
the customization buffer to set the options and faces pertaining to
that feature.  You can also go straight to a particular group by name,
using the command `M-x customize-group'.

   You can view the structure of customization groups on a larger scale
with `M-x customize-browse'.  This command creates a special kind of
customization buffer which shows only the names of the groups (and
options and faces), and their structure.

   In this buffer, you can show the contents of a group by invoking
`[+]'.  When the group contents are visible, this button changes to
`[-]'; invoking that hides the group contents.

   Each group, option or face name in this buffer has an active field
which says `[Group]', `[Option]' or `[Face]'.  Invoking that active
field creates an ordinary customization buffer showing just that group
and its contents, just that option, or just that face.  This is the way
to set values in it.

