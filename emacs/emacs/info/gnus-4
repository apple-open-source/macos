This is ../info/gnus, produced by makeinfo version 4.0 from gnus.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus: (gnus).         The newsreader Gnus.
END-INFO-DIR-ENTRY

   This file documents Gnus, the GNU Emacs newsreader.

   Copyright (C) 1995,96,97,98,99,2000,2001 Free Software Foundation,
Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being none, with the Front-Cover texts being "A GNU
Manual", and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License" in the Emacs manual.

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."

   This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.


File: gnus,  Node: Setting Process Marks,  Prev: Generic Marking Commands,  Up: Marking Articles

Setting Process Marks
---------------------

`M P p'
`#'
     Mark the current article with the process mark
     (`gnus-summary-mark-as-processable').

`M P u'
`M-#'
     Remove the process mark, if any, from the current article
     (`gnus-summary-unmark-as-processable').

`M P U'
     Remove the process mark from all articles
     (`gnus-summary-unmark-all-processable').

`M P i'
     Invert the list of process marked articles
     (`gnus-uu-invert-processable').

`M P R'
     Mark articles that have a `Subject' header that matches a regular
     expression (`gnus-uu-mark-by-regexp').

`M P G'
     Unmark articles that have a `Subject' header that matches a regular
     expression (`gnus-uu-unmark-by-regexp').

`M P r'
     Mark articles in region (`gnus-uu-mark-region').

`M P t'
     Mark all articles in the current (sub)thread
     (`gnus-uu-mark-thread').

`M P T'
     Unmark all articles in the current (sub)thread
     (`gnus-uu-unmark-thread').

`M P v'
     Mark all articles that have a score above the prefix argument
     (`gnus-uu-mark-over').

`M P s'
     Mark all articles in the current series (`gnus-uu-mark-series').

`M P S'
     Mark all series that have already had some articles marked
     (`gnus-uu-mark-sparse').

`M P a'
     Mark all articles in series order (`gnus-uu-mark-series').

`M P b'
     Mark all articles in the buffer in the order they appear
     (`gnus-uu-mark-buffer').

`M P k'
     Push the current process mark set onto the stack and unmark all
     articles (`gnus-summary-kill-process-mark').

`M P y'
     Pop the previous process mark set from the stack and restore it
     (`gnus-summary-yank-process-mark').

`M P w'
     Push the current process mark set onto the stack
     (`gnus-summary-save-process-mark').

   Also see the `&' command in *note Searching for Articles:: for how to
set process marks based on article body contents.


File: gnus,  Node: Limiting,  Next: Threading,  Prev: Marking Articles,  Up: The Summary Buffer

Limiting
========

   It can be convenient to limit the summary buffer to just show some
subset of the articles currently in the group.  The effect most limit
commands have is to remove a few (or many) articles from the summary
buffer.

   All limiting commands work on subsets of the articles already fetched
from the servers.  None of these commands query the server for
additional articles.

`/ /'
`/ s'
     Limit the summary buffer to articles that match some subject
     (`gnus-summary-limit-to-subject').

`/ a'
     Limit the summary buffer to articles that match some author
     (`gnus-summary-limit-to-author').

`/ x'
     Limit the summary buffer to articles that match one of the "extra"
     headers (*note To From Newsgroups::)
     (`gnus-summary-limit-to-extra').

`/ u'
`x'
     Limit the summary buffer to articles not marked as read
     (`gnus-summary-limit-to-unread').  If given a prefix, limit the
     buffer to articles strictly unread.  This means that ticked and
     dormant articles will also be excluded.

`/ m'
     Ask for a mark and then limit to all articles that have been marked
     with that mark (`gnus-summary-limit-to-marks').

`/ t'
     Ask for a number and then limit the summary buffer to articles
     older than (or equal to) that number of days
     (`gnus-summary-limit-to-age').  If given a prefix, limit to
     articles younger than that number of days.

`/ n'
     Limit the summary buffer to the current article
     (`gnus-summary-limit-to-articles').  Uses the process/prefix
     convention (*note Process/Prefix::).

`/ w'
     Pop the previous limit off the stack and restore it
     (`gnus-summary-pop-limit').  If given a prefix, pop all limits off
     the stack.

`/ v'
     Limit the summary buffer to articles that have a score at or above
     some score (`gnus-summary-limit-to-score').

`/ E'
`M S'
     Include all expunged articles in the limit
     (`gnus-summary-limit-include-expunged').

`/ D'
     Include all dormant articles in the limit
     (`gnus-summary-limit-include-dormant').

`/ *'
     Include all cached articles in the limit
     (`gnus-summary-limit-include-cached').

`/ d'
     Exclude all dormant articles from the limit
     (`gnus-summary-limit-exclude-dormant').

`/ M'
     Exclude all marked articles (`gnus-summary-limit-exclude-marks').

`/ T'
     Include all the articles in the current thread in the limit.

`/ c'
     Exclude all dormant articles that have no children from the limit
     (`gnus-summary-limit-exclude-childless-dormant').

`/ C'
     Mark all excluded unread articles as read
     (`gnus-summary-limit-mark-excluded-as-read').   If given a prefix,
     also mark excluded ticked and dormant articles as read.


File: gnus,  Node: Threading,  Next: Sorting,  Prev: Limiting,  Up: The Summary Buffer

Threading
=========

   Gnus threads articles by default.  "To thread" is to put responses
to articles directly after the articles they respond to--in a
hierarchical fashion.

   Threading is done by looking at the `References' headers of the
articles.  In a perfect world, this would be enough to build pretty
trees, but unfortunately, the `References' header is often broken or
simply missing.  Weird news propagation exacerbates the problem, so one
has to employ other heuristics to get pleasing results.  A plethora of
approaches exists, as detailed in horrible detail in *note Customizing
Threading::.

   First, a quick overview of the concepts:

"root"
     The top-most article in a thread; the first article in the thread.

"thread"
     A tree-like article structure.

"sub-thread"
     A small(er) section of this tree-like structure.

"loose threads"
     Threads often lose their roots due to article expiry, or due to
     the root already having been read in a previous session, and not
     displayed in the summary buffer.  We then typically have many
     sub-threads that really belong to one thread, but are without
     connecting roots.  These are called loose threads.

"thread gathering"
     An attempt to gather loose threads into bigger threads.

"sparse threads"
     A thread where the missing articles have been "guessed" at, and are
     displayed as empty lines in the summary buffer.

* Menu:

* Customizing Threading::     Variables you can change to affect the threading.
* Thread Commands::           Thread based commands in the summary buffer.


File: gnus,  Node: Customizing Threading,  Next: Thread Commands,  Up: Threading

Customizing Threading
---------------------

* Menu:

* Loose Threads::        How Gnus gathers loose threads into bigger threads.
* Filling In Threads::   Making the threads displayed look fuller.
* More Threading::       Even more variables for fiddling with threads.
* Low-Level Threading::  You thought it was over... but you were wrong!


File: gnus,  Node: Loose Threads,  Next: Filling In Threads,  Up: Customizing Threading

Loose Threads
.............

`gnus-summary-make-false-root'
     If non-`nil', Gnus will gather all loose subtrees into one big tree
     and create a dummy root at the top.  (Wait a minute.  Root at the
     top?  Yup.)  Loose subtrees occur when the real root has expired,
     or you've read or killed the root in a previous session.

     When there is no real root of a thread, Gnus will have to fudge
     something.  This variable says what fudging method Gnus should use.
     There are four possible values:

    `adopt'
          Gnus will make the first of the orphaned articles the parent.
          This parent will adopt all the other articles.  The adopted
          articles will be marked as such by pointy brackets (`<>')
          instead of the standard square brackets (`[]').  This is the
          default method.

    `dummy'
          Gnus will create a dummy summary line that will pretend to be
          the parent.  This dummy line does not correspond to any real
          article, so selecting it will just select the first real
          article after the dummy article.
          `gnus-summary-dummy-line-format' is used to specify the
          format of the dummy roots.  It accepts only one format spec:
          `S', which is the subject of the article.  *Note Formatting
          Variables::.

    `empty'
          Gnus won't actually make any article the parent, but simply
          leave the subject field of all orphans except the first
          empty.  (Actually, it will use `gnus-summary-same-subject' as
          the subject (*note Summary Buffer Format::).)

    `none'
          Don't make any article parent at all.  Just gather the
          threads and display them after one another.

    `nil'
          Don't gather loose threads.

`gnus-summary-gather-subject-limit'
     Loose threads are gathered by comparing subjects of articles.  If
     this variable is `nil', Gnus requires an exact match between the
     subjects of the loose threads before gathering them into one big
     super-thread.  This might be too strict a requirement, what with
     the presence of stupid newsreaders that chop off long subject
     lines.  If you think so, set this variable to, say, 20 to require
     that only the first 20 characters of the subjects have to match.
     If you set this variable to a really low number, you'll find that
     Gnus will gather everything in sight into one thread, which isn't
     very helpful.

     If you set this variable to the special value `fuzzy', Gnus will
     use a fuzzy string comparison algorithm on the subjects (*note
     Fuzzy Matching::).

`gnus-simplify-subject-fuzzy-regexp'
     This can either be a regular expression or list of regular
     expressions that match strings that will be removed from subjects
     if fuzzy subject simplification is used.

`gnus-simplify-ignored-prefixes'
     If you set `gnus-summary-gather-subject-limit' to something as low
     as 10, you might consider setting this variable to something
     sensible:

          (setq gnus-simplify-ignored-prefixes
                (concat
                 "\\`\\[?\\("
                 (mapconcat
                  'identity
                  '("looking"
                    "wanted" "followup" "summary\\( of\\)?"
                    "help" "query" "problem" "question"
                    "answer" "reference" "announce"
                    "How can I" "How to" "Comparison of"
                    ;; ...
                    )
                  "\\|")
                 "\\)\\s *\\("
                 (mapconcat 'identity
                            '("for" "for reference" "with" "about")
                            "\\|")
                 "\\)?\\]?:?[ \t]*"))

     All words that match this regexp will be removed before comparing
     two subjects.

`gnus-simplify-subject-functions'
     If non-`nil', this variable overrides
     `gnus-summary-gather-subject-limit'.  This variable should be a
     list of functions to apply to the `Subject' string iteratively to
     arrive at the simplified version of the string.

     Useful functions to put in this list include:

    `gnus-simplify-subject-re'
          Strip the leading `Re:'.

    `gnus-simplify-subject-fuzzy'
          Simplify fuzzily.

    `gnus-simplify-whitespace'
          Remove excessive whitespace.

     You may also write your own functions, of course.

`gnus-summary-gather-exclude-subject'
     Since loose thread gathering is done on subjects only, that might
     lead to many false hits, especially with certain common subjects
     like `' and `(none)'.  To make the situation slightly better, you
     can use the regexp `gnus-summary-gather-exclude-subject' to say
     what subjects should be excluded from the gathering process.
     The default is `^ *$\\|^(none)$'.

`gnus-summary-thread-gathering-function'
     Gnus gathers threads by looking at `Subject' headers.  This means
     that totally unrelated articles may end up in the same "thread",
     which is confusing.  An alternate approach is to look at all the
     `Message-ID's in all the `References' headers to find matches.
     This will ensure that no gathered threads ever include unrelated
     articles, but it also means that people who have posted with broken
     newsreaders won't be gathered properly.  The choice is
     yours--plague or cholera:

    `gnus-gather-threads-by-subject'
          This function is the default gathering function and looks at
          `Subject's exclusively.

    `gnus-gather-threads-by-references'
          This function looks at `References' headers exclusively.

     If you want to test gathering by `References', you could say
     something like:

          (setq gnus-summary-thread-gathering-function
                'gnus-gather-threads-by-references)


File: gnus,  Node: Filling In Threads,  Next: More Threading,  Prev: Loose Threads,  Up: Customizing Threading

Filling In Threads
..................

`gnus-fetch-old-headers'
     If non-`nil', Gnus will attempt to build old threads by fetching
     more old headers--headers to articles marked as read.  If you
     would like to display as few summary lines as possible, but still
     connect as many loose threads as possible, you should set this
     variable to `some' or a number.  If you set it to a number, no
     more than that number of extra old headers will be fetched.  In
     either case, fetching old headers only works if the back end you
     are using carries overview files--this would normally be `nntp',
     `nnspool' and `nnml'.  Also remember that if the root of the
     thread has been expired by the server, there's not much Gnus can
     do about that.

     This variable can also be set to `invisible'.  This won't have any
     visible effects, but is useful if you use the `A T' command a lot
     (*note Finding the Parent::).

`gnus-build-sparse-threads'
     Fetching old headers can be slow.  A low-rent similar effect can be
     gotten by setting this variable to `some'.  Gnus will then look at
     the complete `References' headers of all articles and try to string
     together articles that belong in the same thread.  This will leave
     "gaps" in the threading display where Gnus guesses that an article
     is missing from the thread.  (These gaps appear like normal summary
     lines.  If you select a gap, Gnus will try to fetch the article in
     question.)  If this variable is `t', Gnus will display all these
     "gaps" without regard for whether they are useful for completing
     the thread or not.  Finally, if this variable is `more', Gnus
     won't cut off sparse leaf nodes that don't lead anywhere.  This
     variable is `nil' by default.


File: gnus,  Node: More Threading,  Next: Low-Level Threading,  Prev: Filling In Threads,  Up: Customizing Threading

More Threading
..............

`gnus-show-threads'
     If this variable is `nil', no threading will be done, and all of
     the rest of the variables here will have no effect.  Turning
     threading off will speed group selection up a bit, but it is sure
     to make reading slower and more awkward.

`gnus-thread-hide-subtree'
     If non-`nil', all threads will be hidden when the summary buffer is
     generated.

`gnus-thread-expunge-below'
     All threads that have a total score (as defined by
     `gnus-thread-score-function') less than this number will be
     expunged.  This variable is `nil' by default, which means that no
     threads are expunged.

`gnus-thread-hide-killed'
     if you kill a thread and this variable is non-`nil', the subtree
     will be hidden.

`gnus-thread-ignore-subject'
     Sometimes somebody changes the subject in the middle of a thread.
     If this variable is non-`nil', the subject change is ignored.  If
     it is `nil', which is the default, a change in the subject will
     result in a new thread.

`gnus-thread-indent-level'
     This is a number that says how much each sub-thread should be
     indented.  The default is 4.

`gnus-sort-gathered-threads-function'
     Sometimes, particularly with mailing lists, the order in which
     mails arrive locally is not necessarily the same as the order in
     which they arrived on the mailing list.  Consequently, when
     sorting sub-threads using the default
     `gnus-thread-sort-by-number', responses can end up appearing
     before the article to which they are responding to.  Setting this
     variable to an alternate value (e.g. `gnus-thread-sort-by-date'),
     in a group's parameters or in an appropriate hook (e.g.
     `gnus-summary-generate-hook') can produce a more logical
     sub-thread ordering in such instances.


File: gnus,  Node: Low-Level Threading,  Prev: More Threading,  Up: Customizing Threading

Low-Level Threading
...................

`gnus-parse-headers-hook'
     Hook run before parsing any headers.

`gnus-alter-header-function'
     If non-`nil', this function will be called to allow alteration of
     article header structures.  The function is called with one
     parameter, the article header vector, which it may alter in any
     way.  For instance, if you have a mail-to-news gateway which
     alters the `Message-ID's in systematic ways (by adding prefixes
     and such), you can use this variable to un-scramble the
     `Message-ID's so that they are more meaningful.  Here's one
     example:

          (setq gnus-alter-header-function 'my-alter-message-id)
          
          (defun my-alter-message-id (header)
            (let ((id (mail-header-id header)))
              (when (string-match
                     "\\(<[^<>@]*\\)\\.?cygnus\\..*@\\([^<>@]*>\\)" id)
                (mail-header-set-id
                 (concat (match-string 1 id) "@" (match-string 2 id))
                 header))))


File: gnus,  Node: Thread Commands,  Prev: Customizing Threading,  Up: Threading

Thread Commands
---------------

`T k'
`M-C-k'
     Mark all articles in the current (sub-)thread as read
     (`gnus-summary-kill-thread').  If the prefix argument is positive,
     remove all marks instead.  If the prefix argument is negative, tick
     articles instead.

`T l'
`M-C-l'
     Lower the score of the current (sub-)thread
     (`gnus-summary-lower-thread').

`T i'
     Increase the score of the current (sub-)thread
     (`gnus-summary-raise-thread').

`T #'
     Set the process mark on the current (sub-)thread
     (`gnus-uu-mark-thread').

`T M-#'
     Remove the process mark from the current (sub-)thread
     (`gnus-uu-unmark-thread').

`T T'
     Toggle threading (`gnus-summary-toggle-threads').

`T s'
     Expose the (sub-)thread hidden under the current article, if any
     (`gnus-summary-show-thread').

`T h'
     Hide the current (sub-)thread (`gnus-summary-hide-thread').

`T S'
     Expose all hidden threads (`gnus-summary-show-all-threads').

`T H'
     Hide all threads (`gnus-summary-hide-all-threads').

`T t'
     Re-thread the current article's thread
     (`gnus-summary-rethread-current').  This works even when the
     summary buffer is otherwise unthreaded.

`T ^'
     Make the current article the child of the marked (or previous)
     article (`gnus-summary-reparent-thread').

   The following commands are thread movement commands.  They all
understand the numeric prefix.

`T n'
`M-C-n'
`M-down'
     Go to the next thread (`gnus-summary-next-thread').

`T p'
`M-C-p'
`M-up'
     Go to the previous thread (`gnus-summary-prev-thread').

`T d'
     Descend the thread (`gnus-summary-down-thread').

`T u'
     Ascend the thread (`gnus-summary-up-thread').

`T o'
     Go to the top of the thread (`gnus-summary-top-thread').

   If you ignore subject while threading, you'll naturally end up with
threads that have several different subjects in them.  If you then issue
a command like `T k' (`gnus-summary-kill-thread') you might not wish to
kill the entire thread, but just those parts of the thread that have
the same subject as the current article.  If you like this idea, you
can fiddle with `gnus-thread-operation-ignore-subject'.  If it is
non-`nil' (which it is by default), subjects will be ignored when doing
thread commands.  If this variable is `nil', articles in the same
thread with different subjects will not be included in the operation in
question.  If this variable is `fuzzy', only articles that have
subjects fuzzily equal will be included (*note Fuzzy Matching::).


File: gnus,  Node: Sorting,  Next: Asynchronous Fetching,  Prev: Threading,  Up: The Summary Buffer

Sorting
=======

   If you are using a threaded summary display, you can sort the
threads by setting `gnus-thread-sort-functions', which can be either a
single function, a list of functions, or a list containing functions and
`(not some-function)' elements.

   By default, sorting is done on article numbers.  Ready-made sorting
predicate functions include `gnus-thread-sort-by-number',
`gnus-thread-sort-by-author', `gnus-thread-sort-by-subject',
`gnus-thread-sort-by-date', `gnus-thread-sort-by-score', and
`gnus-thread-sort-by-total-score'.

   Each function takes two threads and returns non-`nil' if the first
thread should be sorted before the other.  Note that sorting really is
normally done by looking only at the roots of each thread.

   If you use more than one function, the primary sort key should be the
last function in the list.  You should probably always include
`gnus-thread-sort-by-number' in the list of sorting
functions--preferably first.  This will ensure that threads that are
equal with respect to the other sort criteria will be displayed in
ascending article order.

   If you would like to sort by reverse score, then by subject, and
finally by number, you could do something like:

     (setq gnus-thread-sort-functions
           '(gnus-thread-sort-by-number
             gnus-thread-sort-by-subject
             (not gnus-thread-sort-by-total-score)))

   The threads that have highest score will be displayed first in the
summary buffer.  When threads have the same score, they will be sorted
alphabetically.  The threads that have the same score and the same
subject will be sorted by number, which is (normally) the sequence in
which the articles arrived.

   If you want to sort by score and then reverse arrival order, you
could say something like:

     (setq gnus-thread-sort-functions
           '((lambda (t1 t2)
               (not (gnus-thread-sort-by-number t1 t2)))
             gnus-thread-sort-by-score))

   The function in the `gnus-thread-score-function' variable (default
`+') is used for calculating the total score of a thread.  Useful
functions might be `max', `min', or squared means, or whatever tickles
your fancy.

   If you are using an unthreaded display for some strange reason or
other, you have to fiddle with the `gnus-article-sort-functions'
variable.  It is very similar to the `gnus-thread-sort-functions',
except that it uses slightly different functions for article
comparison.  Available sorting predicate functions are
`gnus-article-sort-by-number', `gnus-article-sort-by-author',
`gnus-article-sort-by-subject', `gnus-article-sort-by-date', and
`gnus-article-sort-by-score'.

   If you want to sort an unthreaded summary display by subject, you
could say something like:

     (setq gnus-article-sort-functions
           '(gnus-article-sort-by-number
             gnus-article-sort-by-subject))


File: gnus,  Node: Asynchronous Fetching,  Next: Article Caching,  Prev: Sorting,  Up: The Summary Buffer

Asynchronous Article Fetching
=============================

   If you read your news from an NNTP server that's far away, the
network latencies may make reading articles a chore.  You have to wait
for a while after pressing `n' to go to the next article before the
article appears.  Why can't Gnus just go ahead and fetch the article
while you are reading the previous one?  Why not, indeed.

   First, some caveats.  There are some pitfalls to using asynchronous
article fetching, especially the way Gnus does it.

   Let's say you are reading article 1, which is short, and article 2 is
quite long, and you are not interested in reading that.  Gnus does not
know this, so it goes ahead and fetches article 2.  You decide to read
article 3, but since Gnus is in the process of fetching article 2, the
connection is blocked.

   To avoid these situations, Gnus will open two (count 'em two)
connections to the server.  Some people may think this isn't a very nice
thing to do, but I don't see any real alternatives.  Setting up that
extra connection takes some time, so Gnus startup will be slower.

   Gnus will fetch more articles than you will read.  This will mean
that the link between your machine and the NNTP server will become more
loaded than if you didn't use article pre-fetch.  The server itself will
also become more loaded--both with the extra article requests, and the
extra connection.

   Ok, so now you know that you shouldn't really use this thing...
unless you really want to.

   Here's how:  Set `gnus-asynchronous' to `t'.  The rest should happen
automatically.

   You can control how many articles are to be pre-fetched by setting
`gnus-use-article-prefetch'.  This is 30 by default, which means that
when you read an article in the group, the back end will pre-fetch the
next 30 articles.  If this variable is `t', the back end will pre-fetch
all the articles it can without bound.  If it is `nil', no pre-fetching
will be done.

   There are probably some articles that you don't want to
pre-fetch--read articles, for instance.  The
`gnus-async-prefetch-article-p' variable controls whether an article is
to be pre-fetched.  This function should return non-`nil' when the
article in question is to be pre-fetched.  The default is
`gnus-async-read-p', which returns `nil' on read articles.  The
function is called with an article data structure as the only parameter.

   If, for instance, you wish to pre-fetch only unread articles shorter
than 100 lines, you could say something like:

     (defun my-async-short-unread-p (data)
       "Return non-nil for short, unread articles."
       (and (gnus-data-unread-p data)
            (< (mail-header-lines (gnus-data-header data))
               100)))
     
     (setq gnus-async-prefetch-article-p 'my-async-short-unread-p)

   These functions will be called many, many times, so they should
preferably be short and sweet to avoid slowing down Gnus too much.
It's probably a good idea to byte-compile things like this.

   Articles have to be removed from the asynch buffer sooner or later.
The `gnus-prefetched-article-deletion-strategy' says when to remove
articles.  This is a list that may contain the following elements:

`read'
     Remove articles when they are read.

`exit'
     Remove articles when exiting the group.

   The default value is `(read exit)'.


File: gnus,  Node: Article Caching,  Next: Persistent Articles,  Prev: Asynchronous Fetching,  Up: The Summary Buffer

Article Caching
===============

   If you have an _extremely_ slow NNTP connection, you may consider
turning article caching on.  Each article will then be stored locally
under your home directory.  As you may surmise, this could potentially
use _huge_ amounts of disk space, as well as eat up all your inodes so
fast it will make your head swim.  In vodka.

   Used carefully, though, it could be just an easier way to save
articles.

   To turn caching on, set `gnus-use-cache' to `t'.  By default, all
articles ticked or marked as dormant will then be copied over to your
local cache (`gnus-cache-directory').  Whether this cache is flat or
hierarchical is controlled by the `gnus-use-long-file-name' variable,
as usual.

   When re-selecting a ticked or dormant article, it will be fetched
from the cache instead of from the server.  As articles in your cache
will never expire, this might serve as a method of saving articles
while still keeping them where they belong.  Just mark all articles you
want to save as dormant, and don't worry.

   When an article is marked as read, is it removed from the cache.

   The entering/removal of articles from the cache is controlled by the
`gnus-cache-enter-articles' and `gnus-cache-remove-articles' variables.
Both are lists of symbols.  The first is `(ticked dormant)' by
default, meaning that ticked and dormant articles will be put in the
cache.  The latter is `(read)' by default, meaning that articles marked
as read are removed from the cache.  Possibly symbols in these two
lists are `ticked', `dormant', `unread' and `read'.

   So where does the massive article-fetching and storing come into the
picture?  The `gnus-jog-cache' command will go through all subscribed
newsgroups, request all unread articles, score them, and store them in
the cache.  You should only ever, ever ever ever, use this command if
1) your connection to the NNTP server is really, really, really slow
and 2) you have a really, really, really huge disk.  Seriously.  One
way to cut down on the number of articles downloaded is to score
unwanted articles down and have them marked as read.  They will not
then be downloaded by this command.

   It is likely that you do not want caching on all groups.  For
instance, if your `nnml' mail is located under your home directory, it
makes no sense to cache it somewhere else under your home directory.
Unless you feel that it's neat to use twice as much space.

   To limit the caching, you could set `gnus-cacheable-groups' to a
regexp of groups to cache, `^nntp' for instance, or set the
`gnus-uncacheable-groups' regexp to `^nnml', for instance.  Both
variables are `nil' by default.  If a group matches both variables, the
group is not cached.

   The cache stores information on what articles it contains in its
active file (`gnus-cache-active-file').  If this file (or any other
parts of the cache) becomes all messed up for some reason or other, Gnus
offers two functions that will try to set things right.  `M-x
gnus-cache-generate-nov-databases' will (re)build all the NOV files,
and `gnus-cache-generate-active' will (re)generate the active file.


File: gnus,  Node: Persistent Articles,  Next: Article Backlog,  Prev: Article Caching,  Up: The Summary Buffer

Persistent Articles
===================

   Closely related to article caching, we have "persistent articles".
In fact, it's just a different way of looking at caching, and much more
useful in my opinion.

   Say you're reading a newsgroup, and you happen on to some valuable
gem that you want to keep and treasure forever.  You'd normally just
save it (using one of the many saving commands) in some file.  The
problem with that is that it's just, well, yucky.  Ideally you'd prefer
just having the article remain in the group where you found it forever;
untouched by the expiry going on at the news server.

   This is what a "persistent article" is--an article that just won't
be deleted.  It's implemented using the normal cache functions, but you
use two explicit commands for managing persistent articles:

`*'
     Make the current article persistent (`gnus-cache-enter-article').

`M-*'
     Remove the current article from the persistent articles
     (`gnus-cache-remove-article').  This will normally delete the
     article.

   Both these commands understand the process/prefix convention.

   To avoid having all ticked articles (and stuff) entered into the
cache, you should set `gnus-use-cache' to `passive' if you're just
interested in persistent articles:

     (setq gnus-use-cache 'passive)


File: gnus,  Node: Article Backlog,  Next: Saving Articles,  Prev: Persistent Articles,  Up: The Summary Buffer

Article Backlog
===============

   If you have a slow connection, but the idea of using caching seems
unappealing to you (and it is, really), you can help the situation some
by switching on the "backlog".  This is where Gnus will buffer already
read articles so that it doesn't have to re-fetch articles you've
already read.  This only helps if you are in the habit of re-selecting
articles you've recently read, of course.  If you never do that,
turning the backlog on will slow Gnus down a little bit, and increase
memory usage some.

   If you set `gnus-keep-backlog' to a number N, Gnus will store at
most N old articles in a buffer for later re-fetching.  If this
variable is non-`nil' and is not a number, Gnus will store _all_ read
articles, which means that your Emacs will grow without bound before
exploding and taking your machine down with you.  I put that in there
just to keep y'all on your toes.

   This variable is `nil' by default.


File: gnus,  Node: Saving Articles,  Next: Decoding Articles,  Prev: Article Backlog,  Up: The Summary Buffer

Saving Articles
===============

   Gnus can save articles in a number of ways.  Below is the
documentation for saving articles in a fairly straight-forward fashion
(i.e., little processing of the article is done before it is saved).
For a different approach (uudecoding, unsharing) you should use
`gnus-uu' (*note Decoding Articles::).

   If `gnus-save-all-headers' is non-`nil', Gnus will not delete
unwanted headers before saving the article.

   If the preceding variable is `nil', all headers that match the
`gnus-saved-headers' regexp will be kept, while the rest will be
deleted before saving.

`O o'
`o'
     Save the current article using the default article saver
     (`gnus-summary-save-article').

`O m'
     Save the current article in mail format
     (`gnus-summary-save-article-mail').

`O r'
     Save the current article in rmail format
     (`gnus-summary-save-article-rmail').

`O f'
     Save the current article in plain file format
     (`gnus-summary-save-article-file').

`O F'
     Write the current article in plain file format, overwriting any
     previous file contents (`gnus-summary-write-article-file').

`O b'
     Save the current article body in plain file format
     (`gnus-summary-save-article-body-file').

`O h'
     Save the current article in mh folder format
     (`gnus-summary-save-article-folder').

`O v'
     Save the current article in a VM folder
     (`gnus-summary-save-article-vm').

`O p'
     Save the current article in a pipe.  Uhm, like, what I mean
     is--Pipe the current article to a process
     (`gnus-summary-pipe-output').

   All these commands use the process/prefix convention (*note
Process/Prefix::).  If you save bunches of articles using these
functions, you might get tired of being prompted for files to save each
and every article in.  The prompting action is controlled by the
`gnus-prompt-before-saving' variable, which is `always' by default,
giving you that excessive prompting action you know and loathe.  If you
set this variable to `t' instead, you'll be prompted just once for each
series of articles you save.  If you like to really have Gnus do all
your thinking for you, you can even set this variable to `nil', which
means that you will never be prompted for files to save articles in.
Gnus will simply save all the articles in the default files.

   You can customize the `gnus-default-article-saver' variable to make
Gnus do what you want it to.  You can use any of the six ready-made
functions below, or you can create your own.

`gnus-summary-save-in-rmail'
     This is the default format, "babyl".  Uses the function in the
     `gnus-rmail-save-name' variable to get a file name to save the
     article in.  The default is `gnus-plain-save-name'.

`gnus-summary-save-in-mail'
     Save in a Unix mail (mbox) file.  Uses the function in the
     `gnus-mail-save-name' variable to get a file name to save the
     article in.  The default is `gnus-plain-save-name'.

`gnus-summary-save-in-file'
     Append the article straight to an ordinary file.  Uses the
     function in the `gnus-file-save-name' variable to get a file name
     to save the article in.  The default is `gnus-numeric-save-name'.

`gnus-summary-save-body-in-file'
     Append the article body to an ordinary file.  Uses the function in
     the `gnus-file-save-name' variable to get a file name to save the
     article in.  The default is `gnus-numeric-save-name'.

`gnus-summary-save-in-folder'
     Save the article to an MH folder using `rcvstore' from the MH
     library.  Uses the function in the `gnus-folder-save-name' variable
     to get a file name to save the article in.  The default is
     `gnus-folder-save-name', but you can also use
     `gnus-Folder-save-name', which creates capitalized names.

`gnus-summary-save-in-vm'
     Save the article in a VM folder.  You have to have the VM mail
     reader to use this setting.

   All of these functions, except for the last one, will save the
article in the `gnus-article-save-directory', which is initialized from
the `SAVEDIR' environment variable.  This is `~/News/' by default.

   As you can see above, the functions use different functions to find a
suitable name of a file to save the article in.  Below is a list of
available functions that generate names:

`gnus-Numeric-save-name'
     File names like `~/News/Alt.andrea-dworkin/45'.

`gnus-numeric-save-name'
     File names like `~/News/alt.andrea-dworkin/45'.

`gnus-Plain-save-name'
     File names like `~/News/Alt.andrea-dworkin'.

`gnus-plain-save-name'
     File names like `~/News/alt.andrea-dworkin'.

   You can have Gnus suggest where to save articles by plonking a
regexp into the `gnus-split-methods' alist.  For instance, if you would
like to save articles related to Gnus in the file `gnus-stuff', and
articles related to VM in `vm-stuff', you could set this variable to
something like:

     (("^Subject:.*gnus\\|^Newsgroups:.*gnus" "gnus-stuff")
      ("^Subject:.*vm\\|^Xref:.*vm" "vm-stuff")
      (my-choosing-function "../other-dir/my-stuff")
      ((equal gnus-newsgroup-name "mail.misc") "mail-stuff"))

   We see that this is a list where each element is a list that has two
elements--the "match" and the "file".  The match can either be a string
(in which case it is used as a regexp to match on the article head); it
can be a symbol (which will be called as a function with the group name
as a parameter); or it can be a list (which will be `eval'ed).  If any
of these actions have a non-`nil' result, the "file" will be used as a
default prompt.  In addition, the result of the operation itself will
be used if the function or form called returns a string or a list of
strings.

   You basically end up with a list of file names that might be used
when saving the current article.  (All "matches" will be used.)  You
will then be prompted for what you really want to use as a name, with
file name completion over the results from applying this variable.

   This variable is `((gnus-article-archive-name))' by default, which
means that Gnus will look at the articles it saves for an
`Archive-name' line and use that as a suggestion for the file name.

   Here's an example function to clean up file names somewhat.  If you
have lots of mail groups called things like `nnml:mail.whatever', you
may want to chop off the beginning of these group names before creating
the file name to save to.  The following will do just that:

     (defun my-save-name (group)
       (when (string-match "^nnml:mail." group)
         (substring group (match-end 0))))
     
     (setq gnus-split-methods
           '((gnus-article-archive-name)
             (my-save-name)))

   Finally, you have the `gnus-use-long-file-name' variable.  If it is
`nil', all the preceding functions will replace all periods (`.') in
the group names with slashes (`/')--which means that the functions will
generate hierarchies of directories instead of having all the files in
the top level directory (`~/News/alt/andrea-dworkin' instead of
`~/News/alt.andrea-dworkin'.)  This variable is `t' by default on most
systems.  However, for historical reasons, this is `nil' on Xenix and
usg-unix-v machines by default.

   This function also affects kill and score file names.  If this
variable is a list, and the list contains the element `not-score', long
file names will not be used for score files, if it contains the element
`not-save', long file names will not be used for saving, and if it
contains the element `not-kill', long file names will not be used for
kill files.

   If you'd like to save articles in a hierarchy that looks something
like a spool, you could

     (setq gnus-use-long-file-name '(not-save)) ; to get a hierarchy
     (setq gnus-default-article-saver
           'gnus-summary-save-in-file) ; no encoding

   Then just save with `o'.  You'd then read this hierarchy with
ephemeral `nneething' groups--`G D' in the group buffer, and the top
level directory as the argument (`~/News/').  Then just walk around to
the groups/directories with `nneething'.


File: gnus,  Node: Decoding Articles,  Next: Article Treatment,  Prev: Saving Articles,  Up: The Summary Buffer

Decoding Articles
=================

   Sometime users post articles (or series of articles) that have been
encoded in some way or other.  Gnus can decode them for you.

* Menu:

* Uuencoded Articles::    Uudecode articles.
* Shell Archives::        Unshar articles.
* PostScript Files::      Split PostScript.
* Other Files::           Plain save and binhex.
* Decoding Variables::    Variables for a happy decoding.
* Viewing Files::         You want to look at the result of the decoding?

   All these functions use the process/prefix convention (*note
Process/Prefix::) for finding out what articles to work on, with the
extension that a "single article" means "a single series".  Gnus can
find out by itself what articles belong to a series, decode all the
articles and unpack/view/save the resulting file(s).

   Gnus guesses what articles are in the series according to the
following simplish rule: The subjects must be (nearly) identical,
except for the last two numbers of the line.  (Spaces are largely
ignored, however.)

   For example: If you choose a subject called `cat.gif (2/3)', Gnus
will find all the articles that match the regexp `^cat.gif
([0-9]+/[0-9]+).*$'.

   Subjects that are non-standard, like `cat.gif (2/3) Part 6 of a
series', will not be properly recognized by any of the automatic viewing
commands, and you have to mark the articles manually with `#'.


File: gnus,  Node: Uuencoded Articles,  Next: Shell Archives,  Up: Decoding Articles

Uuencoded Articles
------------------

`X u'
     Uudecodes the current series (`gnus-uu-decode-uu').

`X U'
     Uudecodes and saves the current series
     (`gnus-uu-decode-uu-and-save').

`X v u'
     Uudecodes and views the current series (`gnus-uu-decode-uu-view').

`X v U'
     Uudecodes, views and saves the current series
     (`gnus-uu-decode-uu-and-save-view').

   Remember that these all react to the presence of articles marked with
the process mark.  If, for instance, you'd like to decode and save an
entire newsgroup, you'd typically do `M P a' (`gnus-uu-mark-all') and
then `X U' (`gnus-uu-decode-uu-and-save').

   All this is very much different from how `gnus-uu' worked with GNUS
4.1, where you had explicit keystrokes for everything under the sun.
This version of `gnus-uu' generally assumes that you mark articles in
some way (*note Setting Process Marks::) and then press `X u'.

   Note: When trying to decode articles that have names matching
`gnus-uu-notify-files', which is hard-coded to
`[Cc][Ii][Nn][Dd][Yy][0-9]+.\\(gif\\|jpg\\)', `gnus-uu' will
automatically post an article on `comp.unix.wizards' saying that you
have just viewed the file in question.  This feature can't be turned
off.


File: gnus,  Node: Shell Archives,  Next: PostScript Files,  Prev: Uuencoded Articles,  Up: Decoding Articles

Shell Archives
--------------

   Shell archives ("shar files") used to be a popular way to distribute
sources, but it isn't used all that much today.  In any case, we have
some commands to deal with these:

`X s'
     Unshars the current series (`gnus-uu-decode-unshar').

`X S'
     Unshars and saves the current series
     (`gnus-uu-decode-unshar-and-save').

`X v s'
     Unshars and views the current series
     (`gnus-uu-decode-unshar-view').

`X v S'
     Unshars, views and saves the current series
     (`gnus-uu-decode-unshar-and-save-view').


File: gnus,  Node: PostScript Files,  Next: Other Files,  Prev: Shell Archives,  Up: Decoding Articles

PostScript Files
----------------

`X p'
     Unpack the current PostScript series (`gnus-uu-decode-postscript').

`X P'
     Unpack and save the current PostScript series
     (`gnus-uu-decode-postscript-and-save').

`X v p'
     View the current PostScript series
     (`gnus-uu-decode-postscript-view').

`X v P'
     View and save the current PostScript series
     (`gnus-uu-decode-postscript-and-save-view').


File: gnus,  Node: Other Files,  Next: Decoding Variables,  Prev: PostScript Files,  Up: Decoding Articles

Other Files
-----------

`X o'
     Save the current series (`gnus-uu-decode-save').

`X b'
     Unbinhex the current series (`gnus-uu-decode-binhex').  This
     doesn't really work yet.


File: gnus,  Node: Decoding Variables,  Next: Viewing Files,  Prev: Other Files,  Up: Decoding Articles

Decoding Variables
------------------

   Adjective, not verb.

* Menu:

* Rule Variables::          Variables that say how a file is to be viewed.
* Other Decode Variables::  Other decode variables.
* Uuencoding and Posting::  Variables for customizing uuencoding.


File: gnus,  Node: Rule Variables,  Next: Other Decode Variables,  Up: Decoding Variables

Rule Variables
..............

   Gnus uses "rule variables" to decide how to view a file.  All these
variables are of the form

           (list '(regexp1 command2)
                 '(regexp2 command2)
                 ...)

`gnus-uu-user-view-rules'
     This variable is consulted first when viewing files.  If you wish
     to use, for instance, `sox' to convert an `.au' sound file, you
     could say something like:
          (setq gnus-uu-user-view-rules
                (list '("\\\\.au$" "sox %s -t .aiff > /dev/audio")))

`gnus-uu-user-view-rules-end'
     This variable is consulted if Gnus couldn't make any matches from
     the user and default view rules.

`gnus-uu-user-archive-rules'
     This variable can be used to say what commands should be used to
     unpack archives.


File: gnus,  Node: Other Decode Variables,  Next: Uuencoding and Posting,  Prev: Rule Variables,  Up: Decoding Variables

Other Decode Variables
......................

`gnus-uu-grabbed-file-functions'
     All functions in this list will be called right after each file
     has been successfully decoded--so that you can move or view files
     right away, and don't have to wait for all files to be decoded
     before you can do anything.  Ready-made functions you can put in
     this list are:

    `gnus-uu-grab-view'
          View the file.

    `gnus-uu-grab-move'
          Move the file (if you're using a saving function.)

`gnus-uu-be-dangerous'
     Specifies what to do if unusual situations arise during decoding.
     If `nil', be as conservative as possible.  If `t', ignore things
     that didn't work, and overwrite existing files.  Otherwise, ask
     each time.

`gnus-uu-ignore-files-by-name'
     Files with name matching this regular expression won't be viewed.

`gnus-uu-ignore-files-by-type'
     Files with a MIME type matching this variable won't be viewed.
     Note that Gnus tries to guess what type the file is based on the
     name.  `gnus-uu' is not a MIME package (yet), so this is slightly
     kludgey.

`gnus-uu-tmp-dir'
     Where `gnus-uu' does its work.

`gnus-uu-do-not-unpack-archives'
     Non-`nil' means that `gnus-uu' won't peek inside archives looking
     for files to display.

`gnus-uu-view-and-save'
     Non-`nil' means that the user will always be asked to save a file
     after viewing it.

`gnus-uu-ignore-default-view-rules'
     Non-`nil' means that `gnus-uu' will ignore the default viewing
     rules.

`gnus-uu-ignore-default-archive-rules'
     Non-`nil' means that `gnus-uu' will ignore the default archive
     unpacking commands.

`gnus-uu-kill-carriage-return'
     Non-`nil' means that `gnus-uu' will strip all carriage returns
     from articles.

`gnus-uu-unmark-articles-not-decoded'
     Non-`nil' means that `gnus-uu' will mark unsuccessfully decoded
     articles as unread.

`gnus-uu-correct-stripped-uucode'
     Non-`nil' means that `gnus-uu' will _try_ to fix uuencoded files
     that have had trailing spaces deleted.

`gnus-uu-pre-uudecode-hook'
     Hook run before sending a message to `uudecode'.

`gnus-uu-view-with-metamail'
     Non-`nil' means that `gnus-uu' will ignore the viewing commands
     defined by the rule variables and just fudge a MIME content type
     based on the file name.  The result will be fed to `metamail' for
     viewing.

`gnus-uu-save-in-digest'
     Non-`nil' means that `gnus-uu', when asked to save without
     decoding, will save in digests.  If this variable is `nil',
     `gnus-uu' will just save everything in a file without any
     embellishments.  The digesting almost conforms to RFC 1153--no
     easy way to specify any meaningful volume and issue numbers were
     found, so I simply dropped them.

