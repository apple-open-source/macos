This is ../info/emacs, produced by makeinfo version 4.0 from emacs.texi.

   This is the Fourteenth edition of the `GNU Emacs Manual', updated
for Emacs version 21.1.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307 USA

   Copyright (C) 1985,
1986,1987,1993,1994,1995,1996,1997,1998,1999,2000,2001    Free Software
Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "The GNU Manifesto", "Distribution" and "GNU
GENERAL PUBLIC LICENSE", with the Front-Cover texts being "A GNU
Manual," and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled "GNU Free Documentation
License."

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: emacs,  Node: Mode Line,  Next: Menu Bar,  Prev: Echo Area,  Up: Screen

The Mode Line
=============

   Each text window's last line is a "mode line", which describes what
is going on in that window.  When there is only one text window, the
mode line appears right above the echo area; it is the next-to-last
line in the frame.  The mode line starts and ends with dashes.  On a
text-mode display, the mode line is in inverse video if the terminal
supports that; on a graphics display, the mode line has a 3D box
appearance to help it stand out.

   Normally, the mode line looks like this:

     -CS:CH  BUF      (MAJOR MINOR)--LINE--POS------

This gives information about the buffer being displayed in the window:
the buffer's name, what major and minor modes are in use, whether the
buffer's text has been changed, and how far down the buffer you are
currently looking.

   CH contains two stars `**' if the text in the buffer has been edited
(the buffer is "modified"), or `--' if the buffer has not been edited.
For a read-only buffer, it is `%*' if the buffer is modified, and `%%'
otherwise.

   BUF is the name of the window's "buffer".  In most cases this is the
same as the name of a file you are editing.  *Note Buffers::.

   The buffer displayed in the selected window (the window that the
cursor is in) is also Emacs's current buffer, the one that editing
takes place in.  When we speak of what some command does to "the
buffer," we are talking about the current buffer.

   LINE is `L' followed by the current line number of point.  This is
present when Line Number mode is enabled (which it normally is).  You
can optionally display the current column number too, by turning on
Column Number mode (which is not enabled by default because it is
somewhat slower).  *Note Optional Mode Line::.

   POS tells you whether there is additional text above the top of the
window, or below the bottom.  If your buffer is small and it is all
visible in the window, POS is `All'.  Otherwise, it is `Top' if you are
looking at the beginning of the buffer, `Bot' if you are looking at the
end of the buffer, or `NN%', where NN is the percentage of the buffer
above the top of the window.

   MAJOR is the name of the "major mode" in effect in the buffer.  At
any time, each buffer is in one and only one of the possible major
modes.  The major modes available include Fundamental mode (the least
specialized), Text mode, Lisp mode, C mode, Texinfo mode, and many
others.  *Note Major Modes::, for details of how the modes differ and
how to select one.

   Some major modes display additional information after the major mode
name.  For example, Rmail buffers display the current message number and
the total number of messages.  Compilation buffers and Shell buffers
display the status of the subprocess.

   MINOR is a list of some of the "minor modes" that are turned on at
the moment in the window's chosen buffer.  For example, `Fill' means
that Auto Fill mode is on.  `Abbrev' means that Word Abbrev mode is on.
`Ovwrt' means that Overwrite mode is on.  *Note Minor Modes::, for
more information.  `Narrow' means that the buffer being displayed has
editing restricted to only a portion of its text.  This is not really a
minor mode, but is like one.  *Note Narrowing::.  `Def' means that a
keyboard macro is being defined.  *Note Keyboard Macros::.

   In addition, if Emacs is currently inside a recursive editing level,
square brackets (`[...]') appear around the parentheses that surround
the modes.  If Emacs is in one recursive editing level within another,
double square brackets appear, and so on.  Since recursive editing
levels affect Emacs globally, not just one buffer, the square brackets
appear in every window's mode line or not in any of them.  *Note
Recursive Edit::.

   Non-windowing terminals can only show a single Emacs frame at a time
(*note Frames::).  On such terminals, the mode line displays the name of
the selected frame, after CH.  The initial frame's name is `F1'.

   CS states the coding system used for the file you are editing.  A
dash indicates the default state of affairs: no code conversion, except
for end-of-line translation if the file contents call for that.  `='
means no conversion whatsoever.  Nontrivial code conversions are
represented by various letters--for example, `1' refers to ISO Latin-1.
*Note Coding Systems::, for more information.  If you are using an
input method, a string of the form `I>' is added to the beginning of
CS; I identifies the input method.  (Some input methods show `+' or `@'
instead of `>'.)  *Note Input Methods::.

   When you are using a character-only terminal (not a window system),
CS uses three characters to describe, respectively, the coding system
for keyboard input, the coding system for terminal output, and the
coding system used for the file you are editing.

   When multibyte characters are not enabled, CS does not appear at
all.  *Note Enabling Multibyte::.

   The colon after CS can change to another string in certain
circumstances.  Emacs uses newline characters to separate lines in the
buffer.  Some files use different conventions for separating lines:
either carriage-return linefeed (the MS-DOS convention) or just
carriage-return (the Macintosh convention).  If the buffer's file uses
carriage-return linefeed, the colon changes to either a backslash (`\')
or `(DOS)', depending on the operating system.  If the file uses just
carriage-return, the colon indicator changes to either a forward slash
(`/') or `(Mac)'.  On some systems, Emacs displays `(Unix)' instead of
the colon even for files that use newline to separate lines.

   You can customize the mode line display for each of the end-of-line
formats by setting each of the variables `eol-mnemonic-unix',
`eol-mnemonic-dos', `eol-mnemonic-mac', and `eol-mnemonic-undecided' to
any string you find appropriate.  *Note Variables::, for an explanation
of how to set variables.

   *Note Optional Mode Line::, for features that add other handy
information to the mode line, such as the current column number of
point, the current time, and whether new mail for you has arrived.

   The mode line is mouse-sensitive; when you move the mouse across
various parts of it, Emacs displays help text to say what a click in
that place will do.  *Note Mode Line Mouse::.


File: emacs,  Node: Menu Bar,  Prev: Mode Line,  Up: Screen

The Menu Bar
============

   Each Emacs frame normally has a "menu bar" at the top which you can
use to perform certain common operations.  There's no need to list them
here, as you can more easily see for yourself.

   When you are using a window system, you can use the mouse to choose a
command from the menu bar.  An arrow pointing right, after the menu
item, indicates that the item leads to a subsidiary menu; `...' at the
end means that the command will read arguments from the keyboard before
it actually does anything.

   To view the full command name and documentation for a menu item, type
`C-h k', and then select the menu bar with the mouse in the usual way
(*note Key Help::).

   On text-only terminals with no mouse, you can use the menu bar by
typing `M-`' or <F10> (these run the command `tmm-menubar').  This
command enters a mode in which you can select a menu item from the
keyboard.  A provisional choice appears in the echo area.  You can use
the left and right arrow keys to move through the menu to different
choices.  When you have found the choice you want, type <RET> to select
it.

   Each menu item also has an assigned letter or digit which designates
that item; it is usually the initial of some word in the item's name.
This letter or digit is separated from the item name by `=>'.  You can
type the item's letter or digit to select the item.

   Some of the commands in the menu bar have ordinary key bindings as
well; if so, the menu lists one equivalent key binding in parentheses
after the item itself.


File: emacs,  Node: User Input,  Next: Keys,  Prev: Screen,  Up: Top

Kinds of User Input
===================

   GNU Emacs uses an extension of the ASCII character set for keyboard
input; it also accepts non-character input events including function
keys and mouse button actions.

   ASCII consists of 128 character codes.  Some of these codes are
assigned graphic symbols such as `a' and `='; the rest are control
characters, such as `Control-a' (usually written `C-a' for short).
`C-a' gets its name from the fact that you type it by holding down the
<CTRL> key while pressing `a'.

   Some ASCII control characters have special names, and most terminals
have special keys you can type them with: for example, <RET>, <TAB>,
<DEL> and <ESC>.  The space character is usually referred to below as
<SPC>, even though strictly speaking it is a graphic character whose
graphic happens to be blank.  Some keyboards have a key labeled
"linefeed" which is an alias for `C-j'.

   Emacs extends the ASCII character set with thousands more printing
characters (*note International::), additional control characters, and a
few more modifiers that can be combined with any character.

   On ASCII terminals, there are only 32 possible control characters.
These are the control variants of letters and `@[]\^_'.  In addition,
the shift key is meaningless with control characters: `C-a' and `C-A'
are the same character, and Emacs cannot distinguish them.

   But the Emacs character set has room for control variants of all
printing characters, and for distinguishing between `C-a' and `C-A'.
The X Window System makes it possible to enter all these characters.
For example, `C--' (that's Control-Minus) and `C-5' are meaningful
Emacs commands under X.

   Another Emacs character-set extension is additional modifier bits.
Only one modifier bit is commonly used; it is called Meta.  Every
character has a Meta variant; examples include `Meta-a' (normally
written `M-a', for short), `M-A' (not the same character as `M-a', but
those two characters normally have the same meaning in Emacs),
`M-<RET>', and `M-C-a'.  For reasons of tradition, we usually write
`C-M-a' rather than `M-C-a'; logically speaking, the order in which the
modifier keys <CTRL> and <META> are mentioned does not matter.

   Some terminals have a <META> key, and allow you to type Meta
characters by holding this key down.  Thus, `Meta-a' is typed by
holding down <META> and pressing `a'.  The <META> key works much like
the <SHIFT> key.  Such a key is not always labeled <META>, however, as
this function is often a special option for a key with some other
primary purpose.  Sometimes it is labeled <ALT> or <EDIT>; on a Sun
keyboard, it may have a diamond on it.

   If there is no <META> key, you can still type Meta characters using
two-character sequences starting with <ESC>.  Thus, you can enter `M-a'
by typing `<ESC> a'.  You can enter `C-M-a' by typing `<ESC> C-a'.
<ESC> is allowed on terminals with <META> keys, too, in case you have
formed a habit of using it.

   The X Window System provides several other modifier keys that can be
applied to any input character.  These are called <SUPER>, <HYPER> and
<ALT>.  We write `s-', `H-' and `A-' to say that a character uses these
modifiers.  Thus, `s-H-C-x' is short for `Super-Hyper-Control-x'.  Not
all X terminals actually provide keys for these modifier flags--in
fact, many terminals have a key labeled <ALT> which is really a <META>
key.  The standard key bindings of Emacs do not include any characters
with these modifiers.  But you can assign them meanings of your own by
customizing Emacs.

   Keyboard input includes keyboard keys that are not characters at all:
for example function keys and arrow keys.  Mouse buttons are also
outside the gamut of characters.  You can modify these events with the
modifier keys <CTRL>, <META>, <SUPER>, <HYPER> and <ALT>, just like
keyboard characters.

   Input characters and non-character inputs are collectively called
"input events".  *Note Input Events: (elisp)Input Events, for more
information.  If you are not doing Lisp programming, but simply want to
redefine the meaning of some characters or non-character events, see
*Note Customization::.

   ASCII terminals cannot really send anything to the computer except
ASCII characters.  These terminals use a sequence of characters to
represent each function key.  But that is invisible to the Emacs user,
because the keyboard input routines recognize these special sequences
and convert them to function key events before any other part of Emacs
gets to see them.


File: emacs,  Node: Keys,  Next: Commands,  Prev: User Input,  Up: Top

Keys
====

   A "key sequence" ("key", for short) is a sequence of input events
that are meaningful as a unit--as "a single command."  Some Emacs
command sequences are just one character or one event; for example,
just `C-f' is enough to move forward one character in the buffer.  But
Emacs also has commands that take two or more events to invoke.

   If a sequence of events is enough to invoke a command, it is a
"complete key".  Examples of complete keys include `C-a', `X', <RET>,
<NEXT> (a function key), <DOWN> (an arrow key), `C-x C-f', and `C-x 4
C-f'.  If it isn't long enough to be complete, we call it a "prefix
key".  The above examples show that `C-x' and `C-x 4' are prefix keys.
Every key sequence is either a complete key or a prefix key.

   Most single characters constitute complete keys in the standard Emacs
command bindings.  A few of them are prefix keys.  A prefix key combines
with the following input event to make a longer key sequence, which may
itself be complete or a prefix.  For example, `C-x' is a prefix key, so
`C-x' and the next input event combine to make a two-event key
sequence.  Most of these key sequences are complete keys, including
`C-x C-f' and `C-x b'.  A few, such as `C-x 4' and `C-x r', are
themselves prefix keys that lead to three-event key sequences.  There's
no limit to the length of a key sequence, but in practice people rarely
use sequences longer than four events.

   By contrast, you can't add more events onto a complete key.  For
example, the two-event sequence `C-f C-k' is not a key, because the
`C-f' is a complete key in itself.  It's impossible to give `C-f C-k'
an independent meaning as a command.  `C-f C-k' is two key sequences,
not one.

   All told, the prefix keys in Emacs are `C-c', `C-h', `C-x', `C-x
<RET>', `C-x @', `C-x a', `C-x n', `C-x r', `C-x v', `C-x 4', `C-x 5',
`C-x 6', <ESC>, and `M-g'.  But this list is not cast in concrete; it is
just a matter of Emacs's standard key bindings.  If you customize Emacs,
you can make new prefix keys, or eliminate these.  *Note Key Bindings::.

   If you do make or eliminate prefix keys, that changes the set of
possible key sequences.  For example, if you redefine `C-f' as a
prefix, `C-f C-k' automatically becomes a key (complete, unless you
define that too as a prefix).  Conversely, if you remove the prefix
definition of `C-x 4', then `C-x 4 f' (or `C-x 4 ANYTHING') is no
longer a key.

   Typing the help character (`C-h' or <F1>) after a prefix key
displays a list of the commands starting with that prefix.  There are a
few prefix keys for which `C-h' does not work--for historical reasons,
they have other meanings for `C-h' which are not easy to change.  But
<F1> should work for all prefix keys.


File: emacs,  Node: Commands,  Next: Text Characters,  Prev: Keys,  Up: Top

Keys and Commands
=================

   This manual is full of passages that tell you what particular keys
do.  But Emacs does not assign meanings to keys directly.  Instead,
Emacs assigns meanings to named "commands", and then gives keys their
meanings by "binding" them to commands.

   Every command has a name chosen by a programmer.  The name is usually
made of a few English words separated by dashes; for example,
`next-line' or `forward-word'.  A command also has a "function
definition" which is a Lisp program; this is what makes the command do
what it does.  In Emacs Lisp, a command is actually a special kind of
Lisp function; one which specifies how to read arguments for it and
call it interactively.  For more information on commands and functions,
see *Note What Is a Function: (elisp)What Is a Function.  (The
definition we use in this manual is simplified slightly.)

   The bindings between keys and commands are recorded in various tables
called "keymaps".  *Note Keymaps::.

   When we say that "`C-n' moves down vertically one line" we are
glossing over a distinction that is irrelevant in ordinary use but is
vital in understanding how to customize Emacs.  It is the command
`next-line' that is programmed to move down vertically.  `C-n' has this
effect _because_ it is bound to that command.  If you rebind `C-n' to
the command `forward-word' then `C-n' will move forward by words
instead.  Rebinding keys is a common method of customization.

   In the rest of this manual, we usually ignore this subtlety to keep
things simple.  To give the information needed for customization, we
state the name of the command which really does the work in parentheses
after mentioning the key that runs it.  For example, we will say that
"The command `C-n' (`next-line') moves point vertically down," meaning
that `next-line' is a command that moves vertically down, and `C-n' is
a key that is normally bound to it.

   While we are on the subject of information for customization only,
it's a good time to tell you about "variables".  Often the description
of a command will say, "To change this, set the variable `mumble-foo'."
A variable is a name used to remember a value.  Most of the variables
documented in this manual exist just to facilitate customization: some
command or other part of Emacs examines the variable and behaves
differently according to the value that you set.  Until you are
interested in customizing, you can ignore the information about
variables.  When you are ready to be interested, read the basic
information on variables, and then the information on individual
variables will make sense.  *Note Variables::.


File: emacs,  Node: Text Characters,  Next: Entering Emacs,  Prev: Commands,  Up: Top

Character Set for Text
======================

   Text in Emacs buffers is a sequence of 8-bit bytes.  Each byte can
hold a single ASCII character.  Both ASCII control characters (octal
codes 000 through 037, and 0177) and ASCII printing characters (codes
040 through 0176) are allowed; however, non-ASCII control characters
cannot appear in a buffer.  The other modifier flags used in keyboard
input, such as Meta, are not allowed in buffers either.

   Some ASCII control characters serve special purposes in text, and
have special names.  For example, the newline character (octal code
012) is used in the buffer to end a line, and the tab character (octal
code 011) is used for indenting to the next tab stop column (normally
every 8 columns).  *Note Text Display::.

   Non-ASCII printing characters can also appear in buffers.  When
multibyte characters are enabled, you can use any of the non-ASCII
printing characters that Emacs supports.  They have character codes
starting at 256, octal 0400, and each one is represented as a sequence
of two or more bytes.  *Note International::.  Single-byte characters
with codes 128 through 255 can also appear in multibyte buffers.

   If you disable multibyte characters, then you can use only one
alphabet of non-ASCII characters, but they all fit in one byte.  They
use codes 0200 through 0377.  *Note Single-Byte Character Support::.


File: emacs,  Node: Entering Emacs,  Next: Exiting,  Prev: Text Characters,  Up: Top

Entering and Exiting Emacs
**************************

   The usual way to invoke Emacs is with the shell command `emacs'.
Emacs clears the screen and then displays an initial help message and
copyright notice.  Some operating systems discard all type-ahead when
Emacs starts up; they give Emacs no way to prevent this.  Therefore, it
is advisable to wait until Emacs clears the screen before typing your
first editing command.

   If you run Emacs from a shell window under the X Window System, run
it in the background with `emacs&'.  This way, Emacs does not tie up
the shell window, so you can use that to run other shell commands while
Emacs operates its own X windows.  You can begin typing Emacs commands
as soon as you direct your keyboard input to the Emacs frame.

   When Emacs starts up, it creates a buffer named `*scratch*'.  That's
the buffer you start out in.  The `*scratch*' buffer uses Lisp
Interaction mode; you can use it to type Lisp expressions and evaluate
them, or you can ignore that capability and simply doodle.  (You can
specify a different major mode for this buffer by setting the variable
`initial-major-mode' in your init file.  *Note Init File::.)

   It is possible to specify files to be visited, Lisp files to be
loaded, and functions to be called, by giving Emacs arguments in the
shell command line.  *Note Command Arguments::.  But we don't recommend
doing this.  The feature exists mainly for compatibility with other
editors.

   Many other editors are designed to be started afresh each time you
want to edit.  You edit one file and then exit the editor.  The next
time you want to edit either another file or the same one, you must run
the editor again.  With these editors, it makes sense to use a
command-line argument to say which file to edit.

   But starting a new Emacs each time you want to edit a different file
does not make sense.  For one thing, this would be annoyingly slow.
For another, this would fail to take advantage of Emacs's ability to
visit more than one file in a single editing session.  And it would
lose the other accumulated context, such as the kill ring, registers,
undo history, and mark ring.

   The recommended way to use GNU Emacs is to start it only once, just
after you log in, and do all your editing in the same Emacs session.
Each time you want to edit a different file, you visit it with the
existing Emacs, which eventually comes to have many files in it ready
for editing.  Usually you do not kill the Emacs until you are about to
log out.  *Note Files::, for more information on visiting more than one
file.


File: emacs,  Node: Exiting,  Next: Basic,  Prev: Entering Emacs,  Up: Top

Exiting Emacs
=============

   There are two commands for exiting Emacs because there are two kinds
of exiting: "suspending" Emacs and "killing" Emacs.

   "Suspending" means stopping Emacs temporarily and returning control
to its parent process (usually a shell), allowing you to resume editing
later in the same Emacs job, with the same buffers, same kill ring,
same undo history, and so on.  This is the usual way to exit.

   "Killing" Emacs means destroying the Emacs job.  You can run Emacs
again later, but you will get a fresh Emacs; there is no way to resume
the same editing session after it has been killed.

`C-z'
     Suspend Emacs (`suspend-emacs') or iconify a frame
     (`iconify-or-deiconify-frame').

`C-x C-c'
     Kill Emacs (`save-buffers-kill-emacs').

   To suspend Emacs, type `C-z' (`suspend-emacs').  This takes you back
to the shell from which you invoked Emacs.  You can resume Emacs with
the shell command `%emacs' in most common shells.

   On systems that do not support suspending programs, `C-z' starts an
inferior shell that communicates directly with the terminal.  Emacs
waits until you exit the subshell.  (The way to do that is probably
with `C-d' or `exit', but it depends on which shell you use.)  The only
way on these systems to get back to the shell from which Emacs was run
(to log out, for example) is to kill Emacs.

   Suspending also fails if you run Emacs under a shell that doesn't
support suspending programs, even if the system itself does support it.
In such a case, you can set the variable `cannot-suspend' to a
non-`nil' value to force `C-z' to start an inferior shell.  (One might
also describe Emacs's parent shell as "inferior" for failing to support
job control properly, but that is a matter of taste.)

   When Emacs communicates directly with an X server and creates its own
dedicated X windows, `C-z' has a different meaning.  Suspending an
application that uses its own X windows is not meaningful or useful.
Instead, `C-z' runs the command `iconify-or-deiconify-frame', which
temporarily iconifies (or "minimizes") the selected Emacs frame (*note
Frames::).  Then you can use the window manager to get back to a shell
window.

   To exit and kill Emacs, type `C-x C-c' (`save-buffers-kill-emacs').
A two-character key is used for this to make it harder to type by
accident.  This command first offers to save any modified file-visiting
buffers.  If you do not save them all, it asks for reconfirmation with
`yes' before killing Emacs, since any changes not saved will be lost
forever.  Also, if any subprocesses are still running, `C-x C-c' asks
for confirmation about them, since killing Emacs will also kill the
subprocesses.

   If the value of the variable `confirm-kill-emacs' is non-`nil', `C-x
C-c' assumes that its value is a predicate function, and calls that
function.  If the result is non-`nil', the session is killed, otherwise
Emacs continues to run.  One convenient function to use as the value of
`confirm-kill-emacs' is the function `yes-or-no-p'.  The default value
of `confirm-kill-emacs' is `nil'.

   There is no way to resume an Emacs session once you have killed it.
You can, however, arrange for Emacs to record certain session
information when you kill it, such as which files are visited, so that
the next time you start Emacs it will try to visit the same files and
so on.  *Note Saving Emacs Sessions::.

   The operating system usually listens for certain special characters
whose meaning is to kill or suspend the program you are running.  This
operating system feature is turned off while you are in Emacs.  The
meanings of `C-z' and `C-x C-c' as keys in Emacs were inspired by the
use of `C-z' and `C-c' on several operating systems as the characters
for stopping or killing a program, but that is their only relationship
with the operating system.  You can customize these keys to run any
commands of your choice (*note Keymaps::).


File: emacs,  Node: Basic,  Next: Minibuffer,  Prev: Exiting,  Up: Top

Basic Editing Commands
**********************

   We now give the basics of how to enter text, make corrections, and
save the text in a file.  If this material is new to you, you might
learn it more easily by running the Emacs learn-by-doing tutorial.  To
use the tutorial, run Emacs and type `Control-h t'
(`help-with-tutorial').

   To clear the screen and redisplay, type `C-l' (`recenter').

* Menu:


* Inserting Text::      Inserting text by simply typing it.
* Moving Point::        How to move the cursor to the place where you want to
			  change something.
* Erasing::	        Deleting and killing text.
* Undo::	        Undoing recent changes in the text.
* Files: Basic Files.   Visiting, creating, and saving files.
* Help: Basic Help.     Asking what a character does.
* Blank Lines::	        Commands to make or delete blank lines.
* Continuation Lines::  Lines too wide for the screen.
* Position Info::       What page, line, row, or column is point on?
* Arguments::	        Numeric arguments for repeating a command.
* Repeating::           A short-cut for repeating the previous command.


File: emacs,  Node: Inserting Text,  Next: Moving Point,  Up: Basic

Inserting Text
==============

   To insert printing characters into the text you are editing, just
type them.  This inserts the characters you type into the buffer at the
cursor (that is, at "point"; *note Point::).  The cursor moves forward,
and any text after the cursor moves forward too.  If the text in the
buffer is `FOOBAR', with the cursor before the `B', then if you type
`XX', you get `FOOXXBAR', with the cursor still before the `B'.

   To "delete" text you have just inserted, use the large key labeled
<DEL>, <BACKSPACE> or <DELETE> which is a short distance above the
<RET> or <ENTER> key.  This is the key you normally use, outside Emacs,
for erasing the last character that you typed.  Regardless of the label
on that key, Emacs thinks of it as <DEL>, and that's what we call it in
this manual.

   The <DEL> key deletes the character _before_ the cursor.  As a
consequence, the cursor and all the characters after it move backwards.
If you type a printing character and then type <DEL>, they cancel out.

   On most computers, Emacs recognizes automatically which key ought to
be <DEL>, and sets it up that way.  But in some cases, especially with
text-only terminals, you will need to tell Emacs which key to use for
that purpose.  If the large key not far above the <RET> or <ENTER> key
doesn't delete backwards, you need to do this.  *Note DEL Does Not
Delete::, for an explanation of how.

   Most PC keyboards have both a <BACKSPACE> key a short ways above
<RET> or <ENTER>, and a <DELETE> key elsewhere.  On these keyboards,
Emacs supports when possible the usual convention that the <BACKSPACE>
key deletes backwards (it is <DEL>), while the <DELETE> key deletes
"forwards," deleting the character after point, the one underneath the
cursor, like `C-d' (see below).

   To end a line and start typing a new one, type <RET>.  This inserts
a newline character in the buffer.  If point is in the middle of a
line, <RET> splits the line.  Typing <DEL> when the cursor is at the
beginning of a line deletes the preceding newline, thus joining the
line with the preceding line.

   Emacs can split lines automatically when they become too long, if you
turn on a special minor mode called "Auto Fill" mode.  *Note Filling::,
for how to use Auto Fill mode.

   If you prefer to have text characters replace (overwrite) existing
text rather than shove it to the right, you can enable Overwrite mode,
a minor mode.  *Note Minor Modes::.

   Direct insertion works for printing characters and <SPC>, but other
characters act as editing commands and do not insert themselves.  If you
need to insert a control character or a character whose code is above
200 octal, you must "quote" it by typing the character `Control-q'
(`quoted-insert') first.  (This character's name is normally written
`C-q' for short.)  There are two ways to use `C-q':

   * `C-q' followed by any non-graphic character (even `C-g') inserts
     that character.

   * `C-q' followed by a sequence of octal digits inserts the character
     with the specified octal character code.  You can use any number of
     octal digits; any non-digit terminates the sequence.  If the
     terminating character is <RET>, it serves only to terminate the
     sequence.  Any other non-digit terminates the sequence and then
     acts as normal input--thus, `C-q 1 0 1 B' inserts `AB'.

     The use of octal sequences is disabled in ordinary non-binary
     Overwrite mode, to give you a convenient way to insert a digit
     instead of overwriting with it.

When multibyte characters are enabled, if you specify a code in the
range 0200 through 0377 octal, `C-q' assumes that you intend to use
some ISO 8859-N character set, and converts the specified code to the
corresponding Emacs character code.  *Note Enabling Multibyte::.  You
select _which_ of the ISO 8859 character sets to use through your
choice of language environment (*note Language Environments::).

   To use decimal or hexadecimal instead of octal, set the variable
`read-quoted-char-radix' to 10 or 16.  If the radix is greater than 10,
some letters starting with `a' serve as part of a character code, just
like digits.

   A numeric argument to `C-q' specifies how many copies of the quoted
character should be inserted (*note Arguments::).

   Customization information: <DEL> in most modes runs the command
`delete-backward-char'; <RET> runs the command `newline', and
self-inserting printing characters run the command `self-insert', which
inserts whatever character was typed to invoke it.  Some major modes
rebind <DEL> to other commands.


File: emacs,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Basic

Changing the Location of Point
==============================

   To do more than insert characters, you have to know how to move point
(*note Point::).  The simplest way to do this is with arrow keys, or by
clicking the left mouse button where you want to move to.

   There are also control and meta characters for cursor motion.  Some
are equivalent to the arrow keys (these date back to the days before
terminals had arrow keys, and are usable on terminals which don't have
them).  Others do more sophisticated things.

`C-a'
     Move to the beginning of the line (`beginning-of-line').

`C-e'
     Move to the end of the line (`end-of-line').

`C-f'
     Move forward one character (`forward-char').  The right-arrow key
     does the same thing.

`C-b'
     Move backward one character (`backward-char').  The left-arrow key
     has the same effect.

`M-f'
     Move forward one word (`forward-word').

`M-b'
     Move backward one word (`backward-word').

`C-n'
     Move down one line, vertically (`next-line').  This command
     attempts to keep the horizontal position unchanged, so if you
     start in the middle of one line, you end in the middle of the
     next.  The down-arrow key does the same thing.

`C-p'
     Move up one line, vertically (`previous-line').  The up-arrow key
     has the same effect.

`M-r'
     Move point to left margin, vertically centered in the window
     (`move-to-window-line').  Text does not move on the screen.

     A numeric argument says which screen line to place point on.  It
     counts screen lines down from the top of the window (zero for the
     top line).  A negative argument counts lines from the bottom (-1
     for the bottom line).

`M-<'
     Move to the top of the buffer (`beginning-of-buffer').  With
     numeric argument N, move to N/10 of the way from the top.  *Note
     Arguments::, for more information on numeric arguments.

`M->'
     Move to the end of the buffer (`end-of-buffer').

`C-v'
     Scroll the display one screen forward, and move point if necessary
     to put it on the screen (`scroll-up').  This doesn't always move
     point, but it is commonly used to do so.  If your keyboard has a
     <PAGEDOWN> key, it does the same thing.

     Scrolling commands are further described in *Note Scrolling::.

`M-v'
     Scroll one screen backward, and move point if necessary to put it
     on the screen (`scroll-down').  This doesn't always move point, but
     it is commonly used to do so.  The <PAGEUP> key has the same
     effect.

`M-x goto-char'
     Read a number N and move point to buffer position N.  Position 1
     is the beginning of the buffer.

`M-x goto-line'
     Read a number N and move point to line number N.  Line 1 is the
     beginning of the buffer.

`C-x C-n'
     Use the current column of point as the "semipermanent goal column"
     for `C-n' and `C-p' (`set-goal-column').  Henceforth, those
     commands always move to this column in each line moved into, or as
     close as possible given the contents of the line.  This goal
     column remains in effect until canceled.

`C-u C-x C-n'
     Cancel the goal column.  Henceforth, `C-n' and `C-p' once again
     try to stick to a fixed horizontal position, as usual.

   If you set the variable `track-eol' to a non-`nil' value, then `C-n'
and `C-p', when starting at the end of the line, move to the end of
another line.  Normally, `track-eol' is `nil'.  *Note Variables::, for
how to set variables such as `track-eol'.

   `C-n' normally gets an error when you use it on the last line of the
buffer (just as `C-p' gets an error on the first line).  But if you set
the variable `next-line-add-newlines' to a non-`nil' value, `C-n' on
the last line of a buffer creates an additional line at the end and
moves down onto it.


File: emacs,  Node: Erasing,  Next: Undo,  Prev: Moving Point,  Up: Basic

Erasing Text
============

`<DEL>'
     Delete the character before point (`delete-backward-char').

`C-d'
     Delete the character after point (`delete-char').

`<DELETE>'
`<BACKSPACE>'
     One of these keys, whichever is the large key above the <RET> or
     <ENTER> key, deletes the character before point, like <DEL>.  If
     that is <BACKSPACE>, and your keyboard also has <DELETE>, then
     <DELETE> deletes forwards, like `C-d'.

`C-k'
     Kill to the end of the line (`kill-line').

`M-d'
     Kill forward to the end of the next word (`kill-word').

`M-<DEL>'
     Kill back to the beginning of the previous word
     (`backward-kill-word').

   You already know about the <DEL> key which deletes the character
before point (that is, before the cursor).  Another key, `Control-d'
(`C-d' for short), deletes the character after point (that is, the
character that the cursor is on).  This shifts the rest of the text on
the line to the left.  If you type `C-d' at the end of a line, it joins
together that line and the next line.

   To erase a larger amount of text, use the `C-k' key, which kills a
line at a time.  If you type `C-k' at the beginning or middle of a
line, it kills all the text up to the end of the line.  If you type
`C-k' at the end of a line, it joins that line and the next line.

   *Note Killing::, for more flexible ways of killing text.


File: emacs,  Node: Undo,  Next: Basic Files,  Prev: Erasing,  Up: Basic

Undoing Changes
===============

   You can undo all the recent changes in the buffer text, up to a
certain point.  Each buffer records changes individually, and the undo
command always applies to the current buffer.  Usually each editing
command makes a separate entry in the undo records, but some commands
such as `query-replace' make many entries, and very simple commands
such as self-inserting characters are often grouped to make undoing less
tedious.

`C-x u'
     Undo one batch of changes--usually, one command worth (`undo').

`C-_'
     The same.

`C-u C-x u'
     Undo one batch of changes in the region.

   The command `C-x u' or `C-_' is how you undo.  The first time you
give this command, it undoes the last change.  Point moves back to
where it was before the command that made the change.

   Consecutive repetitions of `C-_' or `C-x u' undo earlier and earlier
changes, back to the limit of the undo information available.  If all
recorded changes have already been undone, the undo command displays an
error message and does nothing.

   Any command other than an undo command breaks the sequence of undo
commands.  Starting from that moment, the previous undo commands become
ordinary changes that you can undo.  Thus, to redo changes you have
undone, type `C-f' or any other command that will harmlessly break the
sequence of undoing, then type more undo commands.

   Ordinary undo applies to all changes made in the current buffer.  You
can also perform "selective undo", limited to the current region.  To
do this, specify the region you want, then run the `undo' command with
a prefix argument (the value does not matter): `C-u C-x u' or `C-u
C-_'.  This undoes the most recent change in the region.  To undo
further changes in the same region, repeat the `undo' command (no
prefix argument is needed).  In Transient Mark mode, any use of `undo'
when there is an active region performs selective undo; you do not need
a prefix argument.

   If you notice that a buffer has been modified accidentally, the
easiest way to recover is to type `C-_' repeatedly until the stars
disappear from the front of the mode line.  At this time, all the
modifications you made have been canceled.  Whenever an undo command
makes the stars disappear from the mode line, it means that the buffer
contents are the same as they were when the file was last read in or
saved.

   If you do not remember whether you changed the buffer deliberately,
type `C-_' once.  When you see the last change you made undone, you
will see whether it was an intentional change.  If it was an accident,
leave it undone.  If it was deliberate, redo the change as described
above.

   Not all buffers record undo information.  Buffers whose names start
with spaces don't; these buffers are used internally by Emacs and its
extensions to hold text that users don't normally look at or edit.

   You cannot undo mere cursor motion; only changes in the buffer
contents save undo information.  However, some cursor motion commands
set the mark, so if you use these commands from time to time, you can
move back to the neighborhoods you have moved through by popping the
mark ring (*note Mark Ring::).

   When the undo information for a buffer becomes too large, Emacs
discards the oldest undo information from time to time (during garbage
collection).  You can specify how much undo information to keep by
setting two variables: `undo-limit' and `undo-strong-limit'.  Their
values are expressed in units of bytes of space.

   The variable `undo-limit' sets a soft limit: Emacs keeps undo data
for enough commands to reach this size, and perhaps exceed it, but does
not keep data for any earlier commands beyond that.  Its default value
is 20000.  The variable `undo-strong-limit' sets a stricter limit: the
command which pushes the size past this amount is itself forgotten.
Its default value is 30000.

   Regardless of the values of those variables, the most recent change
is never discarded, so there is no danger that garbage collection
occurring right after an unintentional large change might prevent you
from undoing it.

   The reason the `undo' command has two keys, `C-x u' and `C-_', set
up to run it is that it is worthy of a single-character key, but on
some keyboards it is not obvious how to type `C-_'.  `C-x u' is an
alternative you can type straightforwardly on any terminal.


File: emacs,  Node: Basic Files,  Next: Basic Help,  Prev: Undo,  Up: Basic

Files
=====

   The commands described above are sufficient for creating and altering
text in an Emacs buffer; the more advanced Emacs commands just make
things easier.  But to keep any text permanently you must put it in a
"file".  Files are named units of text which are stored by the
operating system for you to retrieve later by name.  To look at or use
the contents of a file in any way, including editing the file with
Emacs, you must specify the file name.

   Consider a file named `/usr/rms/foo.c'.  In Emacs, to begin editing
this file, type

     C-x C-f /usr/rms/foo.c <RET>

Here the file name is given as an "argument" to the command `C-x C-f'
(`find-file').  That command uses the "minibuffer" to read the
argument, and you type <RET> to terminate the argument (*note
Minibuffer::).

   Emacs obeys the command by "visiting" the file: creating a buffer,
copying the contents of the file into the buffer, and then displaying
the buffer for you to edit.  If you alter the text, you can "save" the
new text in the file by typing `C-x C-s' (`save-buffer').  This makes
the changes permanent by copying the altered buffer contents back into
the file `/usr/rms/foo.c'.  Until you save, the changes exist only
inside Emacs, and the file `foo.c' is unaltered.

   To create a file, just visit the file with `C-x C-f' as if it
already existed.  This creates an empty buffer in which you can insert
the text you want to put in the file.  The file is actually created when
you save this buffer with `C-x C-s'.

   Of course, there is a lot more to learn about using files.  *Note
Files::.


File: emacs,  Node: Basic Help,  Next: Blank Lines,  Prev: Basic Files,  Up: Basic

Help
====

   If you forget what a key does, you can find out with the Help
character, which is `C-h' (or <F1>, which is an alias for `C-h').  Type
`C-h k' followed by the key you want to know about; for example, `C-h k
C-n' tells you all about what `C-n' does.  `C-h' is a prefix key; `C-h
k' is just one of its subcommands (the command `describe-key').  The
other subcommands of `C-h' provide different kinds of help.  Type `C-h'
twice to get a description of all the help facilities.  *Note Help::.


File: emacs,  Node: Blank Lines,  Next: Continuation Lines,  Prev: Basic Help,  Up: Basic

Blank Lines
===========

   Here are special commands and techniques for putting in and taking
out blank lines.

`C-o'
     Insert one or more blank lines after the cursor (`open-line').

`C-x C-o'
     Delete all but one of many consecutive blank lines
     (`delete-blank-lines').

   When you want to insert a new line of text before an existing line,
you can do it by typing the new line of text, followed by <RET>.
However, it may be easier to see what you are doing if you first make a
blank line and then insert the desired text into it.  This is easy to do
using the key `C-o' (`open-line'), which inserts a newline after point
but leaves point in front of the newline.  After `C-o', type the text
for the new line.  `C-o F O O' has the same effect as `F O O <RET>',
except for the final location of point.

   You can make several blank lines by typing `C-o' several times, or
by giving it a numeric argument to tell it how many blank lines to make.
*Note Arguments::, for how.  If you have a fill prefix, then `C-o'
command inserts the fill prefix on the new line, when you use it at the
beginning of a line.  *Note Fill Prefix::.

   The easy way to get rid of extra blank lines is with the command
`C-x C-o' (`delete-blank-lines').  `C-x C-o' in a run of several blank
lines deletes all but one of them.  `C-x C-o' on a solitary blank line
deletes that blank line.  When point is on a nonblank line, `C-x C-o'
deletes any blank lines following that nonblank line.


File: emacs,  Node: Continuation Lines,  Next: Position Info,  Prev: Blank Lines,  Up: Basic

Continuation Lines
==================

   If you add too many characters to one line without breaking it with
<RET>, the line grows to occupy two (or more) lines on the screen.  On
graphical displays, Emacs indicates line wrapping with small bent
arrows in the fringes to the left and right of the window.  On
text-only terminals, Emacs displays a `\' character at the right margin
of a screen line if it is not the last in its text line.  This `\'
character says that the following screen line is not really a distinct
line in the text, just a "continuation" of a line too long to fit the
screen.  Continuation is also called "line wrapping".

   When line wrapping occurs before a character that is wider than one
column, some columns at the end of the previous screen line may be
"empty."  In this case, Emacs displays additional `\' characters in the
"empty" columns, just before the `\' character that indicates
continuation.

   Sometimes it is nice to have Emacs insert newlines automatically when
a line gets too long.  Continuation on the screen does not do that.  Use
Auto Fill mode (*note Filling::) if that's what you want.

   As an alternative to continuation, Emacs can display long lines by
"truncation".  This means that all the characters that do not fit in
the width of the screen or window do not appear at all.  They remain in
the buffer, temporarily invisible.  On terminals, `$' in the last
column informs you that the line has been truncated on the display.  On
window systems, a small straight arrow in the fringe to the right of
the window indicates a truncated line.

   Truncation instead of continuation happens whenever horizontal
scrolling is in use, and optionally in all side-by-side windows (*note
Windows::).  You can enable or disable truncation for a particular
buffer with the command `M-x toggle-truncate-lines'.

   *Note Display Custom::, for additional variables that affect how
text is displayed.

