--- macosx/tkMacOSXMouseEvent.c.orig	2004-08-03 16:16:32.000000000 -0700
+++ macosx/tkMacOSXMouseEvent.c	2004-08-03 16:19:44.000000000 -0700
@@ -117,6 +117,7 @@
     int            status,err;
     MouseEventData mouseEventData, * medPtr = &mouseEventData;
     KeyMap         keyMap;
+    long           modif;
 
     switch (eventPtr->eKind) {
         case kEventMouseUp:
@@ -140,19 +141,21 @@
     }
     medPtr->state = 0;
     GetKeys(keyMap);
-    if (keyMap[1] & 2) { 
+    modif = EndianS32_BtoN(*(long*)(&keyMap[1]));
+
+    if (modif & 2) { 
         medPtr->state |= LockMask;
     }
-    if (keyMap[1] & 1) {
+    if (modif & 1) {
         medPtr->state |= ShiftMask;
     }
-    if (keyMap[1] & 8) {
+    if (modif & 8) {
         medPtr->state |= ControlMask;
     }
-    if (keyMap[1] & 32768) {
+    if (modif & 32768) {
         medPtr->state |= Mod1Mask;              /* command key */
     }
-    if (keyMap[1] & 4) {
+    if (modif & 4) {
         medPtr->state |= Mod2Mask;              /* option key */
     }
     if (eventPtr->eKind == kEventMouseDown 
@@ -381,7 +384,7 @@
                  
                 TkMacOSXPreprocessMenu();
                 TkMacOSXHandleMenuSelect(MenuSelect(where),
-                        theKeys[1] & 4);
+                        EndianS32_BtoN(*(long*)(&theKeys[1])) & 4);
                 Tcl_SetServiceMode(oldMode);
                 return true; /* TODO: may not be on event on queue. */
             }
@@ -678,6 +681,7 @@
 {
     unsigned int state = 0;
     KeyMap theKeys;
+    long modif;
 
     if (Button() & !gEatButtonUp) {
         state |= Button1Mask;
@@ -685,23 +689,25 @@
 
     GetKeys(theKeys);
 
-    if (theKeys[1] & 2) {
+    modif = EndianS32_BtoN(*(long*)(&theKeys[1]));
+
+    if (modif & 2) {
         state |= LockMask;
     }
 
-    if (theKeys[1] & 1) {
+    if (modif & 1) {
         state |= ShiftMask;
     }
 
-    if (theKeys[1] & 8) {
+    if (modif & 8) {
         state |= ControlMask;
     }
 
-    if (theKeys[1] & 32768) {
+    if (modif & 32768) {
         state |= Mod1Mask;                /* command key */
     }
 
-    if (theKeys[1] & 4) {
+    if (modif & 4) {
         state |= Mod2Mask;                /* option key */
     }
 
Index: generic/tkMain.c
===================================================================
RCS file: /cvsroot/tktoolkit/tk/generic/tkMain.c,v
retrieving revision 1.15
diff -u -p -r1.15 tkMain.c
--- generic/tkMain.c	13 Dec 2002 16:54:35 -0000	1.15
+++ generic/tkMain.c	27 Sep 2004 08:36:46 -0000
@@ -31,6 +31,9 @@
 #ifdef __WIN32__
 #include "tkWinInt.h"
 #endif
+#ifdef MAC_OSX_TK
+#include "tkMacOSXInt.h"
+#endif
 
 
 typedef struct ThreadSpecificData {
@@ -128,6 +131,12 @@ Tk_MainEx(argc, argv, appInitProc, inter
 #if (defined(__WIN32__) || defined(MAC_TCL))
     Tk_InitConsoleChannels(interp);
 #endif
+
+#ifdef MAC_OSX_TK
+    if (TclGetStartupScriptFileName() == NULL) {
+        TkMacOSXDefaultStartupScript();
+    }
+#endif
     
 #ifdef TCL_MEM_DEBUG
     Tcl_InitMemory(interp);
Index: macosx/tkMacOSXInit.c
===================================================================
RCS file: /cvsroot/tktoolkit/tk/macosx/tkMacOSXInit.c,v
retrieving revision 1.3.2.2
diff -u -p -r1.3.2.2 tkMacOSXInit.c
--- macosx/tkMacOSXInit.c	25 Jul 2004 01:57:41 -0000	1.3.2.2
+++ macosx/tkMacOSXInit.c	27 Sep 2004 19:10:16 -0000
@@ -1,7 +1,7 @@
 /* 
- * tkUnixInit.c --
+ * tkMacOSXInit.c --
  *
- *        This file contains Unix-specific interpreter initialization
+ *        This file contains Mac OS X -specific interpreter initialization
  *        functions.
  *
  * Copyright (c) 1995-1997 Sun Microsystems, Inc.
@@ -15,6 +15,9 @@
 
 #include "tkInt.h"
 #include "tkMacOSXInt.h"
+#include "tclInt.h"
+#include <sys/stat.h>
+#include <mach-o/dyld.h>
 
 /*
  * The Init script (common to Windows and Unix platforms) is
@@ -23,6 +26,15 @@
 #include "tkInitScript.h"
 
 /*
+ * Define the following to 0 to not attempt to use an undocumented SPI
+ * to notify the window server that an unbundled executable is a full
+ * GUI application after loading Tk.
+ */
+#ifndef MAC_OSX_TK_USE_CPS_SPI
+#define MAC_OSX_TK_USE_CPS_SPI 1
+#endif
+
+/*
  * The following structures are used to map the script/language codes of a
  * font to the name that should be passed to Tcl_GetEncoding() to obtain
  * the encoding for that font.  The set of numeric constants is fixed and
@@ -72,6 +84,11 @@ static Map scriptMap[] = {
 
 Tcl_Encoding TkMacOSXCarbonEncoding = NULL;
 
+/*
+ * If the App is in an App package, then we want to add the Scripts
+ * directory to the auto_path.      
+ */
+static char scriptPath[PATH_MAX + 1] = "";
 
 /*
  *----------------------------------------------------------------------
@@ -95,30 +112,27 @@ int
 TkpInit(interp)
     Tcl_Interp *interp;
 {
-    char tkLibPath[1024];
-    int result;
-    static int menusInitialized = false;
-    static int carbonEncodingInitialized = false;
+    static char tkLibPath[PATH_MAX + 1];
+    static int tkMacOSXInitialized = false;
 
     /* 
      * Since it is possible for TkInit to be called multiple times
-     * and we don't want to do the menu initialization multiple times
+     * and we don't want to do the initialization multiple times
      * we protect against doing it more than once.
      */
 
-    if (menusInitialized == false) {
-    	menusInitialized = true;
+    if (tkMacOSXInitialized == false) {
+	CFStringEncoding encoding;
+	char *encodingStr = NULL;
+	int  i;
+
+    	tkMacOSXInitialized = true;
+
         Tk_MacOSXSetupTkNotifier();
         TkMacOSXInitAppleEvents(interp);
         TkMacOSXInitMenus(interp);
         TkMacOSXUseAntialiasedText(interp, TRUE);
         TkMacOSXInitCGDrawing(interp, TRUE, 3);
-    }
- 
-    if (carbonEncodingInitialized == false) {
-	CFStringEncoding encoding;
-	char *encodingStr = NULL;
-	int  i;
 	
 	encoding = CFStringGetSystemEncoding();
 	
@@ -136,20 +150,112 @@ TkpInit(interp)
 	if (TkMacOSXCarbonEncoding == NULL) {
 	    TkMacOSXCarbonEncoding = Tcl_GetEncoding (NULL, NULL);
 	}
-    }
+        
+        /*
+         * When Tk is in a framework, force tcl_findLibrary to look in the 
+         * framework scripts directory.
+         * FIXME: Should we come up with a more generic way of doing this?
+         */
+         
+        Tcl_MacOSXOpenVersionedBundleResources(interp, 
+                "com.tcltk.tklibrary", TK_VERSION, 1, 1024, tkLibPath);
+                 
+        /*
+         * If we don't have a TTY and stdin is a special character file of length 0,
+         * (e.g. /dev/null, which is what Finder sets when double clicking Wish)
+         * then use the Tk based console interpreter.
+         */
     
-    /*
-     * When Tk is in a framework, force tcl_findLibrary to look in the 
-     * framework scripts directory.
-     * FIXME: Should we come up with a more generic way of doing this?
-     */
-     
-    result = Tcl_MacOSXOpenVersionedBundleResources(interp, 
-    	    "com.tcltk.tklibrary", TK_VERSION, 1, 1024, tkLibPath);
-     
-    if (result != TCL_ERROR) {
+        if (!isatty(0)) {
+            struct stat st;
+            if (fstat(0, &st) || (S_ISCHR(st.st_mode) && st.st_blocks == 0)) {
+                Tk_InitConsoleChannels(interp);
+                Tcl_RegisterChannel(interp, Tcl_GetStdChannel(TCL_STDIN));
+                Tcl_RegisterChannel(interp, Tcl_GetStdChannel(TCL_STDOUT));
+                Tcl_RegisterChannel(interp, Tcl_GetStdChannel(TCL_STDERR));
+                if (Tk_CreateConsoleWindow(interp) == TCL_OK) {
+                    /* Only show the console if we don't have a startup script */
+                    if (TclGetStartupScriptPath() == NULL) {
+                        Tcl_Eval(interp, "console show");
+                    }
+                }
+            }
+        }
+#if MAC_OSX_TK_USE_CPS_SPI
+        /*
+         * If we are loaded into an executable that is not a bundled application, 
+         * the window server does not let us come to the foreground.
+         * For such an executable, we attempt to use an undocumented SPI to
+         * notify the window server that we are now a full GUI application.
+         */
+        {
+            /* Check whether we are a bundled executable: */
+            int bundledExecutable = 0;
+            CFBundleRef bundleRef = CFBundleGetMainBundle();
+            CFURLRef bundleUrl = NULL;
+            if (bundleRef) {
+                bundleUrl = CFBundleCopyBundleURL(bundleRef);
+            }
+            if (bundleUrl) {
+                /*
+                 * A bundled executable is two levels down from its main bundle
+                 * directory (e.g. Wish.app/Contents/MacOS/Wish), whereas
+                 * an unbundled executable's main bundle directory is just
+                 * the directory containing the executable.
+                 * So to check whether we are bundled, we delete the last three
+                 * path components of the executable's url and compare the
+                 * resulting url with the main bundle url.
+                 */
+                int j = 3;
+                CFURLRef url = CFBundleCopyExecutableURL(bundleRef);
+                while (url && j--) {
+                    CFURLRef parent = CFURLCreateCopyDeletingLastPathComponent(NULL, url);
+                    CFRelease(url);
+                    url = parent;
+                }
+                if (url) {
+                    bundledExecutable = CFEqual(bundleUrl, url);
+                    CFRelease(url);
+                }
+                CFRelease(bundleUrl);
+            }
+            
+            /* If we are not a bundled executable, attempt to use the CPS SPI: */
+            if (!bundledExecutable) {
+                /*
+                 * Load the CPS SPI symbol dynamically, so that we don't break
+                 * if it every disappears or changes its name.
+                 */
+                OSErr (*cpsEnableForegroundOperation)(ProcessSerialNumberPtr) = NULL;
+                NSSymbol nsSymbol;
+                if(NSIsSymbolNameDefinedWithHint(
+                        "_CPSEnableForegroundOperation", "CoreGraphics")) {
+                    nsSymbol = NSLookupAndBindSymbolWithHint(
+                        "_CPSEnableForegroundOperation", "CoreGraphics");
+                    if(nsSymbol) {
+                        cpsEnableForegroundOperation = NSAddressOfSymbol(nsSymbol);
+                    }
+                }
+                if (cpsEnableForegroundOperation) {
+                    ProcessSerialNumber psn = { 0, kCurrentProcess };
+                    /*
+                     * Let the window server know that we are a foregroundable app
+                     */
+                    cpsEnableForegroundOperation(&psn);
+                }
+            }
+        }
+#endif /* MAC_OSX_TK_USE_CPS_SPI */
+    }
+
+    if (tkLibPath[0] != '\0') {
         Tcl_SetVar(interp, "tk_library", tkLibPath, TCL_GLOBAL_ONLY);
     }
+
+    if (scriptPath[0] != '\0') {
+        Tcl_SetVar(interp, "auto_path", scriptPath,
+                TCL_GLOBAL_ONLY|TCL_LIST_ELEMENT|TCL_APPEND_VALUE);
+    }
     
     return Tcl_Eval(interp, initScript);
 }
@@ -221,3 +327,59 @@ TkpDisplayWarning(msg, title)
         Tcl_WriteChars(errChannel, "\n", 1);
     }
 }
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * TkMacOSXDefaultStartupScript --
+ *
+ *
+ *        On MacOS X, we look for a file in the Resources/Scripts
+ *        directory called AppMain.tcl and if found, we set argv[1] to
+ *        that, so that the rest of the code will find it, and add the
+ *        Scripts folder to the auto_path.  If we don't find the startup
+ *        script, we just bag it, assuming the user is starting up some
+ *        other way.
+ *       
+ * Results:
+ *        None.
+ *
+ * Side effects:
+ *        TclSetStartupScriptFileName() called when AppMain.tcl found.
+ *
+ *----------------------------------------------------------------------
+ */
+
+void
+TkMacOSXDefaultStartupScript(void)
+{
+    CFBundleRef bundleRef;
+    
+    bundleRef = CFBundleGetMainBundle();
+    
+    if (bundleRef != NULL) {
+        CFURLRef appMainURL;
+        appMainURL = CFBundleCopyResourceURL(bundleRef, 
+                CFSTR("AppMain"), 
+                CFSTR("tcl"), 
+                CFSTR("Scripts"));
+
+        if (appMainURL != NULL) {
+            CFURLRef scriptFldrURL;
+            char startupScript[PATH_MAX + 1];
+                            
+            if (CFURLGetFileSystemRepresentation (appMainURL, true,
+                    startupScript, PATH_MAX)) {
+                TclSetStartupScriptFileName(startupScript);
+                scriptFldrURL = CFURLCreateCopyDeletingLastPathComponent(
+                        NULL, appMainURL);
+                if (scriptFldrURL != NULL) {
+                    CFURLGetFileSystemRepresentation(scriptFldrURL, 
+                            true, scriptPath, PATH_MAX);
+                    CFRelease(scriptFldrURL);
+                }
+            }
+            CFRelease(appMainURL);
+        }
+    }
+}
Index: macosx/tkMacOSXInt.h
===================================================================
RCS file: /cvsroot/tktoolkit/tk/macosx/tkMacOSXInt.h,v
retrieving revision 1.3.2.1
diff -u -p -r1.3.2.1 tkMacOSXInt.h
--- macosx/tkMacOSXInt.h	25 Jul 2004 01:57:41 -0000	1.3.2.1
+++ macosx/tkMacOSXInt.h	27 Sep 2004 08:36:46 -0000
@@ -152,6 +152,7 @@ extern Tcl_Encoding TkMacOSXCarbonEncodi
 
 extern int TkMacOSXUseAntialiasedText(Tcl_Interp *interp, int enable);
 extern int TkMacOSXInitCGDrawing(Tcl_Interp *interp, int enable, int antiAlias);
+extern void TkMacOSXDefaultStartupScript(void);
 
 #include "tkIntPlatDecls.h"
 
===================================================================
--- macosx/Wish.pbproj/project.pbxproj.orig	2004-07-19 23:05:59.000000000 -0700
+++ macosx/Wish.pbproj/project.pbxproj	2005-07-07 15:32:49.000000000 -0700
@@ -134,7 +134,7 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 			shellPath = /bin/sh;
-			shellScript = "if [ \"${BUILD_STYLE}\" = \"Development\" ]; then\n\t# keep copy of debug library around, so that\n\t# Deployment build can be installed on top\n\t# of Development build without overwriting it\n\tcd \"${TARGET_BUILD_DIR}/${PRODUCT_NAME}.${WRAPPER_EXTENSION}/Versions/${FRAMEWORK_VERSION}\"\n\tcp -fp \"${PRODUCT_NAME}\" \"${PRODUCT_NAME}_debug\"\n\tln -fs \"Versions/Current/${PRODUCT_NAME}_debug\" ../..\n\tcp -fp \"libtkstub${FRAMEWORK_VERSION}.a\" \"libtkstub${FRAMEWORK_VERSION}g.a\"\n\n\t# force Deployment build to be relinked next time\n\tif [ -f \"${OBJROOT}/Deployment.build/${PROJECT_NAME}.build/${TARGET_NAME}.build/Objects-normal/LinkFileList\" ]; then\n\t    touch -t `date -r \\`expr \\\\\\`date +\"%s\"\\\\\\` + 30\\` +\"%Y%m%d%H%M.%S\"` \"${OBJROOT}/Deployment.build/${PROJECT_NAME}.build/${TARGET_NAME}.build/Objects-normal/LinkFileList\"\n\tfi\nelse\n\t# force Development build to be relinked next time\n\tif [ -f \"${OBJROOT}/Development.build/${PROJECT_NAME}.build/${TARGET_NAME}.build/Objects-normal/LinkFileList\" ]; then\n\t    touch -t `date -r \\`expr \\\\\\`date +\"%s\"\\\\\\` + 30\\` +\"%Y%m%d%H%M.%S\"` \"${OBJROOT}/Development.build/${PROJECT_NAME}.build/${TARGET_NAME}.build/Objects-normal/LinkFileList\"\n\tfi\nfi\n\n# fixup Framework structure\ncd \"${TARGET_BUILD_DIR}/${PRODUCT_NAME}.${WRAPPER_EXTENSION}/Versions/${FRAMEWORK_VERSION}\"\nln -fs `ls libtkstub* | sed -e \"s|.*|Versions/${FRAMEWORK_VERSION}/&|\"` ../..\nln -fs \"Versions/Current/tkConfig.sh\" ../..\nranlib libtkstub${FRAMEWORK_VERSION}*.a";
+			shellScript = "if [ \"${BUILD_STYLE}\" = \"Development\" ]; then\n\t# keep copy of debug library around, so that\n\t# Deployment build can be installed on top\n\t# of Development build without overwriting it\n\tcd \"${TARGET_BUILD_DIR}/${PRODUCT_NAME}.${WRAPPER_EXTENSION}/Versions/${FRAMEWORK_VERSION}\"\n\tcp -fp \"${PRODUCT_NAME}\" \"${PRODUCT_NAME}_debug\"\n\tln -fs \"Versions/Current/${PRODUCT_NAME}_debug\" ../..\n\tcp -fp \"libtkstub${FRAMEWORK_VERSION}.a\" \"libtkstub${FRAMEWORK_VERSION}g.a\"\n\n\t# force Deployment build to be relinked next time\n\tif [ -f \"${OBJROOT}/Deployment.build/${PROJECT_NAME}.build/${TARGET_NAME}.build/Objects-normal/LinkFileList\" ]; then\n\t    touch -t `date -r \\`expr \\\\\\`date +\"%s\"\\\\\\` + 30\\` +\"%Y%m%d%H%M.%S\"` \"${OBJROOT}/Deployment.build/${PROJECT_NAME}.build/${TARGET_NAME}.build/Objects-normal/LinkFileList\"\n\tfi\nelse\n\t# force Development build to be relinked next time\n\tif [ -f \"${OBJROOT}/Development.build/${PROJECT_NAME}.build/${TARGET_NAME}.build/Objects-normal/LinkFileList\" ]; then\n\t    touch -t `date -r \\`expr \\\\\\`date +\"%s\"\\\\\\` + 30\\` +\"%Y%m%d%H%M.%S\"` \"${OBJROOT}/Development.build/${PROJECT_NAME}.build/${TARGET_NAME}.build/Objects-normal/LinkFileList\"\n\tfi\nfi\n\n# fixup Framework structure\ncd \"${TARGET_BUILD_DIR}/${PRODUCT_NAME}.${WRAPPER_EXTENSION}/Versions/${FRAMEWORK_VERSION}\"\nln -fs `ls libtkstub* | sed -e \"s|.*|Versions/${FRAMEWORK_VERSION}/&|\"` ../..\nln -fs \"Versions/Current/tkConfig.sh\" ../..\nranlib libtkstub${FRAMEWORK_VERSION}*.a\n\n# create pkgIndex\n( echo \"if {[package vcompare [package provide Tcl] ${FRAMEWORK_VERSION}] != 0} { return }\" && \\\n  echo \"package ifneeded Tk ${FRAMEWORK_VERSION} [list load [file join \\$dir .. .. Tk] Tk]\" \\\n) > \"Resources/Scripts/pkgIndex.tcl\"";
 		};
 		F537552A016C352C01DC9062 = {
 			buildStyles = (
@@ -432,7 +432,6 @@
 		};
 		F5375546016C376E01DC9062 = {
 			children = (
-				F5375548016C376E01DC9062,
 				F5375549016C376E01DC9062,
 				F537554A016C376E01DC9062,
 				F537554B016C376E01DC9062,
@@ -470,8 +469,9 @@
 		F5375548016C376E01DC9062 = {
 			fileEncoding = 5;
 			isa = PBXFileReference;
-			path = tkMacOSXAppInit.c;
-			refType = 4;
+			name = tkAppInit.c;
+			path = ../unix/tkAppInit.c;
+			refType = 2;
 		};
 		F5375549016C376E01DC9062 = {
 			fileEncoding = 5;
@@ -1321,6 +1321,7 @@
 		};
 		F53755C9016C389901DC9062 = {
 			children = (
+				F5375548016C376E01DC9062,
 				F53755CA016C389901DC9062,
 				F53755CB016C389901DC9062,
 			);
@@ -1566,11 +1567,11 @@
 	<key>CFBundlePackageType</key>
 	<string>FMWK</string>
 	<key>CFBundleShortVersionString</key>
-	<string>8.4.7</string>
+	<string>8.4.7 b</string>
 	<key>CFBundleSignature</key>
 	<string>WiSH</string>
 	<key>CFBundleVersion</key>
-	<string>8.4.7</string>
+	<string>8.4.7 b</string>
 </dict>
 </plist>
 ";
@@ -2897,7 +2898,7 @@
 				LIBRARY_SEARCH_PATHS = "";
 				OPTIMIZATION_CFLAGS = "-O0";
 				OTHER_CFLAGS = "-DMAC_OSX_TK -DTCL_WIDE_INT_TYPE=\"long long\"";
-				OTHER_LDFLAGS = "-sectcreate __TEXT __info_plist \"$TEMP_DIR/Info.plist\" -headerpad_max_install_names";
+				OTHER_LDFLAGS = "-sectcreate __TEXT __info_plist \"${OBJROOT}/Deployment.build/$(PROJECT_NAME).build/$(TARGET_NAME).build/Info.plist\" -headerpad_max_install_names";
 				OTHER_REZFLAGS = "-i \"$(TCL_FRAMEWORK_DIR)/Tcl.framework/Headers\" -i \"../generic\"";
 				PRODUCT_NAME = "Wish Shell";
 				SECTORDER_FLAGS = "";
@@ -2941,7 +2942,7 @@
 	<key>CFBundleExecutable</key>
 	<string>Wish Shell</string>
 	<key>CFBundleGetInfoString</key>
-	<string>Wish Shell 8.4, Copyright © 2003 Tcl Core Team.
+	<string>Wish Shell 8.4, Copyright © 2004 Tcl Core Team.
 MacOS X Port by Jim Ingham &lt;jingham@apple.com&gt; &amp; Ian Reid, Copyright © 2001-2002, Apple Computer, Inc.</string>
 	<key>CFBundleIconFile</key>
 	<string>Wish.icns</string>
@@ -2954,11 +2955,11 @@
 	<key>CFBundlePackageType</key>
 	<string>APPL</string>
 	<key>CFBundleShortVersionString</key>
-	<string>8.4.7</string>
+	<string>8.4.7 b</string>
 	<key>CFBundleSignature</key>
 	<string>WiSH</string>
 	<key>CFBundleVersion</key>
-	<string>8.4.7</string>
+	<string>8.4.7 b</string>
 </dict>
 </plist>
 ";
@@ -2967,8 +2968,6 @@
 			buildActionMask = 2147483647;
 			files = (
 				F53756AC016C4E1D01DC9062,
-				F53756AD016C4E1D01DC9062,
-				F53756AE016C4E1D01DC9062,
 			);
 			isa = PBXHeadersBuildPhase;
 			runOnlyForDeploymentPostprocessing = 0;
@@ -3039,18 +3038,6 @@
 			settings = {
 			};
 		};
-		F53756AD016C4E1D01DC9062 = {
-			fileRef = F5375570016C37A601DC9062;
-			isa = PBXBuildFile;
-			settings = {
-			};
-		};
-		F53756AE016C4E1D01DC9062 = {
-			fileRef = F537553E016C376E01DC9062;
-			isa = PBXBuildFile;
-			settings = {
-			};
-		};
 		F53756B2016C525F01DC9062 = {
 			isa = PBXTargetDependency;
 			target = F53755DF016C38D201DC9062;
Index: macosx/tkMacOSXAppInit.c
===================================================================
RCS file: macosx/tkMacOSXAppInit.c
diff -N macosx/tkMacOSXAppInit.c
--- macosx/tkMacOSXAppInit.c	16 Feb 2004 00:42:34 -0000	1.4.2.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,243 +0,0 @@
-/* 
- * tkAppInit.c --
- *
- *        Provides a default version of the Tcl_AppInit procedure for
- *        use in wish and similar Tk-based applications.
- *
- * Copyright (c) 1993 The Regents of the University of California.
- * Copyright (c) 1994-1997 Sun Microsystems, Inc.
- * Copyright 2001, Apple Computer, Inc.
- *
- * See the file "license.terms" for information on usage and redistribution
- * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
- *
- * RCS: @(#) $Id: tkMacOSXAppInit.c,v 1.4.2.1 2004/02/16 00:42:34 wolfsuit Exp $
- */
-#include <pthread.h>
-#include <sys/stat.h>
-#include "tk.h"
-#include "tclInt.h"
-#include "locale.h"
-
-#include <Carbon/Carbon.h>
-#include "tkPort.h"
-#include "tkMacOSX.h"
-#include "tkMacOSXEvent.h"
-
-/*
- * If the App is in an App package, then we want to add the Scripts
- * directory to the auto_path.  But we have to wait till after the
- * Tcl_Init is run, or it gets blown away.  This stores what we
- * figured out in main.
- */
- 
-char scriptPath[PATH_MAX + 1];
-
-extern Tcl_Interp *gStdoutInterp;
-
-#ifdef TK_TEST
-extern int                Tktest_Init _ANSI_ARGS_((Tcl_Interp *interp));
-#endif /* TK_TEST */
-
-/*
- *----------------------------------------------------------------------
- *
- * main --
- *
- *        This is the main program for the application.
- *
- * Results:
- *        None: Tk_Main never returns here, so this procedure never
- *        returns either.
- *
- * Side effects:
- *        Whatever the application does.
- *
- *----------------------------------------------------------------------
- */
-
-int
-main(argc, argv)
-    int argc;                        /* Number of command-line arguments. */
-    char **argv;                /* Values of command-line arguments. */
-{
-    int textEncoding; /* 
-                       * Variable used to take care of
-                       * lazy font initialization
-                       */
-    CFBundleRef bundleRef;
-
-    /*
-     * The following #if block allows you to change the AppInit
-     * function by using a #define of TCL_LOCAL_APPINIT instead
-     * of rewriting this entire file.  The #if checks for that
-     * #define and uses Tcl_AppInit if it doesn't exist.
-     */
-    
-#ifndef TK_LOCAL_APPINIT
-#define TK_LOCAL_APPINIT Tcl_AppInit    
-#endif
-    extern int TK_LOCAL_APPINIT _ANSI_ARGS_((Tcl_Interp *interp));
-
-    scriptPath[0] = '\0';
-
-    /*
-     * The following #if block allows you to change how Tcl finds the startup
-     * script, prime the library or encoding paths, fiddle with the argv,
-     * etc., without needing to rewrite Tk_Main().  Note, if you use this
-     * hook, then I won't do the CFBundle lookup, since if you are messing
-     * around at this level, you probably don't want me to do this for you...
-     */
-    
-#ifdef TK_LOCAL_MAIN_HOOK
-    extern int TK_LOCAL_MAIN_HOOK _ANSI_ARGS_((int *argc, char ***argv));
-    TK_LOCAL_MAIN_HOOK(&argc, &argv);
-#else
-
-    /*
-     * On MacOS X, we look for a file in the Resources/Scripts directory
-     * called AppMain.tcl and if found, we set argv[1] to that, so that
-     * the rest of the code will find it, and add the Scripts folder to
-     * the auto_path.  If we don't find the startup script, we just bag
-     * it, assuming the user is starting up some other way.
-     */
-    
-    bundleRef = CFBundleGetMainBundle();
-    
-    if (bundleRef != NULL) {
-        CFURLRef appMainURL;
-        appMainURL = CFBundleCopyResourceURL(bundleRef, 
-                CFSTR("AppMain"), 
-                CFSTR("tcl"), 
-                CFSTR("Scripts"));
-
-        if (appMainURL != NULL) {
-            CFURLRef scriptFldrURL;
-            char *startupScript = malloc(PATH_MAX + 1);
-                            
-            if (CFURLGetFileSystemRepresentation (appMainURL, true,
-                    startupScript, PATH_MAX)) {
-                TclSetStartupScriptFileName(startupScript);
-                scriptFldrURL = CFBundleCopyResourceURL(bundleRef,
-                        CFSTR("Scripts"),
-                        NULL,
-                        NULL);
-                CFURLGetFileSystemRepresentation(scriptFldrURL, 
-                        true, scriptPath, PATH_MAX);
-                CFRelease(scriptFldrURL);
-            } else {
-                free(startupScript);
-            }
-            CFRelease(appMainURL);
-        }
-    }
-
-#endif
-    textEncoding = GetApplicationTextEncoding();
-    
-    /*
-     * Now add the scripts folder to the auto_path.
-     */
-     
-    Tk_Main(argc,argv,TK_LOCAL_APPINIT);
-    return 0;                        /* Needed only to prevent compiler warning. */
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * Tcl_AppInit --
- *
- *        This procedure performs application-specific initialization.
- *        Most applications, especially those that incorporate additional
- *        packages, will have their own version of this procedure.
- *
- * Results:
- *        Returns a standard Tcl completion code, and leaves an error
- *        message in the interp's result if an error occurs.
- *
- * Side effects:
- *        Depends on the startup script.
- *
- *----------------------------------------------------------------------
- */
-
-int
-Tcl_AppInit(interp)
-    Tcl_Interp *interp;                /* Interpreter for application. */
-{        
-    if (Tcl_Init(interp) == TCL_ERROR) {
-        return TCL_ERROR;
-    }    
-    if (Tk_Init(interp) == TCL_ERROR) {
-        return TCL_ERROR;
-    }
-    Tcl_StaticPackage(interp, "Tk", Tk_Init, Tk_SafeInit);
-
-    if (scriptPath[0] != '\0') {
-        Tcl_SetVar(interp, "auto_path", scriptPath,
-                TCL_GLOBAL_ONLY|TCL_LIST_ELEMENT|TCL_APPEND_VALUE);
-    }
-    
-#ifdef TK_TEST
-    if (Tktest_Init(interp) == TCL_ERROR) {
-        return TCL_ERROR;
-    }
-    Tcl_StaticPackage(interp, "Tktest", Tktest_Init,
-            (Tcl_PackageInitProc *) NULL);
-#endif /* TK_TEST */
-
-    /*
-     * If we don't have a TTY and stdin is a special character file of length 0,
-     * (e.g. /dev/null, which is what Finder sets when double clicking Wish)
-     * then use the Tk based console interpreter.
-     */
-
-    if (!isatty(0)) {
-	struct stat st;
-	if (fstat(0, &st) || (S_ISCHR(st.st_mode) && st.st_blocks == 0)) {
-            Tk_InitConsoleChannels(interp);
-            Tcl_RegisterChannel(interp, Tcl_GetStdChannel(TCL_STDIN));
-            Tcl_RegisterChannel(interp, Tcl_GetStdChannel(TCL_STDOUT));
-            Tcl_RegisterChannel(interp, Tcl_GetStdChannel(TCL_STDERR));
-	    if (Tk_CreateConsoleWindow(interp) == TCL_ERROR) {
-		goto error;
-	    }
-	    /* Only show the console if we don't have a startup script */
-	    if (TclGetStartupScriptPath() == NULL) {
-		Tcl_Eval(interp, "console show");
-	    }
-	}
-    }
-    
-    /*
-     * Call the init procedures for included packages.  Each call should
-     * look like this:
-     *
-     * if (Mod_Init(interp) == TCL_ERROR) {
-     *     return TCL_ERROR;
-     * }
-     *
-     * where "Mod" is the name of the module.
-     */
-
-    /*
-     * Call Tcl_CreateCommand for application-specific commands, if
-     * they weren't already created by the init procedures called above.
-     */
-
-    
-    /*
-     * Specify a user-specific startup file to invoke if the application
-     * is run interactively.  Typically the startup file is "~/.apprc"
-     * where "app" is the name of the application.  If this line is deleted
-     * then no user-specific startup file will be run under any conditions.
-     */
-     
-    Tcl_SetVar(interp, "tcl_rcFileName", "~/.wishrc", TCL_GLOBAL_ONLY);
-
-    return TCL_OK;
-
-    error:
-    return TCL_ERROR;
-}
--- macosx/tkMacOSXDraw.c.orig	2005-11-09 14:44:33.000000000 -0800
+++ macosx/tkMacOSXDraw.c	2005-11-09 14:48:55.000000000 -0800
@@ -464,7 +464,11 @@
         pixmap.pixelSize = 32;
         pixmap.cmpCount = 3;
         pixmap.cmpSize = 8;
+#ifdef __BIG_ENDIAN__
         pixmap.pixelFormat = k32ARGBPixelFormat;
+#else /* !__BIG_ENDIAN__ */
+        pixmap.pixelFormat = k32BGRAPixelFormat;
+#endif /* !__BIG_ENDIAN__ */
         pixmap.pmTable = NULL;
         pixmap.pmExt = 0;
         pixmap.baseAddr = image->data;
--- unix/Makefile.in.orig	2006-04-14 16:14:51.000000000 -0700
+++ unix/Makefile.in	2006-04-14 16:17:09.000000000 -0700
@@ -688,7 +688,8 @@
 	    rm -f tkAppInit.sav; \
 	    mv tkAppInit.o tkAppInit.sav; \
 	fi;
-	$(CC) -c $(CC_SWITCHES_NO_STUBS) -DTK_TEST $(UNIX_DIR)/tkAppInit.c
+	$(CC) -c $(CC_SWITCHES_NO_STUBS) -DTK_TEST -mdynamic-no-pic \
+	    $(UNIX_DIR)/tkAppInit.c
 	rm -f tkTestInit.o
 	mv tkAppInit.o tkTestInit.o
 	@if test -f tkAppInit.sav ; then \
@@ -696,7 +697,8 @@
 	fi;
 
 tkAppInit.o: $(UNIX_DIR)/tkAppInit.c
-	$(CC) -c $(CC_SWITCHES_NO_STUBS) $(UNIX_DIR)/tkAppInit.c
+	$(CC) -c $(CC_SWITCHES_NO_STUBS) -mdynamic-no-pic \
+	    $(UNIX_DIR)/tkAppInit.c
 
 tk3d.o: $(GENERIC_DIR)/tk3d.c
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tk3d.c
--- doc/FindPhoto.3~	Thu May  4 13:27:21 2006
+++ doc/FindPhoto.3	Thu May  4 13:27:21 2006
@@ -19,7 +19,6 @@
 .SH SYNOPSIS
 .nf
 \fB#include <tk.h>\fR
-\fB#include <tkPhoto.h>\fR
 .sp
 Tk_PhotoHandle
 .VS 8.0 br
--- generic/tkTextTag.c.orig	2006-05-31 15:54:01.000000000 -0700
+++ generic/tkTextTag.c	2006-05-31 15:58:18.000000000 -0700
@@ -1267,7 +1267,7 @@
     TkTextTag **copyArrayPtr = NULL;	/* Initialization needed to prevent
 					 * compiler warning. */
 
-    int numOldTags, numNewTags, i, j, size;
+    int numOldTags, numNewTags, i, j, size, nearby;
     XEvent event;
 
     /*
@@ -1336,9 +1336,14 @@
 
     if (textPtr->pickEvent.type != LeaveNotify) {
 	TkTextPixelIndex(textPtr, textPtr->pickEvent.xcrossing.x,
-		textPtr->pickEvent.xcrossing.y, &index);
-	newArrayPtr = TkBTreeGetTags(&index, &numNewTags);
-	SortTags(numNewTags, newArrayPtr);
+			 textPtr->pickEvent.xcrossing.y, &index, &nearby);
+	if (nearby) {
+	    newArrayPtr = NULL;
+	    numNewTags = 0;
+	} else {
+	    newArrayPtr = TkBTreeGetTags(&index, &numNewTags);
+	    SortTags(numNewTags, newArrayPtr);
+	}
     } else {
 	newArrayPtr = NULL;
 	numNewTags = 0;
@@ -1408,10 +1413,11 @@
      */
 
     TkTextPixelIndex(textPtr, textPtr->pickEvent.xcrossing.x,
-	    textPtr->pickEvent.xcrossing.y, &index);
+		     textPtr->pickEvent.xcrossing.y, &index, &nearby);
     TkTextSetMark(textPtr, "current", &index);
     if (numNewTags != 0) {
-	if ((textPtr->bindingTable != NULL) && (textPtr->tkwin != NULL)) {
+	if ((textPtr->bindingTable != NULL) && (textPtr->tkwin != NULL)
+	  && !nearby) {
 	    event = textPtr->pickEvent;
 	    event.type = EnterNotify;
 	    event.xcrossing.detail = NotifyAncestor;
--- generic/tkTextDisp.c.orig	2006-05-31 15:58:52.000000000 -0700
+++ generic/tkTextDisp.c	2006-05-31 16:04:31.000000000 -0700
@@ -4119,16 +4119,22 @@
  */
 
 void
-TkTextPixelIndex(textPtr, x, y, indexPtr)
+TkTextPixelIndex(textPtr, x, y, indexPtr, nearest)
     TkText *textPtr;		/* Widget record for text widget. */
     int x, y;			/* Pixel coordinates of point in widget's
 				 * window. */
     TkTextIndex *indexPtr;	/* This index gets filled in with the
 				 * index of the character nearest to (x,y). */
+    int *nearest;               /* If non-NULL then gets set to 0 if
+				 * (x,y) is actually over the returned
+				 * index, and 1 if it is just nearby
+				 * (e.g. if x,y is on the border of the
+				 * widget). */
 {
     TextDInfo *dInfoPtr = textPtr->dInfoPtr;
     register DLine *dlPtr, *validdlPtr;
     register TkTextDispChunk *chunkPtr;
+    int nearby = 0;
 
     /*
      * Make sure that all of the layout information about what's
@@ -4148,14 +4154,19 @@
     if (y < dInfoPtr->y) {
 	y = dInfoPtr->y;
 	x = dInfoPtr->x;
+	nearby = 1;
     }
     if (x >= dInfoPtr->maxX) {
 	x = dInfoPtr->maxX - 1;
+	nearby = 1;
     }
     if (x < dInfoPtr->x) {
 	x = dInfoPtr->x;
+	nearby = 1;
     }
 
+    if (nearest != NULL) *nearest = nearby;
+
     /*
      * Find the display line containing the desired y-coordinate.
      */
@@ -4170,6 +4181,7 @@
 	     */
 
 	    x = dInfoPtr->maxX - 1;
+	    nearby = 1;
 	    break;
 	}
     }
--- generic/tkTextBTree.c.orig	2006-05-31 16:04:56.000000000 -0700
+++ generic/tkTextBTree.c	2006-05-31 16:07:25.000000000 -0700
@@ -2347,6 +2347,12 @@
     TagInfo tagInfo;
 #define NUM_TAG_INFOS 10
 
+    if (numTagsPtr == NULL) return NULL;
+    if (indexPtr == NULL) {
+      *numTagsPtr = 0;
+      return NULL;
+    }
+
     tagInfo.numTags = 0;
     tagInfo.arraySize = NUM_TAG_INFOS;
     tagInfo.tagPtrs = (TkTextTag **) ckalloc((unsigned)
--- generic/tkText.h.orig	2006-05-31 16:18:46.000000000 -0700
+++ generic/tkText.h	2006-05-31 16:19:54.000000000 -0700
@@ -881,7 +881,7 @@
 EXTERN void		TkTextPickCurrent _ANSI_ARGS_((TkText *textPtr,
 			    XEvent *eventPtr));
 EXTERN void		TkTextPixelIndex _ANSI_ARGS_((TkText *textPtr,
-			    int x, int y, TkTextIndex *indexPtr));
+			    int x, int y, TkTextIndex *indexPtr, int *nearest));
 EXTERN void		TkTextPrintIndex _ANSI_ARGS_((
 			    CONST TkTextIndex *indexPtr, char *string));
 EXTERN void		TkTextRedrawRegion _ANSI_ARGS_((TkText *textPtr,
--- generic/tkTextIndex.c.orig	2006-05-31 16:38:27.000000000 -0700
+++ generic/tkTextIndex.c	2006-05-31 16:38:55.000000000 -0700
@@ -415,7 +415,7 @@
 	if (end == cp) {
 	    goto error;
 	}
-	TkTextPixelIndex(textPtr, x, y, indexPtr);
+	TkTextPixelIndex(textPtr, x, y, indexPtr, NULL);
 	endOfBase = end;
 	goto gotBase; 
     }
--- macosx/tkMacOSXNotify.c.orig	2004-02-15 16:42:34.000000000 -0800
+++ macosx/tkMacOSXNotify.c	2007-02-22 19:16:37.000000000 -0800
@@ -405,7 +405,19 @@
     ThreadSpecificData *tsdPtr = (ThreadSpecificData *) clientData;
     Tcl_MutexLock(&notifierMutex);
     tsdPtr->eventReady = 1;
-    Tcl_ConditionNotify(&tsdPtr->waitCV);
+    if (tsdPtr->isMainLoop) {
+	OSErr err;
+	
+	/* We need to wake up the main loop, and let it have the event. */
+	EventRef fakeEvent = TkMacOSXCreateFakeEvent();
+	EventQueueRef mainEventQueue = GetMainEventQueue();
+	
+	err = PostEventToQueue(mainEventQueue, fakeEvent,
+			       kEventPriorityHigh);
+	ReleaseEvent(fakeEvent);
+    } else {
+	Tcl_ConditionNotify(&tsdPtr->waitCV);
+    }
     Tcl_MutexUnlock(&notifierMutex);
 #endif
 }
