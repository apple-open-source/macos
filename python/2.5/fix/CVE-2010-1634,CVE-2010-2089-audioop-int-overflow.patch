--- Modules/audioop.c.0	2010-06-17 16:05:24.000000000 -0700
+++ Modules/audioop.c	2010-06-17 16:22:18.000000000 -0700
@@ -295,6 +295,29 @@ static int stepsizeTable[89] = {
 
 static PyObject *AudioopError;
 
+static int
+audioop_check_size(int size)
+{
+        if ( size != 1 && size != 2 && size != 4 ) {
+                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
+                return 0;
+        } else {
+                return 1;
+        }
+}
+
+static int
+audioop_check_parameters(int len, int size)
+{
+        if (!audioop_check_size(size))
+                return 0;
+        if ( len % size != 0 ) {
+                PyErr_SetString(AudioopError, "not a whole number of frames");
+                return 0;
+        }
+        return 1;
+}
+
 static PyObject *
 audioop_getsample(PyObject *self, PyObject *args)
 {
@@ -304,10 +327,8 @@ audioop_getsample(PyObject *self, PyObje
 
         if ( !PyArg_ParseTuple(args, "s#ii:getsample", &cp, &len, &size, &i) )
                 return 0;
-        if ( size != 1 && size != 2 && size != 4 ) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
         if ( i < 0 || i >= len/size ) {
                 PyErr_SetString(AudioopError, "Index out of range");
                 return 0;
@@ -328,10 +349,8 @@ audioop_max(PyObject *self, PyObject *ar
 
         if ( !PyArg_ParseTuple(args, "s#i:max", &cp, &len, &size) )
                 return 0;
-        if ( size != 1 && size != 2 && size != 4 ) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
         for ( i=0; i<len; i+= size) {
                 if ( size == 1 )      val = (int)*CHARP(cp, i);
                 else if ( size == 2 ) val = (int)*SHORTP(cp, i);
@@ -352,10 +371,8 @@ audioop_minmax(PyObject *self, PyObject 
 
         if (!PyArg_ParseTuple(args, "s#i:minmax", &cp, &len, &size))
                 return NULL;
-        if (size != 1 && size != 2 && size != 4) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
+        if (!audioop_check_parameters(len, size))
                 return NULL;
-        }
         for (i = 0; i < len; i += size) {
                 if (size == 1) val = (int) *CHARP(cp, i);
                 else if (size == 2) val = (int) *SHORTP(cp, i);
@@ -376,10 +393,8 @@ audioop_avg(PyObject *self, PyObject *ar
 
         if ( !PyArg_ParseTuple(args, "s#i:avg", &cp, &len, &size) )
                 return 0;
-        if ( size != 1 && size != 2 && size != 4 ) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
         for ( i=0; i<len; i+= size) {
                 if ( size == 1 )      val = (int)*CHARP(cp, i);
                 else if ( size == 2 ) val = (int)*SHORTP(cp, i);
@@ -403,10 +418,8 @@ audioop_rms(PyObject *self, PyObject *ar
 
         if ( !PyArg_ParseTuple(args, "s#i:rms", &cp, &len, &size) )
                 return 0;
-        if ( size != 1 && size != 2 && size != 4 ) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
         for ( i=0; i<len; i+= size) {
                 if ( size == 1 )      val = (int)*CHARP(cp, i);
                 else if ( size == 2 ) val = (int)*SHORTP(cp, i);
@@ -609,10 +622,8 @@ audioop_avgpp(PyObject *self, PyObject *
 
         if ( !PyArg_ParseTuple(args, "s#i:avgpp", &cp, &len, &size) )
                 return 0;
-        if ( size != 1 && size != 2 && size != 4 ) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
         /* Compute first delta value ahead. Also automatically makes us
         ** skip the first extreme value
         */
@@ -666,10 +677,8 @@ audioop_maxpp(PyObject *self, PyObject *
 
         if ( !PyArg_ParseTuple(args, "s#i:maxpp", &cp, &len, &size) )
                 return 0;
-        if ( size != 1 && size != 2 && size != 4 ) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
         /* Compute first delta value ahead. Also automatically makes us
         ** skip the first extreme value
         */
@@ -717,10 +726,8 @@ audioop_cross(PyObject *self, PyObject *
 
         if ( !PyArg_ParseTuple(args, "s#i:cross", &cp, &len, &size) )
                 return 0;
-        if ( size != 1 && size != 2 && size != 4 ) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
         ncross = -1;
         prevval = 17; /* Anything <> 0,1 */
         for ( i=0; i<len; i+= size) {
@@ -745,6 +752,8 @@ audioop_mul(PyObject *self, PyObject *ar
 
         if ( !PyArg_ParseTuple(args, "s#id:mul", &cp, &len, &size, &factor ) )
                 return 0;
+        if (!audioop_check_parameters(len, size))
+                return NULL;
     
         if ( size == 1 ) maxval = (double) 0x7f;
         else if ( size == 2 ) maxval = (double) 0x7fff;
@@ -787,6 +796,12 @@ audioop_tomono(PyObject *self, PyObject 
         if ( !PyArg_ParseTuple(args, "s#idd:tomono",
 	                       &cp, &len, &size, &fac1, &fac2 ) )
                 return 0;
+        if (!audioop_check_parameters(len, size))
+                return NULL;
+        if ( ((len / size) & 1) != 0 ) {
+                PyErr_SetString(AudioopError, "not a whole number of frames");
+                return NULL;
+        }
     
         if ( size == 1 ) maxval = (double) 0x7f;
         else if ( size == 2 ) maxval = (double) 0x7fff;
@@ -824,7 +839,7 @@ static PyObject *
 audioop_tostereo(PyObject *self, PyObject *args)
 {
         signed char *cp, *ncp;
-        int len, new_len, size, val1, val2, val = 0;
+        int len, size, val1, val2, val = 0;
         double fac1, fac2, fval, maxval;
         PyObject *rv;
         int i;
@@ -832,6 +847,8 @@ audioop_tostereo(PyObject *self, PyObjec
         if ( !PyArg_ParseTuple(args, "s#idd:tostereo",
 	                       &cp, &len, &size, &fac1, &fac2 ) )
                 return 0;
+        if (!audioop_check_parameters(len, size))
+                return NULL;
     
         if ( size == 1 ) maxval = (double) 0x7f;
         else if ( size == 2 ) maxval = (double) 0x7fff;
@@ -841,14 +858,13 @@ audioop_tostereo(PyObject *self, PyObjec
                 return 0;
         }
     
-        new_len = len*2;
-        if (new_len < 0) {
+        if (len > INT_MAX/2) {
                 PyErr_SetString(PyExc_MemoryError,
                                 "not enough memory for output buffer");
                 return 0;
         }
 
-        rv = PyString_FromStringAndSize(NULL, new_len);
+        rv = PyString_FromStringAndSize(NULL, len*2);
         if ( rv == 0 )
                 return 0;
         ncp = (signed char *)PyString_AsString(rv);
@@ -891,7 +907,8 @@ audioop_add(PyObject *self, PyObject *ar
         if ( !PyArg_ParseTuple(args, "s#s#i:add",
                           &cp1, &len1, &cp2, &len2, &size ) )
                 return 0;
-
+        if (!audioop_check_parameters(len1, size))
+                return NULL;
         if ( len1 != len2 ) {
                 PyErr_SetString(AudioopError, "Lengths should be the same");
                 return 0;
@@ -945,11 +962,8 @@ audioop_bias(PyObject *self, PyObject *a
         if ( !PyArg_ParseTuple(args, "s#ii:bias",
                           &cp, &len, &size , &bias) )
                 return 0;
-
-        if ( size != 1 && size != 2 && size != 4) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
     
         rv = PyString_FromStringAndSize(NULL, len);
         if ( rv == 0 )
@@ -981,12 +995,9 @@ audioop_reverse(PyObject *self, PyObject
         if ( !PyArg_ParseTuple(args, "s#i:reverse",
                           &cp, &len, &size) )
                 return 0;
+        if (!audioop_check_parameters(len, size))
+                return NULL;
 
-        if ( size != 1 && size != 2 && size != 4 ) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
-    
         rv = PyString_FromStringAndSize(NULL, len);
         if ( rv == 0 )
                 return 0;
@@ -1011,27 +1022,24 @@ audioop_lin2lin(PyObject *self, PyObject
 {
         signed char *cp;
         unsigned char *ncp;
-        int len, new_len, size, size2, val = 0;
+        int len, size, size2, val = 0;
         PyObject *rv;
         int i, j;
 
         if ( !PyArg_ParseTuple(args, "s#ii:lin2lin",
                           &cp, &len, &size, &size2) )
                 return 0;
-
-        if ( (size != 1 && size != 2 && size != 4) ||
-             (size2 != 1 && size2 != 2 && size2 != 4)) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
+        if (!audioop_check_size(size2))
+                return NULL;
     
-        new_len = (len/size)*size2;
-        if (new_len < 0) {
+        if (len/size > INT_MAX/size2) {
                 PyErr_SetString(PyExc_MemoryError,
                                 "not enough memory for output buffer");
                 return 0;
         }
-        rv = PyString_FromStringAndSize(NULL, new_len);
+        rv = PyString_FromStringAndSize(NULL, (len/size)*size2);
         if ( rv == 0 )
                 return 0;
         ncp = (unsigned char *)PyString_AsString(rv);
@@ -1067,7 +1075,6 @@ audioop_ratecv(PyObject *self, PyObject 
         int chan, d, *prev_i, *cur_i, cur_o;
         PyObject *state, *samps, *str, *rv = NULL;
         int bytes_per_frame;
-        size_t alloc_size;
 
         weightA = 1;
         weightB = 0;
@@ -1075,10 +1082,8 @@ audioop_ratecv(PyObject *self, PyObject 
 	                      &nchannels, &inrate, &outrate, &state,
 			      &weightA, &weightB))
                 return NULL;
-        if (size != 1 && size != 2 && size != 4) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
+        if (!audioop_check_size(size))
                 return NULL;
-        }
         if (nchannels < 1) {
                 PyErr_SetString(AudioopError, "# of channels should be >= 1");
                 return NULL;
@@ -1110,14 +1115,13 @@ audioop_ratecv(PyObject *self, PyObject 
         inrate /= d;
         outrate /= d;
 
-        alloc_size = sizeof(int) * (unsigned)nchannels;
-        if (alloc_size < nchannels) {
+        if (nchannels > PY_SIZE_MAX/sizeof(int)) {
                 PyErr_SetString(PyExc_MemoryError,
                                 "not enough memory for output buffer");
                 return 0;
         }
-        prev_i = (int *) malloc(alloc_size);
-        cur_i = (int *) malloc(alloc_size);
+        prev_i = (int *) malloc(nchannels * sizeof(int));
+        cur_i = (int *) malloc(nchannels * sizeof(int));
         if (prev_i == NULL || cur_i == NULL) {
                 (void) PyErr_NoMemory();
                 goto exit;
@@ -1154,25 +1158,16 @@ audioop_ratecv(PyObject *self, PyObject 
                    ceiling(len*outrate/inrate) output frames, and each frame
                    requires bytes_per_frame bytes.  Computing this
                    without spurious overflow is the challenge; we can
-                   settle for a reasonable upper bound, though. */
-                int ceiling;   /* the number of output frames */
-                int nbytes;    /* the number of output bytes needed */
-                int q = len / inrate;
-                /* Now len = q * inrate + r exactly (with r = len % inrate),
-                   and this is less than q * inrate + inrate = (q+1)*inrate.
-                   So a reasonable upper bound on len*outrate/inrate is
-                   ((q+1)*inrate)*outrate/inrate =
-                   (q+1)*outrate.
-                */
-                ceiling = (q+1) * outrate;
-                nbytes = ceiling * bytes_per_frame;
-                /* See whether anything overflowed; if not, get the space. */
-                if (q+1 < 0 ||
-                    ceiling / outrate != q+1 ||
-                    nbytes / bytes_per_frame != ceiling)
+                   settle for a reasonable upper bound, though, in this
+                   case ceiling(len/inrate) * outrate. */
+
+                /* compute ceiling(len/inrate) without overflow */
+                int q = len > 0 ? 1 + (len - 1) / inrate : 0;
+                if (outrate > INT_MAX / q / bytes_per_frame)
                         str = NULL;
                 else
-                        str = PyString_FromStringAndSize(NULL, nbytes);
+                        str = PyString_FromStringAndSize(NULL,
+                                             q * outrate * bytes_per_frame);
 
                 if (str == NULL) {
                         PyErr_SetString(PyExc_MemoryError,
@@ -1264,11 +1259,8 @@ audioop_lin2ulaw(PyObject *self, PyObjec
         if ( !PyArg_ParseTuple(args, "s#i:lin2ulaw",
                                &cp, &len, &size) )
                 return 0 ;
-
-        if ( size != 1 && size != 2 && size != 4) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
     
         rv = PyString_FromStringAndSize(NULL, len/size);
         if ( rv == 0 )
@@ -1291,31 +1283,27 @@ audioop_ulaw2lin(PyObject *self, PyObjec
         unsigned char *cp;
         unsigned char cval;
         signed char *ncp;
-        int len, new_len, size, val;
+        int len, size, val;
         PyObject *rv;
         int i;
 
         if ( !PyArg_ParseTuple(args, "s#i:ulaw2lin",
                                &cp, &len, &size) )
                 return 0;
-
-        if ( size != 1 && size != 2 && size != 4) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_size(size))
+                return NULL;
     
-        new_len = len*size;
-        if (new_len < 0) {
+        if (len > INT_MAX/size) {
                 PyErr_SetString(PyExc_MemoryError,
                                 "not enough memory for output buffer");
                 return 0;
         }
-        rv = PyString_FromStringAndSize(NULL, new_len);
+        rv = PyString_FromStringAndSize(NULL, len*size);
         if ( rv == 0 )
                 return 0;
         ncp = (signed char *)PyString_AsString(rv);
     
-        for ( i=0; i < new_len; i += size ) {
+        for ( i=0; i < len*size; i += size ) {
                 cval = *cp++;
                 val = st_ulaw2linear16(cval);
         
@@ -1338,11 +1326,8 @@ audioop_lin2alaw(PyObject *self, PyObjec
         if ( !PyArg_ParseTuple(args, "s#i:lin2alaw",
                                &cp, &len, &size) )
                 return 0;
-
-        if ( size != 1 && size != 2 && size != 4) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
     
         rv = PyString_FromStringAndSize(NULL, len/size);
         if ( rv == 0 )
@@ -1365,31 +1350,27 @@ audioop_alaw2lin(PyObject *self, PyObjec
         unsigned char *cp;
         unsigned char cval;
         signed char *ncp;
-        int len, new_len, size, val;
+        int len, size, val;
         PyObject *rv;
         int i;
 
         if ( !PyArg_ParseTuple(args, "s#i:alaw2lin",
                                &cp, &len, &size) )
                 return 0;
-
-        if ( size != 1 && size != 2 && size != 4) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_size(size))
+                return NULL;
     
-        new_len = len*size;
-        if (new_len < 0) {
+        if (len > INT_MAX/size) {
                 PyErr_SetString(PyExc_MemoryError,
                                 "not enough memory for output buffer");
                 return 0;
         }
-        rv = PyString_FromStringAndSize(NULL, new_len);
+        rv = PyString_FromStringAndSize(NULL, len*size);
         if ( rv == 0 )
                 return 0;
         ncp = (signed char *)PyString_AsString(rv);
     
-        for ( i=0; i < new_len; i += size ) {
+        for ( i=0; i < len*size; i += size ) {
                 cval = *cp++;
                 val = st_alaw2linear16(cval);
         
@@ -1413,12 +1394,8 @@ audioop_lin2adpcm(PyObject *self, PyObje
         if ( !PyArg_ParseTuple(args, "s#iO:lin2adpcm",
                                &cp, &len, &size, &state) )
                 return 0;
-    
-
-        if ( size != 1 && size != 2 && size != 4) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_parameters(len, size))
+                return NULL;
     
         str = PyString_FromStringAndSize(NULL, len/(size*2));
         if ( str == 0 )
@@ -1514,18 +1491,15 @@ audioop_adpcm2lin(PyObject *self, PyObje
 {
         signed char *cp;
         signed char *ncp;
-        int len, new_len, size, valpred, step, delta, index, sign, vpdiff;
+        int len, size, valpred, step, delta, index, sign, vpdiff;
         PyObject *rv, *str, *state;
         int i, inputbuffer = 0, bufferstep;
 
         if ( !PyArg_ParseTuple(args, "s#iO:adpcm2lin",
                                &cp, &len, &size, &state) )
                 return 0;
-
-        if ( size != 1 && size != 2 && size != 4) {
-                PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");
-                return 0;
-        }
+        if (!audioop_check_size(size))
+                return NULL;
     
         /* Decode state, should have (value, step) */
         if ( state == Py_None ) {
@@ -1536,13 +1510,12 @@ audioop_adpcm2lin(PyObject *self, PyObje
         } else if ( !PyArg_ParseTuple(state, "ii", &valpred, &index) )
                 return 0;
     
-        new_len = len*size*2;
-        if (new_len < 0) {
+        if (len > (INT_MAX/size)/2) {
                 PyErr_SetString(PyExc_MemoryError,
                                 "not enough memory for output buffer");
                 return 0;
         }
-        str = PyString_FromStringAndSize(NULL, new_len);
+        str = PyString_FromStringAndSize(NULL, len*size*2);
         if ( str == 0 )
                 return 0;
         ncp = (signed char *)PyString_AsString(str);
@@ -1550,7 +1523,7 @@ audioop_adpcm2lin(PyObject *self, PyObje
         step = stepsizeTable[index];
         bufferstep = 0;
     
-        for ( i=0; i < new_len; i += size ) {
+        for ( i=0; i < len*size*2; i += size ) {
                 /* Step 1 - get the delta value and compute next index */
                 if ( bufferstep ) {
                         delta = inputbuffer & 0xf;
