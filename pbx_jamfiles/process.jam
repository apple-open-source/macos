# Copyright (c) 1999-2003 Apple Computer, Inc.
# All rights reserved.

# Variables referenced:
# BUILD_DIR		Location of built product
# RESOURCE_DIR 		Directory for resource files in product
# *_LINK, *_LINK_PATH	Wrapper versioning information
# *_HEADER_DIR		Directories for headers of product
# _INFO_PLIST_FILE_PATH	Path to Info.plist file (if any), generated by PBXCore
# _PKGINFO_FILE_PATH	Path to PkgInfo file (if any), generated by PBXCore
# _VERSION_PLIST_FILE_PATH     Path to version.plist file (if any), generated by PBXCore
# _PBDEVELOPMENT_PLIST_FILE_PATH       Path to pbdevelopment.plist file (if any), generated by PBXCore
# VERSIONING_SYSTEM	Versioning system to use for product
# JAVA_COMPILE_TARGET	Nonfile target representing all java compiles
# REZ_EXECUTABLE	Run Rez directly on executable to produce fork if YES
# PRESERVE_RESOURCES	Files to be recopied with CpMac after install tar copy
# APPLESCRIPTS_DIR	Directory for compiled AppleScripts
#
# Variables set:
# DERIVED_FILES		Intermediate sources
# OBJECT_FILES		Object files produced by compilations
# LINKED_FILES		Files to be used by a link rule
# PRODUCT_FILES		Files that belong in the built product
# INFO_PLIST_FILE	Info.plist file in product wrapper, copied from PRODUCT_SETTINGS_PATH
# PKGINFO_FILE		PkgInfo file in product wrapper, copied from _PKGINFO_FILE_PATH
# HDRRULE, HDRSCAN	Target specific header scanning information
# FLAGS			Target specific compilation flags
# HEADER_SEARCH_PATHS, FRAMEWORK_SEARCH_PATHS	Target specific search paths
#
# Build phase variables:
# BUILD_PHASE		Target for current build phase
# PREVIOUS_BUILD_PHASE	Target for previous build phase
# BUILD_PHASE_PRODUCTS	Products of current build phase
# PHASE_TARGETS		List of all phase targets for conflict checks

# Source and resource handling rules by extension
.h_RULE		= ProcessHeader ;
.nib_RULE	= ProcessResource ;
.rtf_RULE	= ProcessResource ;
.exe_RULE	= ProcessResource ;
.java_RULE	= ProcessUsingJavaCompiler ;
.applescript_RULE	= ProcessAppleScript ;
.c_RULE		= ProcessC ;
.adb_RULE	= ProcessC ; # unsupported
.ads_RULE	= ProcessC ; # unsupported
.C_RULE		= ProcessCplusplus ;
.cc_RULE	= ProcessCplusplus ;
.cp_RULE	= ProcessCplusplus ;
.cpp_RULE	= ProcessCplusplus ;
.CPP_RULE       = ProcessCplusplus ;
.cxx_RULE	= ProcessCplusplus ;
.CXX_RULE	= ProcessCplusplus ;
# !!!:cmolick:20020226 note: .C++ not accepted by c++ compiler driver
.c++_RULE	= ProcessCplusplus ;
.m_RULE		= ProcessC ;
.mm_RULE	= ProcessCplusplus ;
.M_RULE		= ProcessCplusplus ;
.s_RULE		= ProcessAssembly ;
.f_RULE		= ProcessFortran ;
.for_RULE	= ProcessFortran ;
.f77_RULE	= ProcessFortran ;
.f90_RULE	= ProcessFortran ;
.F_RULE		= ProcessFortran ;
.fpp_RULE	= ProcessFortran ;
.exp_RULE	= ProcessExportsFile ;
.defs_RULE	= ProcessUsingMig ;
.mig_RULE	= ProcessUsingMig ;
.l_RULE		= ProcessUsingLex ;
.lm_RULE	= ProcessUsingLex ;
.LM_RULE	= ProcessUsingLex ;
.lmm_RULE	= ProcessUsingLex ;
.lpp_RULE	= ProcessUsingLex ;
.LPP_RULE	= ProcessUsingLex ;
.lxx_RULE	= ProcessUsingLex ;
.LXX_RULE	= ProcessUsingLex ;
.y_RULE		= ProcessUsingYacc ;
.ym_RULE	= ProcessUsingYacc ;
.YM_RULE	= ProcessUsingYacc ;
.ymm_RULE	= ProcessUsingYacc ;
.ypp_RULE	= ProcessUsingYacc ;
.YPP_RULE	= ProcessUsingYacc ;
.yxx_RULE	= ProcessUsingYacc ;
.YXX_RULE	= ProcessUsingYacc ;
.x_RULE		= ProcessUsingRPCGen ;
.jobs_RULE      = ProcessUsingBridget ;
.framework_RULE = ProcessFrameworkOrLibrary ;
.r_RULE		= ProcessRezFile ;
.rsrc_RULE	= ProcessRezFile ;
.RSRC_RULE	= ProcessRezFile ;
.ppob_RULE	= ProcessRezFile ;

# Set the initial list of phase targets to empty
PHASE_TARGETS = ;

# PhaseTarget <phase target variable> <product> <phase name>
# Sets up the given phase target variable based on the target
# and phase name and uses the list of phase targets to attempt
# avoid collisions between targets for phases with the same name.
rule PhaseTarget
{
    local PHASE_SUFFIXES = 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 ;
    local PHASE_TARGET = $(2:G=$(3)) ;
    if $(PHASE_TARGET) in $(PHASE_TARGETS) {
        # attempt differentiation by adding last nonmatching suffix
        for PHASE_SUFFIX in $(PHASE_SUFFIXES) {
            ALTERNATE_PHASE_TARGET = $(2:G=$(3)$(PHASE_SUFFIX)) ;
            if ! $(ALTERNATE_PHASE_TARGET) in $(PHASE_TARGETS) {
                PHASE_TARGET = $(ALTERNATE_PHASE_TARGET) ;
            }
        }
    }
    PHASE_TARGETS += $(PHASE_TARGET) ;
    $(1) = $(PHASE_TARGET) ;
    NOTFILE $(PHASE_TARGET) ;
}

# BuildPhase <phase> <product> <previous phase>
# Set up product (and variant hack) dependence on phase
# and phase dependence on previous phase
# and defines an action to indicate phase completion
rule BuildPhase
{
    # retain a list of all phases
    _BUILD_PHASES += $(1) ;
    # retain name for action echo
    PHASE_NAME on $(1) = $(1:G) ;
    # this build phase depends on the previous phase
    if $(3) {
        DEPENDS $(1) : $(3) ;
    }
    # phase required for parent target
    DEPENDS $(2) : $(1) ;
}
actions BuildPhase
{
    $(ECHO) Completed phase $(PHASE_NAME:Q) for $(1:Q)
}

# DerivedFiles <derived-files>
# Locates derived files in the derived file directory,
# sees the derived paths with the derived file directory if necessary,
# creates derived subpaths and ads them to derived paths as necessary,
# and makes the derived file depend on all derived paths.
rule DerivedFiles
{
    local _DERIVED_FILE ;
    for _DERIVED_FILE in $(1) {
        # !!!:cmolick:20021110 not all these files should be added to DERIVED_FILES
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(_DERIVED_FILE) ;
        }
        # make and depend on containing directory
        LOCATE on $(_DERIVED_FILE) = $(DERIVED_FILE_DIR) ;
        if ! $(DERIVED_PATHS) {
            DERIVED_PATHS = $(DERIVED_FILE_DIR) ;
        }
        local DIR = $(DERIVED_FILE_DIR)$(/)$(_DERIVED_FILE:D) ;
        if ! ( $(DIR) in $(DERIVED_PATHS) ) && ! ( $(DIR)/ in $(DERIVED_PATHS) ) {
            Mkdir $(DIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(DIR) ;
            }
            DERIVED_PATHS += $(DIR) ;
        }
        DEPENDS $(_DERIVED_FILE) : $(DERIVED_PATHS) ;
    }
}

# ProductFile <product-file>
# The product file location is set to BUILD_DIR.
# If the reference and containing directory are not already
# in the list of product files, then they are added.  They also
# become build phase products unless phasing is turned off.
rule ProductFile
{
    LOCATE on $(1) = $(TARGET_BUILD_DIR) ;
    if ! $(1) in $(PRODUCT_FILES) {
        PRODUCT_FILES += $(1) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(1) ;
        }
    }
}

# ProductFileAside <file>
# Same as ProductFile, but default location is ASIDE_DIR.
rule ProductFileAside
{
    LOCATE on $(1) = $(ASIDE_DIR) ;
    if ! $(1) in $(PRODUCT_FILES) {
        PRODUCT_FILES += $(1) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(1) ;
        }
    }
}

# SetModeOwnerAndGroup <nonfile gristed target> : <base target>
# Uses given nonfile gristed target to set mode, owner, and group
# of the base product
rule SetModeOwnerAndGroup
{
    NOTFILE $(1) ;
    LOCATE on $(1) = $(TARGET_BUILD_DIR) ;
    POST_PHASE_PRODUCTS += $(1) ;
    if $(INSTALL_MODE_FLAG) {
        SetMode $(1) : $(2) ;
    }
    if $(INSTALL_OWNER) {
        if $(INSTALL_GROUP) {
            SetOwnerAndGroup $(1) : $(2) ;
        }
        else {
            SetOwner $(1) : $(2) ;
        }
    }
    else if $(INSTALL_GROUP) {
        SetGroup $(1) : $(2) ;
    }
}
actions SetMode
{
     $(CHMOD) -RH $(INSTALL_MODE_FLAG) $(2:G=:Q)
}
actions SetOwner
{
    $(CHOWN) -RH $(INSTALL_OWNER) $(2:G=:Q)
}
actions SetGroup
{
    $(CHOWN) -RH :$(INSTALL_GROUP) $(2:G=:Q)
}
actions SetOwnerAndGroup
{
    $(CHOWN) -RH $(INSTALL_OWNER):$(INSTALL_GROUP) $(2:G=:Q)
}

rule NoOp
{
    if $(_BUILD_PHASING) = YES {
        PhaseTarget BUILD_PHASE : $(1) : NoOp ;
        BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
        PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
    }
}

# ProcessHeaders <product> <headers>
#
# Process individual headers, call Interfacer to generate headers,
# precompile and assemble implicitly included headers as necessary,
# and run headerdoc.
rule ProcessHeaders
{
    if ( headers in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : CopyHeaders ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
#            PREVIOUS_BUILD_PHASE_PRODUCTS = $(BUILD_PHASE_PRODUCTS) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        for FILE in $(2) {
            if $(_BUILD_PHASING) = YES {
                ProcessHeader $(BUILD_PHASE) : $(FILE) ;
            }
            else {
                ProcessHeader $(1) : $(FILE) ;
            }
        }
        
        # conditionally gather documentation generated from headers
        if build in $(BUILD_COMPONENTS) && $(GATHERHEADERDOC) && $(GENERATE_HEADERDOC) = YES && $(HEADERDOC_DIR) && HEADERDOC_TARGETS {
            GATHERED_HEADERDOC_TARGET = masterTOC.html ;
            LOCATE on $(GATHERED_HEADERDOC_TARGET) = $(HEADERDOC_DIR) ;
            DEPENDS $(GATHERED_HEADERDOC_TARGET) : $(HEADERDOC_DIR) ;
            DEPENDS $(GATHERED_HEADERDOC_TARGET) : $(HEADERDOC_TARGETS) ;
            GatheredHeaderDoc $(GATHERED_HEADERDOC_TARGET) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(GATHERED_HEADERDOC_TARGET) ;
            }
        }
    }
    # generate interfacer derived headers
    if headers in $(BUILD_COMPONENTS) && $(GENERATE_HEADERS) = YES {
        InterfacerHeaders $(1) ;
    }
    # Prepare to use prefix file, possibly starting with precompiling
    # Prefix file preparation and precompling is done only when the build action is "build", but not "installhdrs"
    if ( build in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        # The prefix file may be compiled for use with cpp-precomp, PFE, or PCH mechanisms
        if ( $(PREFIX_HEADER) != ""  &&  $(PRECOMPILE_PREFIX_HEADER) = YES ) {
            PFE_FILE_C_DIALECTS default = "c" "objective-c" "c++" "objective-c++" ;
            PRECOMP_DESTINATION_DIR default = $(TEMP_DIR)$(/)PrefixHeaders ;
            Mkdir $(PRECOMP_DESTINATION_DIR) ;
            PRODUCT_FILES += $(PRECOMP_DESTINATION_DIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(PRECOMP_DESTINATION_DIR) ;
            }
            if ( $(GCC_VERSION) = 2.x ) || ( $(GCC_VERSION) = 3.1 && $(USE_GCC3_PFE_SUPPORT) != YES ) {
                # compile prefix file with cpp-precomp
                # create header stub in subfolder of TEMP_DIR
                local PREFIX_HEADER_STUB = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER:BS) ;
                DEPENDS $(PREFIX_HEADER_STUB) : $(PRECOMP_DESTINATION_DIR) ;
                AbsolutePathImportStub $(PREFIX_HEADER_STUB) : $(PREFIX_HEADER) ;
                INCLUDES $(PREFIX_HEADER_STUB) : $(PREFIX_HEADER) ;
                # recompile for C and C++
                if ( "c" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c" in $(PFE_FILE_C_DIALECTS) ) {
                    C_PRECOMP_FILE_DESTINATION_PATH = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER_STUB:BS="-gcc3.p") ;
                    PrecompileHeader $(C_PRECOMP_FILE_DESTINATION_PATH) : $(PREFIX_HEADER_STUB) ;
                    PRODUCT_FILES += $(C_PRECOMP_FILE_DESTINATION_PATH) ;
                    if $(_BUILD_PHASING) = YES {
                        BUILD_PHASE_PRODUCTS += $(C_PRECOMP_FILE_DESTINATION_PATH) ;
                    }
                }
                if ( "c++" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c++" in $(PFE_FILE_C_DIALECTS) ) {
                    CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER_STUB:BS="-gcc3.pp") ;
                    PrecompileHeader $(CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH) : $(PREFIX_HEADER_STUB) ;
                    PRODUCT_FILES += $(CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH) ;
                    if $(_BUILD_PHASING) = YES {
                        BUILD_PHASE_PRODUCTS += $(CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH) ;
                    }
                }
                # effective prefix header is now header stub
                EFFECTIVE_PREFIX_HEADER = $(PREFIX_HEADER_STUB) ;
                # prepare precompile option using -include
                # set default flags for precompiled prefix header usage
            }
            else {
                if $(GCC_VERSION) = 3.1 && $(USE_GCC3_PFE_SUPPORT) = YES {
                    # prefix file precompiled with PFE support
                    # precompile by dialect
                    for ARCH in $(ARCHS) {
                        EFFECTIVE_PFE_FILE_$(ARCH) = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER:BS="-$(ARCH).pfe") ;
                        if ( "c" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c" in $(PFE_FILE_C_DIALECTS) ) {
                            MakePFEFile $(EFFECTIVE_PFE_FILE_$(ARCH)) : $(PREFIX_HEADER) ;
                        }
                        if ( "c++" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c++" in $(PFE_FILE_C_DIALECTS) ) {
                            MakePFEFile++ $(EFFECTIVE_PFE_FILE_$(ARCH)) : $(PREFIX_HEADER) ;
                        }
                        PRODUCT_FILES += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                        if $(_BUILD_PHASING) = YES {
                            BUILD_PHASE_PRODUCTS += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                        }
                    }
                    # effective prefix header is empty because no -include flag is passed
                    EFFECTIVE_PREFIX_HEADER = ;
                    # use flag for picking up PFE
                    PREFIX_HEADER_CFLAGS_BASE default = --load-pch ;
                }
                if $(GCC_VERSION) = 3.3 || $(GCC_VERSION) = 3.5 || $(GCC_VERSION) = 4.0 {
                    # prefix file precompiled with PCH support
                    # precompile by dialect
                    for ARCH in $(ARCHS) {
                        EFFECTIVE_PFE_FILE_$(ARCH) = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER:BS="-$(ARCH)").gch ;
                        if ( "c" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c" in $(PFE_FILE_C_DIALECTS) ) {
                            ProcessPCH $(EFFECTIVE_PFE_FILE_$(ARCH)) : $(PREFIX_HEADER) ;
                        }
                        if ( "c++" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c++" in $(PFE_FILE_C_DIALECTS) ) {
                            ProcessPCH++ $(EFFECTIVE_PFE_FILE_$(ARCH)) : $(PREFIX_HEADER) ;
                        }
                        PRODUCT_FILES += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                        if $(_BUILD_PHASING) = YES {
                            BUILD_PHASE_PRODUCTS += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                        }
                    }
                    # effective prefix header is empty because no -include flag is passed
                    EFFECTIVE_PREFIX_HEADER = ;
                    # use inclusion flag for PCH
                    PREFIX_HEADER_CFLAGS_BASE default = -include ;
                }
            }
        }
        else {
            # In this case there may be a prefix header, but no precompile
            EFFECTIVE_PREFIX_HEADER = $(PREFIX_HEADER) ;
        }
    }
    # phase end logic
    # THIS *MUST* COME *AFTER* ALL OTHER WORK FOR THIS PHASE!!!
    # cmolick:20020213 ideally this should be within action conditionals,
    #  but that is difficult now that there are three disjointed ones,
    #  so checking to see if the build phase is defined is a hack
    #  the problem of bad DEPENDS here on clean for now.
    if $(_BUILD_PHASING) = YES && $(BUILD_PHASE) {
        if $(BUILD_PHASE_PRODUCTS) {
            DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
        }
        PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
    }
}

# ProcessHeader <product or phase> <header>
#
# Generate headerdoc from header as necessary,
# and copy header to subfolders of product as appropriate.
rule ProcessHeader
{
    if source in $(BUILD_COMPONENTS) {
        local HEADER_SOURCE_COPY ;
        local HEADER_SOURCE_DIR ;
        # make directory first if necessary
        if $(2:D) {
            HEADER_SOURCE_DIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(HEADER_SOURCE_DIR) ;
            HEADER_SOURCE_COPY = $(HEADER_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(HEADER_SOURCE_COPY) : $(HEADER_SOURCE_DIR) ;
        }
        else {
            HEADER_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(HEADER_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        Cp $(HEADER_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(HEADER_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        # Scan this header to see if it includes other headers.
        if $(ENABLE_HEADER_DEPENDENCIES) != NO && $(DO_HEADER_SCANNING_IN_JAM) = YES {
            HDRRULE on $(2) = ProcessC.HdrRule ;
            HDRSCAN on $(2) = $(HDRPATTERN) ;
        }
        # Set search path for header so dependence analysis will find it
        SEARCH on $(2:D=) += $(2:D) ;

        # conditionally generate documentation from headers
        if $(GENERATE_HEADERDOC) = YES && $(HEADERDOC_DIR) {
            HEADERDOC_TARGET = $(2:B)$(/)toc.html ;
            LOCATE on $(HEADERDOC_TARGET) = $(HEADERDOC_DIR) ;
            HeaderDoc $(HEADERDOC_TARGET) : $(2) ;
            DEPENDS $(HEADERDOC_TARGET) : $(HEADERDOC_DIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(HEADERDOC_TARGET) ;
            }
            HEADERDOC_TARGETS += $(HEADERDOC_TARGET) ;
        }
    }
    local ATTRIBUTES = $($(2)_ATTRIBUTES) ;
    local HEADER_ATTRIBUTE ;
    for HEADER_ATTRIBUTE in $(ATTRIBUTES) {
        switch $(HEADER_ATTRIBUTE) {
            case Project :
                # Define option as valid, but take no action
            case Public :
                HAS_PUBLIC_HEADERS = YES ;
                # Create a public header directory
                if ! $(PUBLIC_HEADER_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(PUBLIC_HEADER_DIR) ;
                    ProductFile $(PUBLIC_HEADER_DIR) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PUBLIC_HEADER_DIR default = $(PUBLIC_HEADER_DIR:G=aside) ;
                        Mkdir $(ASIDE_PUBLIC_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PUBLIC_HEADER_DIR) ;
                    }
                }
                # Create symlink to public header dir in versioned frameworks
                if $(PUBLIC_HEADER_LINK)
                  && ! $(PUBLIC_HEADER_LINK) in $(PRODUCT_FILES) {
                    SymLink $(PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
                    DEPENDS $(PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_DIR) ;
                    ProductFile $(PUBLIC_HEADER_LINK) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PUBLIC_HEADER_LINK default = $(PUBLIC_HEADER_LINK:G=aside) ;
                        SymLink $(ASIDE_PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
                        DEPENDS $(ASIDE_PUBLIC_HEADER_LINK) : $(ASIDE_PUBLIC_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PUBLIC_HEADER_LINK) ;
                    }
                    NOUPDATE $(PUBLIC_HEADER_LINK) ;
                }
                if headers in $(BUILD_COMPONENTS) {
                    if $(PUBLIC_HEADER_DIR) {
                        local HEADER_COPY = $(PUBLIC_HEADER_DIR)$(/)$(2:BS:G=) ;
                        DEPENDS $(HEADER_COPY) : $(2) ;
                        DEPENDS $(HEADER_COPY) : $(PUBLIC_HEADER_DIR) ;
                        PBXCp $(HEADER_COPY) : $(2) ;
                        ProductFile $(HEADER_COPY) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_HEADER_COPY = $(HEADER_COPY:G=aside) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(2) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(ASIDE_PUBLIC_HEADER_DIR) ;
                            PBXCp $(ASIDE_HEADER_COPY) : $(2) ;
                            ProductFileAside $(ASIDE_HEADER_COPY) ;
                        }
                    }
                    else {
                        ECHO warning: public header $(2) ignored because PUBLIC_HEADER_DIR has no value ;
                    }
                }
            case Private :
                HAS_PRIVATE_HEADERS = YES ;
                # create a private header directory
                if ! $(PRIVATE_HEADER_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(PRIVATE_HEADER_DIR) ;
                    ProductFile $(PRIVATE_HEADER_DIR) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PRIVATE_HEADER_DIR default = $(PRIVATE_HEADER_DIR:G=aside) ;
                        Mkdir $(ASIDE_PRIVATE_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PRIVATE_HEADER_DIR) ;
                    }
                }
                # accompanying link in versioned frameworks
                if $(PRIVATE_HEADER_LINK)
                  && ! $(PRIVATE_HEADER_LINK) in $(PRODUCT_FILES) {
                    SymLink $(PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
                    DEPENDS $(PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_DIR) ;
                    ProductFile $(PRIVATE_HEADER_LINK) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PRIVATE_HEADER_LINK default = $(PRIVATE_HEADER_LINK:G=aside) ;
                        SymLink $(ASIDE_PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
                        DEPENDS $(ASIDE_PRIVATE_HEADER_LINK) : $(ASIDE_PRIVATE_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PRIVATE_HEADER_LINK) ;
                    }
                    NOUPDATE $(PRIVATE_HEADER_LINK) ;
                }
                if headers in $(BUILD_COMPONENTS) {
                    if $(PRIVATE_HEADER_DIR) {
                        local HEADER_COPY = $(PRIVATE_HEADER_DIR)$(/)$(2:BS:G=) ;
                        DEPENDS $(HEADER_COPY) : $(2) ;
                        DEPENDS $(HEADER_COPY) : $(PRIVATE_HEADER_DIR) ;
                        PBXCp $(HEADER_COPY) : $(2) ;
                        ProductFile $(HEADER_COPY) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_HEADER_COPY = $(HEADER_COPY:G=aside) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(ASIDE_PRIVATE_HEADER_DIR) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(2) ;
                            PBXCp $(ASIDE_HEADER_COPY) : $(2) ;
                            ProductFileAside $(ASIDE_HEADER_COPY) ;
                        }
                    }
                    else {
                        ECHO warning: private header $(2) ignored because PRIVATE_HEADER_DIR has no value ;
                    }
                }
            case * :
                if $(HEADER_ATTRIBUTE) != AbsolutePath {
                    ECHO jam: warning: Ignoring unknown header attribute $(HEADER_ATTRIBUTE) ;
                }
        }
    }
}

rule PrecompileHeader
{
    DEPENDS $(1) : $(2) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_FRAMEWORK)/PrivateHeaders $(KERNEL_HEADERS) ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(GCC_VERSION) != 4.0 && $(OS) in MACOS DARWIN {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    # Pass headermap and/or header symlinks directory.
    if $(CPP_HEADERMAP_FILE) {
        if $(GCC_VERSION) <= 3.3 {
            CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
        }
        else if $(GCC_VERSION) >= 4.0 {
            CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
        }
        else {
            ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
        }
    }
    if $(1:S) = .pp {
            FLAGS on $(1) += -x objective-c++ ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(PRECOMP_DESTINATION_DIR)$(/)$(1:DB)-$(ARCH).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions PrecompileHeader
{
    $(CC) -precomp -o $(1:Q) $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(ARCH_FLAGS) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CFLAGS)" "$(OTHER_CFLAGS)" $(2:Q)
}

rule MakePFEFile
{
    DEPENDS $(1) : $(2) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_FRAMEWORK)/PrivateHeaders $(KERNEL_HEADERS) ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass headermap and/or header symlinks directory.
    if $(CPP_HEADERMAP_FILE) {
        if $(GCC_VERSION) <= 3.3 {
            CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
        }
        else if $(GCC_VERSION) >= 4.0 {
            CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
        }
        else {
            ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
        }
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    ARCH on $(1) = $(ARCH) ;
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions MakePFEFile
{
    for _c_dialect in $(PFE_FILE_C_DIALECTS) ; do if [ ${_c_dialect} == c -o ${_c_dialect} == objective-c ] ; then dummy_file=`mktemp /tmp/.null-XXXXXXXX`; $(CC) -c -x ${_c_dialect} $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CFLAGS)" "$(OTHER_CFLAGS)" $(2:Q) -o ${dummy_file} --dump-pch $(1:Q) ; exit_code=$? ; rm ${dummy_file} ; if [ ${exit_code} != 0 ] ; then rm -rf $(1:Q) ; exit ${exit_code} ; fi ; fi ; done
}

rule MakePFEFile++
{
    DEPENDS $(1) : $(2) ;
    PER_ARCH_CPLUSPLUSFLAGS_$(ARCH) default = $(PER_ARCH_CFLAGS_$(ARCH)) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_FRAMEWORK)/PrivateHeaders $(KERNEL_HEADERS) ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        KERNEL_COMPILE_OPTIONS += -fapple-kext ;
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass headermap and/or header symlinks directory.
    if $(CPP_HEADERMAP_FILE) {
        if $(GCC_VERSION) <= 3.3 {
            CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
        }
        else if $(GCC_VERSION) >= 4.0 {
            CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
        }
        else {
            ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
        }
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    ARCH on $(1) = $(ARCH) ;
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions MakePFEFile++
{
    for _c_dialect in $(PFE_FILE_C_DIALECTS) ; do if [ ${_c_dialect} == c++ -o ${_c_dialect} == objective-c++ ] ; then dummy_file=`mktemp /tmp/.null-XXXXXXXX`; $(CC) -c -x ${_c_dialect} $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CPLUSPLUSFLAGS)" "$(OTHER_CPLUSPLUSFLAGS)" $(2:Q) -o ${dummy_file} --dump-pch $(1:Q) ; exit_code=$? ; rm ${dummy_file} ; if [ ${exit_code} != 0 ] ; then rm -rf $(1:Q) ; exit ${exit_code} ; fi ; fi ; done
}

rule ProcessPCH
{
    DEPENDS $(1) : $(2) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_FRAMEWORK)/PrivateHeaders $(KERNEL_HEADERS) ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    OBJC_PCH_GC_FLAGS on $(1) = "" ;
    if ( "objective-c" in $(PFE_FILE_C_DIALECTS) ) {
        # DO NOT USE THE FOLLOWING BUILD SETTINGS!
        if $(GCC_FAST_OBJC_DISPATCH) = YES {
            OBJC_PCH_GC_FLAGS on $(1) += -fobjc-direct-dispatch ;
        }
        if $(GCC_ENABLE_OBJC_GC) = YES {
            OBJC_PCH_GC_FLAGS on $(1) += -fobjc-gc ;
        }
    }
    # Pass headermap and/or header symlinks directory.
    if $(CPP_HEADERMAP_FILE) {
        if $(GCC_VERSION) <= 3.3 {
            CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
        }
        else if $(GCC_VERSION) >= 4.0 {
            CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
        }
        else {
            ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
        }
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    ARCH on $(1) = $(ARCH) ;
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions ProcessPCH
{
    mkdir -p $(1:Q)
    for _c_dialect in $(PFE_FILE_C_DIALECTS) ; do if [ ${_c_dialect} == c -o ${_c_dialect} == objective-c ] ; then rm -f $(1:Q)$(/)${_c_dialect} ; $(CC) -c -x ${_c_dialect}-header $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) `if [ ${_c_dialect} == objective-c ] ; then echo "$(OBJC_PCH_GC_FLAGS)" ; fi` $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CFLAGS)" "$(OTHER_CFLAGS)" $(2:Q) -o $(1:Q)$(/)${_c_dialect} ; exit_code=$? ; if [ ${exit_code} != 0 ] ; then rm -rf $(1:Q)$(/)${_c_dialect} ; touch $(1:Q) ; exit ${exit_code} ; fi ; fi ; done
}
 
rule ProcessPCH++
{
    DEPENDS $(1) : $(2) ;
    PER_ARCH_CPLUSPLUSFLAGS_$(ARCH) default = $(PER_ARCH_CFLAGS_$(ARCH)) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_FRAMEWORK)/PrivateHeaders $(KERNEL_HEADERS) ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        KERNEL_COMPILE_OPTIONS += -fapple-kext ;
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    OBJCPLUSPLUS_PCH_GC_FLAGS on $(1) = "" ;
    if ( "objective-c++" in $(PFE_FILE_C_DIALECTS) ) {
        # DO NOT USE THE FOLLOWING BUILD SETTINGS!
        if $(GCC_FAST_OBJC_DISPATCH) = YES {
            OBJCPLUSPLUS_PCH_GC_FLAGS on $(1) += -fobjc-direct-dispatch ;
        }
        if $(GCC_ENABLE_OBJC_GC) = YES {
            OBJCPLUSPLUS_PCH_GC_FLAGS on $(1) += -fobjc-gc ;
        }
    }
    # Pass headermap and/or header symlinks directory.
    if $(CPP_HEADERMAP_FILE) {
        if $(GCC_VERSION) <= 3.3 {
            CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
        }
        else if $(GCC_VERSION) >= 4.0 {
            CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
        }
        else {
            ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
        }
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    ARCH on $(1) = $(ARCH) ;
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions ProcessPCH++
{
    mkdir -p $(1:Q)
    for _c_dialect in $(PFE_FILE_C_DIALECTS) ; do if [ ${_c_dialect} == c++ -o ${_c_dialect} == objective-c++ ] ; then rm -f $(1:Q)$(/)${_c_dialect} ; $(CC) -c -x ${_c_dialect}-header $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) `if [ ${_c_dialect} == objective-c++ ] ; then echo "$(OBJCPLUSPLUS_PCH_GC_FLAGS)" ; fi` $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_PRECOMP_CFLAGS)" "$(OTHER_CPLUSPLUSFLAGS)" $(2:Q) -o $(1:Q)$(/)${_c_dialect} ; exit_code=$? ; if [ ${exit_code} != 0 ] ; then rm -f $(1:Q)$(/)${_c_dialect} ; touch $(1:Q) ; exit ${exit_code} ; fi ; fi ; done
}


# ProcessResources <product> <bundle resources>
#
# Process individual resource files, copy property list settings file,
# and write the package info file if appropriate.
rule ProcessResources
{
    if ( build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : CopyResources ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        for FILE in $(2) {
            if $(_BUILD_PHASING) = YES {
                ProcessResource $(BUILD_PHASE) : $(FILE) ;
            }
            else {
                ProcessResource $(1) : $(FILE) ;
            }
        }
        # product settings, version settings, and package info written only during build
        if build in $(BUILD_COMPONENTS) {
            # product settings property list
            if $(_INFO_PLIST_FILE_PATH)
             && $(PURE_JAVA) != YES {
                # if available and not pure java
                if $(PRODUCT_TYPE) = Framework {
                    INFO_PLIST_FILE default = $(RESOURCE_DIR)$(/)Info.plist ;
                    if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(RESOURCE_DIR) ;
                        ProductFile $(RESOURCE_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                            Mkdir $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAside $(ASIDE_RESOURCE_DIR) ;
                        }
                    }
                    DEPENDS $(INFO_PLIST_FILE) : $(RESOURCE_DIR) ;
                    if $(RESOURCE_LINK)
                     && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
                        SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                        ProductFile $(RESOURCE_LINK) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                            SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                            ProductFileAside $(ASIDE_RESOURCE_LINK) ;
                        }
                    }
                    DEPENDS $(INFO_PLIST_FILE) : $(RESOURCE_LINK) ;
                }
                else {
                    if $(BUNDLE_STYLE) = SHALLOW {
                        INFO_PLIST_FILE default = $(1:G=)$(/)Info.plist ;
                    }
                    else {
                        INFO_PLIST_FILE default = $(1:G=)$(/)Contents$(/)Info.plist ;
                    }
                    INFO_PLIST_DIR = $(INFO_PLIST_FILE:D) ;
                    if ! $(INFO_PLIST_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(INFO_PLIST_DIR) ;
                        ProductFile $(INFO_PLIST_DIR) ;
                    }
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_INFO_PLIST_DIR default = $(INFO_PLIST_DIR:G=aside) ;
                        if ! $(ASIDE_INFO_PLIST_DIR) in $(PRODUCT_FILES) {
                            Mkdir $(ASIDE_INFO_PLIST_DIR) ;
                            ProductFileAside $(ASIDE_INFO_PLIST_DIR) ;
                        }
                    }
                    DEPENDS $(INFO_PLIST_FILE) : $(INFO_PLIST_DIR) ;
                }
                PBXCp $(INFO_PLIST_FILE) : $(_INFO_PLIST_FILE_PATH) ;
                ProductFile $(INFO_PLIST_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_INFO_PLIST_FILE default = $(INFO_PLIST_FILE:G=aside) ;
                    DEPENDS $(ASIDE_INFO_PLIST_FILE) : $(ASIDE_INFO_PLIST_DIR) ;
                    PBXCp $(ASIDE_INFO_PLIST_FILE) : $(_INFO_PLIST_FILE_PATH) ;
                    ProductFileAside $(ASIDE_INFO_PLIST_FILE) ;
                }
            }
            # version settings property list
            if $(_VERSION_PLIST_FILE_PATH)
             && $(PURE_JAVA) != YES {
                # if available and not pure java
                if $(PRODUCT_TYPE) = Framework {
	            VERSION_PLIST_FILE default = $(RESOURCE_DIR)$(/)version.plist ;
                    if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(RESOURCE_DIR) ;
                        ProductFile $(RESOURCE_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                            Mkdir $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAside $(ASIDE_RESOURCE_DIR) ;
                        }
                    }
                    DEPENDS $(VERSION_PLIST_FILE) : $(RESOURCE_DIR) ;
                    # create accompanying link in the case of versioned frameworks
                    if $(RESOURCE_LINK)
                     && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
                        SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                        ProductFile $(RESOURCE_LINK) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                            DEPENDS $(ASIDE_RESOURCE_LINK) : $(ASIDE_RESOURCE_DIR) ;
                            SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                            ProductFileAside $(ASIDE_RESOURCE_LINK) ;
                        }
                    }
                    DEPENDS $(VERSION_PLIST_FILE) : $(RESOURCE_LINK) ;
                }
                else {
                    if $(BUNDLE_STYLE) = SHALLOW {
                        VERSION_PLIST_FILE default = $(1:G=)$(/)version.plist ;
                    }
                    else {
                        VERSION_PLIST_FILE default = $(1:G=)$(/)Contents$(/)version.plist ;
                    }
                    VERSION_PLIST_DIR = $(VERSION_PLIST_FILE:D) ;
                    if ! $(VERSION_PLIST_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(VERSION_PLIST_DIR) ;
                        ProductFile $(VERSION_PLIST_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_VERSION_PLIST_DIR default = $(VERSION_PLIST_DIR) ;
                            Mkdir $(ASIDE_VERSION_PLIST_DIR) ;
                            ProductFileAside $(ASIDE_VERSION_PLIST_DIR) ;
                        }
                    }
                    DEPENDS $(VERSION_PLIST_FILE) : $(VERSION_PLIST_DIR) ;
                }
                PBXCp $(VERSION_PLIST_FILE) : $(_VERSION_PLIST_FILE_PATH) ;
                ProductFile $(VERSION_PLIST_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_VERSION_PLIST_FILE default = $(VERSION_PLIST_FILE:G=aside) ;
                    Cp $(ASIDE_VERSION_PLIST_FILE) : $(_VERSION_PLIST_FILE_PATH) ;
                    DEPENDS $(ASIDE_VERSION_PLIST_FILE) : $(ASIDE_VERSION_PLIST_DIR) ;
                    ProductFileAside $(ASIDE_VERSION_PLIST_FILE) ;
                }
            }
            # Copy development settings property list unless using deployment locations
            if $(DEVELOPMENT_SETTINGS_PATH)
             && $(PURE_JAVA) != YES && $(DEPLOYMENT_LOCATION) != YES {
                # if available and not pure java
                if $(PRODUCT_TYPE) = Framework {
	            DEVELOPMENT_PLIST_FILE default = $(RESOURCE_DIR)$(/)pbdevelopment.plist ;
                    if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(RESOURCE_DIR) ;
                        ProductFile $(RESOURCE_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                            Mkdir $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAsides $(ASIDE_RESOURCE_DIR) ;
                        }
                    }
                    DEPENDS $(DEVELOPMENT_PLIST_FILE) : $(RESOURCE_DIR) ;
                    # create accompanying link in the case of versioned frameworks
                    if $(RESOURCE_LINK)
                      && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
                        SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                        ProductFile $(RESOURCE_LINK) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                            SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                            DEPENDS $(ASIDE_RESOURCE_LINK) : $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAside $(ASIDE_RESOURCE_LINK) ;
                        }
                    }
                    DEPENDS $(DEVELOPMENT_PLIST_FILE) : $(RESOURCE_LINK) ;
                }
                else {
                    if $(BUNDLE_STYLE) = SHALLOW {
                        DEVELOPMENT_PLIST_FILE default = $(1:G=)$(/)pbdevelopment.plist ;
                    }
                    else {
                        DEVELOPMENT_PLIST_FILE default = $(1:G=)$(/)Contents$(/)pbdevelopment.plist ;
                    }
                    DEVELOPMENT_PLIST_DIR = $(DEVELOPMENT_PLIST_FILE:D) ;
                    if ! $(DEVELOPMENT_PLIST_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(DEVELOPMENT_PLIST_DIR) ;
                        ProductFile $(DEVELOPMENT_PLIST_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_DEVELOPMENT_PLIST_DIR default = $(DEVELOPMENT_PLIST_DIR:G=aside) ;
                            Mkdir $(ASIDE_DEVELOPMENT_PLIST_DIR) ;
                            ProductFileAsides $(ASIDE_DEVELOPMENT_PLIST) ;
                        }
                    }
                    DEPENDS $(DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_PLIST_DIR) ;
                }
                PBXCp $(DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_SETTINGS_PATH) ;
                ProductFile $(DEVELOPMENT_PLIST_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_DEVELOPMENT_PLIST_FILE default = $(DEVELOPMENT_PLIST_FILE:G=aside) ;
                    PBXCp $(ASIDE_DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_SETTINGS_PATH) ;
                    DEPENDS $(ASIDE_DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_PLIST_DIR) ;
                    ProductFileAside $(ASIDE_DEVELOPMENT_PLIST_FILE) ;
                }
            }
            # Write package info file with type and creator if available
            # and if not framework or oldest layout or pure java
            if $(_PKGINFO_FILE_PATH)
             && ( $(PRODUCT_TYPE) != Framework
             && $(PRODUCT_TYPE) != Bundle
             && $(PURE_JAVA) != YES || $(GENERATE_PKGINFO_FILE) = YES ) {
                if $(BUNDLE_STYLE) = SHALLOW || $(PRODUCT_TYPE) = Framework {
                    PKGINFO_FILE default = $(1:G=)$(/)PkgInfo ;
                }
                else {
                    PKGINFO_FILE default = $(1:G=)$(/)Contents$(/)PkgInfo ;
                }
                PKGINFO_DIR = $(PKGINFO_FILE:D) ;
                if ! $(PKGINFO_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(PKGINFO_DIR) ;
                    ProductFile $(PKGINFO_DIR) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PKGINFO_DIR default = $(PKGINFO_DIR:G=aside) ;
                        Mkdir $(ASIDE_PKGINFO_DIR) ;
                        ProductFileAside $(ASIDE_PKGINFO_DIR) ;
                    }
                }
                DEPENDS $(PKGINFO_FILE) : $(PKGINFO_DIR) ;
                PBXCp $(PKGINFO_FILE) : $(_PKGINFO_FILE_PATH) ;
                ProductFile $(PKGINFO_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_PKGINFO_FILE default = $(PKGINFO_FILE:G=aside) ;
                    DEPENDS $(ASIDE_PKGINFO_FILE) : $(ASIDE_PKGINFO_DIR) ;
                    PBXCp $(ASIDE_PKGINFO_FILE) : $(_PKGINFO_FILE_PATH) ;
                    ProductFileAside $(ASIDE_PKGINFO_FILE) ;
                }
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

# ProcessResource <product or phase> <bundle resource>
#
# Copies resources to nonlocalized or localized folders as appropriate
rule ProcessResource
{
    if source in $(BUILD_COMPONENTS) {
        local RESOURCE_SOURCE_COPY ;
        local RESOURCE_SOURCE_DIR ;
        # make directory first if necessary
        if $(2:D) {
            RESOURCE_SOURCE_DIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(RESOURCE_SOURCE_DIR) ;
            RESOURCE_SOURCE_COPY = $(RESOURCE_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(RESOURCE_SOURCE_COPY) : $(RESOURCE_SOURCE_DIR) ;
        }
        else {
            RESOURCE_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(RESOURCE_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        # copy resource to source location
        Cp $(RESOURCE_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(RESOURCE_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        local REGION = $($(2)_REGION) ;
        local SPECIFIC_REGION ;
        # resource directory must exist
        if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
            Mkdir $(RESOURCE_DIR) ;
            ProductFile $(RESOURCE_DIR) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                Mkdir $(ASIDE_RESOURCE_DIR) ;
                ProductFileAside $(ASIDE_RESOURCE_DIR) ;
            }
        }
        # create accompanying link in the case of versioned frameworks
        if $(RESOURCE_LINK)
         && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
            SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
            ProductFile $(RESOURCE_LINK) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                DEPENDS $(ASIDE_RESOURCE_LINK) : $(ASIDE_RESOURCE_DIR) ;
                ProductFileAside $(ASIDE_RESOURCE_LINK) ;
            }
        }
        if ! $(REGION) {
            # non-localized resource
            local NONLOCALIZED_RESOURCE_DIR NONLOCALIZED_RESOURCE ;
            NONLOCALIZED_RESOURCE_DIR = $(RESOURCE_DIR) ;
            if ! $(NONLOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                Mkdir $(NONLOCALIZED_RESOURCE_DIR) ;
                ProductFile $(NONLOCALIZED_RESOURCE_DIR) ;
            }
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_NONLOCALIZED_RESOURCE_DIR = $(NONLOCALIZED_RESOURCE_DIR:G=aside) ;
                if ! $(ASIDE_NONLOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(ASIDE_NONLOCALIZED_RESOURCE_DIR) ;
                    ProductFileAside $(ASIDE_NONLOCALIZED_RESOURCE_DIR) ;
                }
            }
            NONLOCALIZED_RESOURCE = $(NONLOCALIZED_RESOURCE_DIR)$(/)$(2:BS) ;
            DEPENDS $(NONLOCALIZED_RESOURCE) : $(NONLOCALIZED_RESOURCE_DIR) ;
            DEPENDS $(NONLOCALIZED_RESOURCE) : $(2) ;
            PBXCp $(NONLOCALIZED_RESOURCE) : $(2) ;
            ProductFile $(NONLOCALIZED_RESOURCE) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_NONLOCALIZED_RESOURCE = $(NONLOCALIZED_RESOURCE:G=aside) ;
                DEPENDS $(ASIDE_NONLOCALIZED_RESOURCE) : $(2) ;
                DEPENDS $(ASIDE_NONLOCALIZED_RESOURCE) : $(ASIDE_NONLOCALIZED_RESOURCE_DIR) ;
                PBXCp $(ASIDE_NONLOCALIZED_RESOURCE) : $(2) ;
                ProductFileAside $(ASIDE_NONLOCALIZED_RESOURCE) ;
            }
        } else for SPECIFIC_REGION in $(REGION) {
            # for each localization of a resource (only one ever expected)
            local LOCALIZED_RESOURCE_DIR LOCALIZED_RESOURCE ;
            LOCALIZED_RESOURCE_DIR = $(RESOURCE_DIR)$(/)$(SPECIFIC_REGION:S=.lproj) ;
            # localized resource directory must exist
            if ! $(LOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                Mkdir $(LOCALIZED_RESOURCE_DIR) ;
                ProductFile $(LOCALIZED_RESOURCE_DIR) ;
            }
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_LOCALIZED_RESOURCE_DIR = $(LOCALIZED_RESOURCE_DIR:G=aside) ;
                if ! $(ASIDE_LOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(ASIDE_LOCALIZED_RESOURCE_DIR) ;
                    ProductFileAside $(ASIDE_LOCALIZED_RESOURCE_DIR) ;
                }
            }
            LOCALIZED_RESOURCE = $(LOCALIZED_RESOURCE_DIR)$(/)$(2:BS) ;
            DEPENDS $(LOCALIZED_RESOURCE) : $(2) ;
            DEPENDS $(LOCALIZED_RESOURCE) : $(LOCALIZED_RESOURCE_DIR) ;
            PBXCp $(LOCALIZED_RESOURCE) : $(2) ;
            ProductFile $(LOCALIZED_RESOURCE) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_LOCALIZED_RESOURCE = $(LOCALIZED_RESOURCE:G=aside) ;
                DEPENDS $(ASIDE_LOCALIZED_RESOURCE) : $(2) ;
                DEPENDS $(ASIDE_LOCALIZED_RESOURCE) : $(ASIDE_LOCALIZED_RESOURCE_DIR) ;
                PBXCp $(ASIDE_LOCALIZED_RESOURCE) : $(2) ;
                ProductFileAside $(ASIDE_LOCALIZED_RESOURCE) ;
            }
        }
    }
}

actions CopyProjectFiles
{
    if [ -d $(2:Q) ]; then
        $(CP) -pRP $(2:Q) $(1:Q)
    elif [ -d $(2:S=.pbxproj:Q) ]; then
        $(CP) -pRP $(2:S=.pbxproj:Q) $(1:Q)
    fi
}

# ProcessSources <product> <source files>
#
# Process individual source files and generate versioning stub,
# kernel module stub, and use Interfacer to make exports and glue
rule ProcessSources
{
    if build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : DeriveAndCompileSources ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        # copy project files if copying source
        if source in $(BUILD_COMPONENTS) {
            local PROJECT_FILES = $(SOURCE_ROOT)/$(PROJECT).pbproj ;
            local LEGACY_PROJECT_FILES = $(SOURCE_ROOT)/$(PROJECT).pbxproj ;
            local PROJECT_FILES_COPY = $(INSTALL_ROOT)/$(PROJECT).pbproj ;
            CopyProjectFiles $(PROJECT_FILES_COPY) : $(PROJECT_FILES) : $(LEGACY_PROJECT_FILES) ;
            DEPENDS $(PROJECT_FILES_COPY) : $(INSTALL_ROOT) ;
            Mkdir $(INSTALL_ROOT) ;
            DEPENDS $(PROJECT_FILES_COPY) : $(PROJECT_FILES) ;
            NOCARE $(PROJECT_FILES) ;
            DEPENDS $(PROJECT_FILES_COPY) : $(LEGACY_PROJECT_FILES) ;
            NOCARE $(LEGACY_PROJECT_FILES) ;
            BUILD_PHASE_PRODUCTS += $(PROJECT_FILES_COPY) ;
        }
        for FILE in $(2) {
            if $(_BUILD_PHASING) = YES {
                ProcessSource $(BUILD_PHASE) : $(FILE) ;
            }
            else {
                ProcessSource $(1) : $(FILE) ;
            }
        }
        # any build component implies handling: header cloning, versioning,
        # kernel module generation, and interfacer usage
        if build in $(BUILD_COMPONENTS) {
            # generate versioning system derived sources
            if $(VERSIONING_SYSTEM) {
                local RULE = VersioningSystem_$(VERSIONING_SYSTEM) ;
                $(RULE) $(1) ;
            }
            # generate kernel module or extension info source
            if $(KERNEL_MODULE) = YES {
                KernelModuleGeneratedSource $(1) ;
            }
            # generate interfacer derived sources
            if $(GENERATE_EXPORT_SETS_AND_GLUE) = YES {
                InterfacerExportSetsAndGlue $(1) ;
            }
        }
        # compilation depends on derivation
        # !!!:cmolick:20021108 this bloats most rebuilds
        for VARIANT in $(BUILD_VARIANTS) {
            if $(OBJECT_FILES_$(VARIANT)) && $(DERIVED_FILES) {
                DEPENDS $(OBJECT_FILES_$(VARIANT)) : $(DERIVED_FILES) ;
            }
        }
        # end of phase logic
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
                # product reference link must be in place before any compiles
                if $(PRODUCT_REFERENCE) {
                    DEPENDS $(BUILD_PHASE_PRODUCTS) : $(PRODUCT_REFERENCE) ;
                }
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

# ProcessSource <product> <source file>
#
# Call ProcessFile to process a source file with the correct
# extension-specific rule, and start header scanning.
rule ProcessSource
{
    # scan non-Java for header file references in any source
    if $(2:S) != ".java" {
        if $(ENABLE_HEADER_DEPENDENCIES) != NO && $(DO_HEADER_SCANNING_IN_JAM) = YES {
            HDRRULE on $(2) = ProcessC.HdrRule ;
            HDRSCAN on $(2) = $(HDRPATTERN) ;
        }
    }
    ProcessFile $(1) : $(2) ;
}

rule ProcessFiles
{
    local FILE ;
    for FILE in $(2) {
        ProcessFile $(1) : $(FILE) ;
    }
}

rule ProcessFile
{
    local SOURCE_COPY ;
    local SOURCE_SUBDIR ;
    if source in $(BUILD_COMPONENTS) {
        # copy to source location
        # make directory first if necessary
        if $(2:D) {
            SOURCE_SUBDIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(SOURCE_SUBDIR) ;
            SOURCE_COPY = $(SOURCE_SUBDIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(SOURCE_SUBDIR) ;
            }
        }
        else {
            SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        Cp $(SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        # process file with rule based on the file suffix
        local EXCLUDED_OSS = $($(2)_EXCLUDED_OSS) ;
        local INCLUDED_OSS = $($(2)_INCLUDED_OSS) ;
        local RULE = $($(2:S)_RULE) ;

        if $(EXCLUDED_OSS) && ( $(OS) in $(EXCLUDED_OSS) ) {
            # do nothing -- file excluded from build
        } else if $(INCLUDED_OSS) && ! ( $(OS) in $(INCLUDED_OSS) ) {
            # do nothing -- file excluded from build
        } else if $(RULE) {
            $(RULE) $(1) : $(2) ;
        } else {
            ECHO jam: warning: no rule for file $(2) ;
        }
    }
}

# ProcessFrameworksAndLibraries <product> <linked files>
#
# Link object files and/or archive classes
rule ProcessFrameworksAndLibraries
{
    if ( build in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : LinkWithFrameworksAndLibraries ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = $(INNER_PRODUCT) ;
        }
        for VARIANT in $(BUILD_VARIANTS) {
	# add to linked files, including java .jar files even when there are no native object files!
        # This was never questioned, but the long comment was added after this
        # step was repeatedly moved outside this block by integration errors.
	LINKED_FILES_$(VARIANT) += $(2) ;

        # only link if there are object files
        if $(OBJECT_FILES_$(VARIANT)) {
            if ! ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC ) {
                SINGLE_MODULE default = YES ;
            }
            # define products
            if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Library {
                # simple product
                INNER_PRODUCT default = $(1:G=) ;
                INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT)$(VARIANT_SUFFIX_$(VARIANT)) ;
                INNER_PRODUCT_LINK_$(VARIANT) default = ;
                ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
                if $(DEPLOYMENT_POSTPROCESSING) = YES {
                    SetModeOwnerAndGroup $(INNER_PRODUCT_$(VARIANT):G=ModeOwnerGroup) : $(INNER_PRODUCT_$(VARIANT)) ;
                }
            }
            else {
                if $(PRODUCT_TYPE) = Framework {
                    # versioned bundle
                    INNER_PRODUCT default = $(1:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)$(1:BG=) ;
                    INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK default = $(1:G=)$(/)$(1:BG=) ;
                    if $(VARIANT) = normal {
                        INNER_PRODUCT_LINK_$(VARIANT) default = $(INNER_PRODUCT_LINK)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                        INNER_PRODUCT_LINK_PATH default = Versions$(/)Current$(/)$(1:BG=) ;
                        INNER_PRODUCT_LINK_PATH_$(VARIANT) default = $(INNER_PRODUCT_LINK_PATH)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    }
                }
                else {
                    # standard bundle
                    if $(BUNDLE_STYLE) = SHALLOW {
                        INNER_PRODUCT default = $(1:G=)$(/)$(1:BG=) ;
                    }
                    else {
                        INNER_PRODUCT default = $(1:G=)$(/)Contents$(/)MacOS$(/)$(1:BG=) ;
                    }
                    INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT)$(VARIANT_SUFFIX_$(VARIANT))$(TOOL_SUFFIX) ;
                    INNER_PRODUCT_LINK_$(VARIANT) default = ;
                }
                # inner product should always be ready before the link to it
                if $(INNER_PRODUCT_LINK_$(VARIANT)) {
                    DEPENDS $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                }
                # inner product directory needed for all bundle types
                INNER_PRODUCT_DIR_$(VARIANT) = $(INNER_PRODUCT_$(VARIANT):D) ;
                if ! $(INNER_PRODUCT_DIR_$(VARIANT)) in $(PRODUCT_FILES) {
                    Mkdir $(INNER_PRODUCT_DIR_$(VARIANT)) ;
                    ProductFile $(INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
                if $(INNER_PRODUCT_$(VARIANT)) && $(INNER_PRODUCT_DIR_$(VARIANT)) {
                    DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
                # optionally make inner product dir aside
                if $(ASIDE_DIR) {
                    ASIDE_INNER_PRODUCT_DIR_$(VARIANT) = $(INNER_PRODUCT_DIR_$(VARIANT):G=aside) ;
                    if ! $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) in $(PRODUCT_FILES) {
                        Mkdir $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                        ProductFileAside $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                    }
                }
            }
            # Link inner product
            # By default single module linking is done for all but static libraries.
            # If using Interfacer, then a master object file is generated instead.
            # Static libraries have ranlib run on them after all other steps are complete.
            if $(GENERATE_HEADERS) = YES || $(GENERATE_EXPORT_SETS_AND_GLUE) = YES || $(CFM_BRIDGE) = YES {
                GENERATE_MASTER_OBJECT_FILE default = YES ;
            }
            if $(GENERATE_MASTER_OBJECT_FILE) = YES {
                SINGLE_MODULE = NO ;
            }
	    LINK_FILE_LIST_$(VARIANT) on $(INNER_PRODUCT_$(VARIANT)) = $(FILE_LIST_$(VARIANT)) ;
            if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
                # stand alone executable
                if $(GENERATE_MASTER_OBJECT_FILE) = YES {
                    ProcessSingleObjectLink $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : StandaloneExecutable ;
                }
                else {
                    StandaloneExecutable $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) ;
                }
            }
            else {
                if $(LIBRARY_STYLE) = STATIC && $(KERNEL_MODULE) != YES {
                    # static library
                    if $(GENERATE_MASTER_OBJECT_FILE) = YES {
                        ProcessSingleObjectLink $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : StaticLibrary ;
                    }
                    else {
                        StaticLibrary $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) ;
                    }
                }
                else {
                    # dylibs, bundles, frameworks, and kernel extensions
                    if $(GENERATE_MASTER_OBJECT_FILE) = YES {
                        ProcessSingleObjectLink $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : DynamicLibrary ;
                    }
                    else {
                        DynamicLibrary $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) ;
                    }
                }
            }
            ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
            DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(TARGET_BUILD_DIR) ;
            # optionally copy inner product aside
            if $(ASIDE_DIR) {
                ASIDE_INNER_PRODUCT_$(VARIANT) = $(INNER_PRODUCT_$(VARIANT):G=aside) ;
                ProductFileAside $(ASIDE_INNER_PRODUCT_$(VARIANT)) ;
                PBXCp $(ASIDE_INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                if $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) {
                    DEPENDS $(ASIDE_INNER_PRODUCT_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
            }
            # preen
            if $(DEPLOYMENT_POSTPROCESSING) = YES && $(UNSTRIPPED_PRODUCT) != YES {
                STRIPPED_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT_$(VARIANT):G=strip) ;
                DEPENDS $(STRIPPED_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                if $(ASIDE_INNER_PRODUCT_$(VARIANT)) {
                    DEPENDS $(STRIPPED_PRODUCT_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_$(VARIANT)) ;
                }
                if $(PRODUCT_TYPE) != Tool && $(PRODUCT_TYPE) != Application {
                    if ( $(PRODUCT_TYPE) = Bundle
                     || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = BUNDLE ) )
                     && $(KERNEL_MODULE) != YES {
                        STRIPFLAGS default = -x ;
                    }
                    else {
                        STRIPFLAGS default = -S ;
                    }
                }
                if $(SEPARATE_STRIP) = YES
                 || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC ) 
                 || ( $(STRIPFLAGS) && $(STRIPFLAGS) != -s && $(STRIPFLAGS) != -S && $(STRIPFLAGS) != -x ) {
                    # static libraries and products with nontrivial STRIPFLAGS get an explicit strip call
                    Strip $(STRIPPED_PRODUCT_$(VARIANT)) ;
                    if $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC {
                        Ranlib $(STRIPPED_PRODUCT_$(VARIANT)) ;
                    }
                    ProductFile $(STRIPPED_PRODUCT_$(VARIANT)) ;
                }
                else {
                    # all other products get -s or -S supplied to the linker depending on basic STRIPFLAGS usage
                    if $(STRIPFLAGS) = -S {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -Wl,-S ;
                    }
                    else {
                        if $(STRIPFLAGS) = -x {
                            FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -Wl,-x ;
                        }
                        else {
                            FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -s ;
                        }
                    }
                }
            }
            # make inner product symlink, if any
            if $(INNER_PRODUCT_LINK_$(VARIANT)) {
                SymLink $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                ProductFile $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                DEPENDS $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                # optionally copy inner product link aside
                if $(ASIDE_DIR) {
                    ASIDE_INNER_PRODUCT_LINK_$(VARIANT) = $(INNER_PRODUCT_LINK_$(VARIANT):G=aside) ;
                    ProductFileAside $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) ;
                    SymLink $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                    DEPENDS $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_$(VARIANT)) ;
                    DEPENDS $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
            }
            # edit symbols
            # Symbol editing is done directly with the product with linker flags if possible
            # unless a master object file is generated in which case that is edited prior to linking.
            if $(EXPORTED_SYMBOLS_FILE) && $(GENERATE_MASTER_OBJECT_FILE) != YES {
                if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application
                 || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) != DYNAMIC ) {
                    # !!!:cmolick:20021025 edit using nmedit after the link
                    EditSymbols $(INNER_PRODUCT_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE) ;
                }
                else {
                    # !!!:cmolick:20021025 attempt to use linker flag
                    FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -Wl,-exported_symbols_list $(EXPORTED_SYMBOLS_FILE) ;
                    DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE) ;
                }
            }
            # static libraries must have ranlib run on them after all else
            if $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC {
                RANLIB_INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT_$(VARIANT):G=ranlib) ;
                # ranlib depends on link, strip, modeownergroup
                DEPENDS $(RANLIB_INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                if $(ASIDE_INNER_PRODUCT_$(VARIANT)) {
                    DEPENDS $(RANLIB_INNER_PRODUCT_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_$(VARIANT)) ;
                }
                if $(STRIPPED_PRODUCT_$(VARIANT)) {
                    DEPENDS $(RANLIB_INNER_PRODUCT_$(VARIANT)) : $(STRIPPED_PRODUCT_$(VARIANT)) ;
                }
                ProductFile $(RANLIB_INNER_PRODUCT_$(VARIANT)) ;
            }
            if $(GENERATE_MASTER_OBJECT_FILE) != YES {
                # Add prelink flags and libraries to link flags if nonempty
                # Because -keep_private_externs was typically specific to prelinking, it is not carried over.
                for _PRELINK_FLAG in $(PRELINK_FLAGS) {
                    if $(_PRELINK_FLAG) != -keep_private_externs {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += $(_PRELINK_FLAG) ;
                    }
                }
                for _PRELINK_LIB in $(PRELINK_LIBS) {
                    if $(_PRELINK_LIB) != -keep_private_externs {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += $(_PRELINK_LIB) ;
                    }
                }
            }
            # Basic link options determine if this is kext, bundle, or library
            if $(KERNEL_MODULE) = YES {
                MODULE_OBJECT_PATH = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(MODULE_OBJECT_FILE_$(VARIANT)) ;
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -static -nostdlib -r -lkmodc++ "$(MODULE_OBJECT_PATH)" -lkmod -lcc_kext ;
                if $(GCC_VERSION) = 4.0 {
                    FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -lcpp_kext ;
                }
            }
            else {
                # Options for products that are not bundles or static libraries
                if $(PRODUCT_TYPE) != Bundle
                 && ! ( $(PRODUCT_TYPE) = Library && ( $(LIBRARY_STYLE) = BUNDLE || $(LIBRARY_STYLE) = STATIC ) ) {
                    if $(PREBINDING) = YES {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -prebind ;
                    }
                    if $(SINGLE_MODULE) = YES && $(PRODUCT_TYPE) != Tool && $(PRODUCT_TYPE) != Application {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -Wl,-single_module ;
                    }
                }
                # Options relating to the type of library desired as output
                if $(PRODUCT_TYPE) = Bundle
                 || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = BUNDLE ) {
                    FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -bundle ;
                } else {
                    if $(PRODUCT_TYPE) = Framework
                     || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = DYNAMIC ) {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -dynamiclib ;
                    }
                    else {
                        if $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC {
                            FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -static ;
                        }
                    }
                }
                # Dynamic library link options set version and installed name
                if ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = DYNAMIC )
                 || $(PRODUCT_TYPE) = Framework {
                    if $(DYLIB_COMPATIBILITY_VERSION) {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -compatibility_version "$(DYLIB_COMPATIBILITY_VERSION)" ;
                    }
                    if $(DYLIB_CURRENT_VERSION) {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -current_version "$(DYLIB_CURRENT_VERSION)" ;
                    }
                    if ! $(DYLIB_INSTALL_NAME_BASE) {
                        if $(INSTALL_PATH) {
                            DYLIB_INSTALL_NAME_BASE = $(INSTALL_PATH) ;
                        }
                    }
                    if $(DYLIB_INSTALL_NAME_BASE) {
                        DYLIB_INSTALLED_NAME_$(VARIANT) default = $(DYLIB_INSTALL_NAME_BASE)$(/)$(INNER_PRODUCT_$(VARIANT):G=) ;
                        INSTALLED_NAME_FLAG on $(INNER_PRODUCT_$(VARIANT)) = -install_name \"`echo \"$(DYLIB_INSTALLED_NAME_$(VARIANT))\" | $(SED) 's!//*!/!g'`\" ;
                    }
                }
            }
            # reduce warnings for multiarchitecture builds
            if $(WARNING_LDFLAGS) && ( $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application ) {
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += $(WARNING_LDFLAGS) ;
            }
            # profiling link option
            if $(PROFILING_CODE) = YES {
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -pg ;
            }
            # other link options
            if $(OTHER_LDFLAGS_$(VARIANT)) {
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += $(OTHER_LDFLAGS_$(VARIANT)) ;
            }
        }
        else {
            # no object files present, indicating pure Java
            if $(PRODUCT_TYPE) = Framework {
                if $(CURRENT_VERSION_LINK) {
                    INNER_PRODUCT_$(VARIANT) default = $(1:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)$(1:B)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK_$(VARIANT) default = $(1:G=)$(/)$(1:BG=)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK_PATH_$(VARIANT) default = Versions$(/)Current$(/)$(1:BG=)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    # inner product link
                    SymLink $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                    ProductFile $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                    NOUPDATE $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                }
                else  {
                    INNER_PRODUCT_$(VARIANT) default = $(1:G=)$(/)$(1:BG=)_$(VARIANT)$(DYNAMIC_LIBRARY_SUFFIX) ;
                }
                ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
                if $(DYLIB_COMPATIBILITY_VERSION) {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -compatibility_version "$(DYLIB_COMPATIBILITY_VERSION)" ;
                }
                else {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -compatibility_version 1 ;
                }
                if $(DYLIB_CURRENT_VERSION) {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -current_version "$(DYLIB_CURRENT_VERSION)" ;
                }
                else {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -current_version 1 ;
                }
                if ! $(DYLIB_INSTALL_NAME_BASE) {
                    if $(INSTALL_PATH) {
                        DYLIB_INSTALL_NAME_BASE = $(INSTALL_PATH) ;
                    }
                }
                GenerateFrameworkStub $(INNER_PRODUCT_$(VARIANT)) ;
                INNER_PRODUCT_DIR = $(INNER_PRODUCT_$(VARIANT):D) ;
                if ! $(INNER_PRODUCT_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(INNER_PRODUCT_DIR) ;
                    ProductFile $(INNER_PRODUCT_DIR) ;
                    DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_DIR) ;
                }
                if $(INNER_PRODUCT_LINK_$(VARIANT)) {
                    SymLink $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                    NOUPDATE $(INNER_PRODUCT_LINK_$(VARIANT)) ; 
                    ProductFile $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                }
            }
        }
        # Java processing compatible with the presense of object files
        if $(COMPILED_JAVA) {
            # provide stub executable if necessary
            if $(JAVA_ONLY) = YES {
                INNER_PRODUCT_$(VARIANT) default = $(1:G=)$(/)Contents$(/)MacOS$(/)$(1:BG=) ;
                # must first make subfolder and depend on that
                INNER_PRODUCT_SUBDIR = $(INNER_PRODUCT_$(VARIANT):D) ;
                if ! $(INNER_PRODUCT_SUBDIR) in $(PRODUCT_FILES) {
                    Mkdir $(INNER_PRODUCT_SUBDIR) ;
                    ProductFile $(INNER_PRODUCT_SUBDIR) ;
                    DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_SUBDIR) ;
                }
                Cp $(INNER_PRODUCT_$(VARIANT)) : $(JAVA_APP_STUB) ;
                ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
            }
        }
        # Add jar/zip files that are in the link phase to the classpath
        if $(OTHER_JAVA_CLASS_PATH) {
            export LINKED_CLASS_ARCHIVES = :"$(OTHER_JAVA_CLASS_PATH)" ;
        }
        else {
            export LINKED_CLASS_ARCHIVES = "" ;
        }
        for JAVA_CLASS_SEARCH_PATH in $(JAVA_CLASS_SEARCH_PATHS) {
            LINKED_CLASS_ARCHIVES = "$(LINKED_CLASS_ARCHIVES):$(JAVA_CLASS_SEARCH_PATH)" ;
        }
        local ARCHIVE ;
        
        for ARCHIVE in $(LINKED_FILES_$(VARIANT)) {
            switch $(ARCHIVE) {
            case *.framework :
                local FW_SUBDIR ;
                for FW_SUBDIR in $(JAVA_FRAMEWORK_RESOURCES_DIRS) {
                    LINKED_CLASS_ARCHIVES = $(LINKED_CLASS_ARCHIVES):$(ARCHIVE)$(/)$(FW_SUBDIR)$(/)Java ;
                    JAVA_FRAMEWORK_JARS += $(ARCHIVE)$(/)$(FW_SUBDIR)$(/)Java ;
                }
            case *.jar :
                LINKED_CLASS_ARCHIVES = $(LINKED_CLASS_ARCHIVES):$(ARCHIVE) ;
                if Merge in $($(ARCHIVE)_ATTRIBUTES) {
                    # merge archive contents by unpacking them into hierarchy
                    local DESTINATION_TARGET = $(CLASS_FILE_DIR:G=Unarchive$(ARCHIVE)) ;
                    NOTFILE $(DESTINATION_TARGET) ;
                    DEPENDS $(DESTINATION_TARGET) : $(JAVA_COMPILE_TARGET) ;
                    if $(MERGED_ARCHIVES) {
                        MERGED_ARCHIVES += $(DESTINATION_TARGET) ;
                    }
                    else {
                        MERGED_ARCHIVES = $(DESTINATION_TARGET) ;
                    }
                    Unarchive $(DESTINATION_TARGET) : $(ARCHIVE) ;
                }
            case *.zip :
                LINKED_CLASS_ARCHIVES = $(LINKED_CLASS_ARCHIVES):$(ARCHIVE) ;
                if Merge in $($(ARCHIVE)_ATTRIBUTES) {
                    # merge archive contents by unpacking them into hierarchy
                    local DESTINATION_TARGET = $(CLASS_FILE_DIR:G=Unarchive$(ARCHIVE)) ;
                    NOTFILE $(DESTINATION_TARGET) ;
                    DEPENDS $(DESTINATION_TARGET) : $(JAVA_COMPILE_TARGET) ;
                    if $(MERGED_ARCHIVES) {
                        MERGED_ARCHIVES += $(DESTINATION_TARGET) ;
                    }
                    else {
                        MERGED_ARCHIVES = $(DESTINATION_TARGET) ;
                    }
                    Unarchive $(DESTINATION_TARGET) : $(ARCHIVE) ;
                }
            }
        }
        # generate an archive if there are compiled or merged classes
        if $(COMPILED_JAVA) || $(MERGED_ARCHIVES) || $(COPIED_JAVA_RESOURCES) {
	    if $(JAVA_ARCHIVE_CLASSES) != NO {
	        # java archive suffix applies to applications and frameworks
	        if $(JAVA_ARCHIVE_TYPE) = JAR {
		    CLASS_ARCHIVE_SUFFIX default = .jar ;
	        }
	        else {
		    if $(JAVA_ARCHIVE_TYPE) = ZIP {
		        CLASS_ARCHIVE_SUFFIX default = .zip ;
		    }
	        }
	        if ( $(PRODUCT_TYPE) = Bundle
                  || $(PRODUCT_TYPE) = Application
                  || $(PRODUCT_TYPE) = Framework ) {
                    # Assume bundled products with object files are Cocoa
		    CLASS_ARCHIVE default = $(RESOURCE_DIR)$(/)Java$(/)$(1:B)$(CLASS_ARCHIVE_SUFFIX) ;
                    ProductFile $(CLASS_ARCHIVE) ;
	        }
	        else {
                    CLASS_ARCHIVE default = $(1:B:G=)$(CLASS_ARCHIVE_SUFFIX) ;
                    # It is critical for the class archive to be declared
                    # a product file before any symlinks to it are made
                    # which would conditionally involved declaring the
                    # symbolic link content to not be a file.
                    ProductFile $(CLASS_ARCHIVE) ;
                    # ref. w/suffix for tool or library in deployment location
                    if $(DEPLOYMENT_LOCATION) = YES {
                        _ARCHIVE_REFERENCE default = $(BUILT_PRODUCTS_DIR:G=ArchiveRef)$(/)$(CLASS_ARCHIVE) ;
                        SymLink $(_ARCHIVE_REFERENCE) : $(CLASS_ARCHIVE) ;
                        DEPENDS $(_ARCHIVE_REFERENCE) : $(BUILT_PRODUCTS_DIR) ;
                        DEPENDS $(1) : $(_ARCHIVE_REFERENCE) ;
                    }
                    # Make a link to the product without extension
                    # to allow for references missing extension.
                    _SUFFIX_FREE_ARCHIVE_REFERENCE = $(BUILT_PRODUCTS_DIR:G=SuffixFreeArchiveRef)$(/)$(CLASS_ARCHIVE:S=) ;
                    SymLink $(_SUFFIX_FREE_ARCHIVE_REFERENCE) : $(CLASS_ARCHIVE) ;
                    DEPENDS $(_SUFFIX_FREE_ARCHIVE_REFERENCE) : $(BUILT_PRODUCTS_DIR) ;
                    DEPENDS $(1) : $(_SUFFIX_FREE_ARCHIVE_REFERENCE) ;
    	        }
                # class archive depends on target build dir
                DEPENDS $(CLASS_ARCHIVE) : $(TARGET_BUILD_DIR) ;
                # class archive depends on class archive dir (if defined)
                CLASS_ARCHIVE_DIR = $(CLASS_ARCHIVE:D:G=) ;
                if $(CLASS_ARCHIVE_DIR) && ! $(CLASS_ARCHIVE_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(CLASS_ARCHIVE_DIR) ;
                    ProductFile $(CLASS_ARCHIVE_DIR) ;
                }
	        # class files unknown, so archive depends on java compile log
	        ClassArchive $(CLASS_ARCHIVE) : $(CLASS_FILE_DIR) ;
	        if $(MERGED_ARCHIVES) {
                    DEPENDS $(CLASS_ARCHIVE) : $(MERGED_ARCHIVES) ;
                }
                if $(COMPILED_JAVA) {
                    DEPENDS $(CLASS_ARCHIVE) : $(JAVA_COMPILE_TARGET) ;
                }
                if $(COPIED_JAVA_RESOURCES) {
                    DEPENDS $(CLASS_ARCHIVE) : $(COPIED_JAVA_RESOURCES) ;
                }
	    }
            if $(JAVA_ARCHIVE_CLASSES) != YES {
                ForceMkdir $(PRODUCT_CLASS_FILE_DIR) ;
                ProductFile $(PRODUCT_CLASS_FILE_DIR) ;
                Ditto $(PRODUCT_CLASS_FILE_DIR) : $(CLASS_FILE_DIR) ;
	        if $(MERGED_ARCHIVES) {
                    DEPENDS $(PRODUCT_CLASS_FILE_DIR) : $(MERGED_ARCHIVES) ;
                }
                else {
                    DEPENDS $(PRODUCT_CLASS_FILE_DIR) : $(JAVA_COMPILE_TARGET) ;
                }
            }
        }
	# Export the path to the inner product, if any.
	export INNER_PRODUCT_SUBPATH = $(INNER_PRODUCT:G=) ;
	# Build phasing bookkeeping
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
    }
}

rule ProcessFrameworkOrLibrary
{
    for VARIANT in $(BUILD_VARIANTS) {
    LINKED_FILES_$(VARIANT) += $(2) ;
    }
}

# ProcessRezFiles <product> <rez and resmerger input files>
#
# Processes Rez and ResMerger input files, or if there are none
# and type and creator are set uses SetFile to set type and creator.
rule ProcessRezFiles
{
    if ( build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : RezResourceManagerFiles ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        if $(2) {
            for FILE in $(2) {
                if $(_BUILD_PHASING) = YES {
                    ProcessRezFile $(BUILD_PHASE) : $(FILE) ;
                }
                else {
                    ProcessRezFile $(1) : $(FILE) ;
                }
            }
        }
        else {
            if ( $(MACOS_TYPE) || $(MACOS_CREATOR) ) && $(REZ_EXECUTABLE) = YES {
                local RESOURCE_FORK = $(INNER_PRODUCT:G=ResourceFork) ;
                if ! $(INNER_PRODUCT) in $(PRESERVE_RESOURCES) {
                     PRESERVE_RESOURCES += $(INNER_PRODUCT) ;
                }
                ProductFile $(RESOURCE_FORK) ;
                if $(ALWAYS_REZ) = YES {
                    ALWAYS $(RESOURCE_FORK) ;
                }
                SetFile $(RESOURCE_FORK) ;
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

# ProcessRezFile <product or phase> <rez or resmerger input file>
#
# Sets up the compile of one Rez or ResMerger input file.
# RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR	folder for resource collectors
# RESOURCE_MANAGER_RESOURCE_COLLECTOR		resource collector
# RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)	localized collector
# RESOURCE_MANAGER_RESOURCE			final resource destination
# RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR	localized final folder
# RESOURCE_MANAGER_RESOURCE_$(REGION)		localized final destination
rule ProcessRezFile
{
    if source in $(BUILD_COMPONENTS) {
        local REZ_SOURCE_COPY ;
        local REZ_SOURCE_DIR ;
        # make directory first if necessary
        if $(2:D) {
            REZ_SOURCE_DIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(REZ_SOURCE_DIR) ;
            REZ_SOURCE_COPY = $(REZ_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(REZ_SOURCE_COPY) : $(REZ_SOURCE_DIR) ;
        }
        else {
            REZ_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(REZ_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        # copy rez files to source location
        Cp $(REZ_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(REZ_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        local REGION = $($(2)_REGION) ;
        # scan for header files
        if $(ENABLE_HEADER_DEPENDENCIES) != NO && $(DO_HEADER_SCANNING_IN_JAM) = YES {
            HDRRULE on $(2) = ProcessC.HdrRule ;
            HDRSCAN on $(2) = $(HDRPATTERN) ;
        }
        # all resources require a folder to hold any collector
        if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) {
            RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR = $(TEMP_DIR)$(/)ResourceManagerResources ;
            Mkdir $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
            ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
        }
        if $(REZ_EXECUTABLE) = YES {
            # Optionally accumulate ResourceManager resources
            # on a resource fork of the executable
            PRESERVE_RESOURCES += $(INNER_PRODUCT) ;
            if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) {
                RESOURCE_MANAGER_RESOURCE_COLLECTOR = $(INNER_PRODUCT:BG=ResourceManagerResourceCollector) ;
                DEPENDS $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
            }
            if $(2:S) = ".r" {
                RezCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
            } else {
                ResMergerCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
            }
            # The collector must be declared a product file
            # only after the first Collector rule invocation
            # to correctly initialize the collector.
            ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
            # location must be set after ProductFile invocation
            LOCATE on $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) = $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
            if ! $(RESOURCE_MANAGER_RESOURCE) {
                RESOURCE_MANAGER_RESOURCE = $(INNER_PRODUCT:G=ResourceManagerResource) ;
                ProductFile $(RESOURCE_MANAGER_RESOURCE) ;
                ResMergerProduct $(RESOURCE_MANAGER_RESOURCE) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
            }
        }
        else {
            # By default ResourceManager resources are stored in data forks
            # as Resources/<product>.rsrc files if non localized, or 
            # Resources/<region>.lproj/Localized.rsrc files if localized.
            if $(REGION) {
                # localized resource collector
                if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) {
                    RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION) = $(REGION).rsrc ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
                }
                if $(2:S) = ".r" {
                    RezCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) : $(2) ;
                } else {
                    ResMergerCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) : $(2) ;
                }
                # collector declared product after first Collector rule invocation
                ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) ;
                # set location only after ProductFile invocation
                LOCATE on $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) = $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
                # localized resource folder
                RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR = $(RESOURCE_DIR)$(/)$(REGION).lproj ;
                Mkdir $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                ProductFile $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                # localized resource
                if ! $(RESOURCE_MANAGER_RESOURCE_$(REGION)) {
                    RESOURCE_MANAGER_RESOURCE_$(REGION) = $(RESOURCE_DIR)$(/)$(REGION).lproj$(/)Localized.rsrc ;
                    ProductFile $(RESOURCE_MANAGER_RESOURCE_$(REGION)) ;
                    # folder for localized resource
                    RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR = $(RESOURCE_DIR)$(/)$(REGION).lproj ;
                    Mkdir $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                    ProductFile $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) : $(RESOURCE_DIR) ;
                    # get product from collector
                    ResMergerProduct $(RESOURCE_MANAGER_RESOURCE_$(REGION)) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_$(REGION)) : $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                }
            }
            else {
                # nonlocalized resource collector
                if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) {
                    RESOURCE_MANAGER_RESOURCE_COLLECTOR = $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR)$(/)$(1:S=.rsrc:G=) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
                }
                if $(2:S) = ".r" {
                    RezCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
                } else {
                    ResMergerCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
                }
                # collector declared product after Collector rule invocation
                ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
                # nonlocalized resource
                if ! $(RESOURCE_MANAGER_RESOURCE) {
                    RESOURCE_MANAGER_RESOURCE = $(RESOURCE_DIR)$(/)$(1:S=.rsrc:G=) ;
                    ProductFile $(RESOURCE_MANAGER_RESOURCE) ;
                    # get product from collector
                    ResMergerProduct $(RESOURCE_MANAGER_RESOURCE) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE) : $(RESOURCE_DIR) ;
                    if $(ALWAYS_REZ) = YES {
                        ALWAYS $(RESOURCE_MANAGER_RESOURCE) ;
                    }
                }
            }

            if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                Mkdir $(RESOURCE_DIR) ;
                ProductFile $(RESOURCE_DIR) ;
            }
        }
        # create accompanying link in the case of versioned frameworks
        if $(RESOURCE_LINK) 
         && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
            SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
            ProductFile $(RESOURCE_LINK) ;
        }
    }
}

rule ProcessScriptBuildPhaseFiles
{
    if source in $(BUILD_COMPONENTS) || headers in $(BUILD_COMPONENTS) || build in $(BUILD_COMPONENTS) {
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : Script ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        if build in $(BUILD_COMPONENTS)
         || ( headers in $(BUILD_COMPONENTS) && $(INSTALLHDRS_SCRIPT_PHASE) = YES ) {
            SEARCH on $(2) = $(SOURCE_ROOT) $(TEMP_ROOT) ;
            PHASE_SCRIPT_EXECUTION = $(2:G=Execution) ;
            NOTFILE $(PHASE_SCRIPT_EXECUTION) ;
            ALWAYS $(PHASE_SCRIPT_EXECUTION) ;
            DEPENDS $(1) : $(PHASE_SCRIPT_EXECUTION) ;
            PhaseScriptExecution $(PHASE_SCRIPT_EXECUTION) : $(2) ;
            if ! $(PHASE_SCRIPT_EXECUTION) in $(PRODUCT_FILES) {
                if $(_BUILD_PHASING) = YES {
                    BUILD_PHASE_PRODUCTS += $(PHASE_SCRIPT_EXECUTION) ;
                }
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
                if $(PREVIOUS_BUILD_PHASE) {
                    # !!!:cmolick:20021119 depend on previous phase or products to get timing right?
                    DEPENDS $(BUILD_PHASE_PRODUCTS) : $(PREVIOUS_BUILD_PHASE) ;
                }
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

rule PhaseScriptExecution
{
    JAMSHOULDSETENV on $(1) = YES ;
    DEPENDS $(1) : $(2) ;
}
actions exportvars PhaseScriptExecution
{
    echo "=== Script ==="
    cat $(2:Q)
    echo "--- Output ---"
    $(2:Q)
    _result=$?
    echo "=== Exit code: ${_result} ==="
    exit ${_result}
}

rule ProcessCopyFiles
{
    if $(_BUILD_PHASING) = YES {
        PhaseTarget BUILD_PHASE : $(1) : CopyFiles ;
        BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
        BUILD_PHASE_PRODUCTS = ;
    }
    if build in $(BUILD_COMPONENTS)
     || ( headers in $(BUILD_COMPONENTS) && $(INSTALLHDRS_COPY_PHASE) = YES ) {
        SEARCH on $(2) = $(SOURCE_ROOT) ;
        for FILE in $(2) {
            ProcessCopyFile $(1) : $(FILE) : $(COPYFILES_DESTINATION_PATH) ;
        }
    }
    if $(_BUILD_PHASING) = YES {
        if $(BUILD_PHASE_PRODUCTS) {
            DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
        }
        PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
    }
}

rule ProcessCopyFile
{
    if source in $(BUILD_COMPONENTS) {
        local SOURCE_COPY ;
        local SOURCE_SUBDIR ;
        # copy files to source location
        # make directory first if necessary
        if $(2:D) {
            SOURCE_SUBDIR = $(2:D:G=SourceCopy) ;
            Mkdir $(SOURCE_SUBDIR) ;
            SOURCE_COPY = $(SOURCE_SUBDIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_SUBDIR) ;
        }
        else {
            SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        Cp $(SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) || headers in $(BUILD_COMPONENTS) {
        local DESTINATION_DIR = $(3) ;
        if ! $(DESTINATION_DIR) in $(PRODUCT_FILES) {
            Mkdir $(DESTINATION_DIR) ;
            ProductFile $(DESTINATION_DIR) ;
        }
        local DESTINATION_BASE = $(2:BS) ;
        local DESTINATION default = $(DESTINATION_DIR)$(/)$(DESTINATION_BASE) ;
        DEPENDS $(DESTINATION) : $(DESTINATION_DIR) ;
        DEPENDS $(DESTINATION) : $(2) ;
        ProductFile $(DESTINATION) ;
        LOCATE on $(DESTINATION) = $(DESTINATION_DIR) ;
        PBXCp $(DESTINATION) : $(2) ;
    }
}

rule ProcessJavaResourceFiles
{
    if build in $(BUILD_COMPONENTS) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : JavaArchiveFiles ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        LOCATE on $(2) = $(SOURCE_ROOT) ;
        for FILE in $(2) {
            ProcessJavaResourceFile $(1) : $(FILE) : $(CLASS_FILE_DIR) ;
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

rule ProcessJavaResourceFile
{
    local ARCHIVE_PATH ;
    local ARCHIVE_DESTINATION ;
    local ARCHIVE_DESTINATION_FILE ;

    # copy any other reference - formulate destination first
    if $($(2)_JAVA_ARCHIVE_SUBDIR) {
        ARCHIVE_DESTINATION_DIR = $(3)$(/)$($(2)_JAVA_ARCHIVE_SUBDIR) ;
    }
    else {
        # if there's no setting, just copy the file to the root of the archive.
        ARCHIVE_DESTINATION_DIR = $(3) ;
    }
    ARCHIVE_DESTINATION_FILE = $(ARCHIVE_DESTINATION_DIR)/$(2:BS) ;
    Mkdir $(ARCHIVE_DESTINATION_DIR) ;
    ProductFile $(ARCHIVE_DESTINATION_DIR) ;
    PBXCp $(ARCHIVE_DESTINATION_FILE:G=populated) : $(2) ;
    ProductFile $(ARCHIVE_DESTINATION_FILE:G=populated) ;
    DEPENDS $(ARCHIVE_DESTINATION_FILE:G=populated) : $(ARCHIVE_DESTINATION_DIR) ;

    # copied content depends on source
    DEPENDS $(ARCHIVE_DESTINATION_FILE) : $(2) ;
    # set contents present for archival flag by making COPIED_JAVA_RESOURCES nonempty
    COPIED_JAVA_RESOURCES += $(2) ;
}

# Following rules are used by ProcessSource
# to attend to specific types of source file.

rule ProcessUsingJavaCompiler
{
    # Compile .java to .class files using javac or jikes
    # Because what class files will be generated by the java compiler
    # can't be known in advance, an abstract target is used for this step.
    if $(JAVA_COMPILE_TARGET) = "" {
        JAVA_COMPILE_TARGET = $(1:G=CompileJava) ;
        NOTFILE $(JAVA_COMPILE_TARGET) ;
        DEPENDS $(1) : $(JAVA_COMPILE_TARGET) ;
        DEPENDS $(JAVA_COMPILE_TARGET) : $(CLASS_FILE_DIR) ;
        # bridge derived java to be generated and compiled first
        if $(JAVA_BRIDGE_COMPILE_TARGET) {
            DEPENDS $(JAVA_COMPILE_TARGET) : $(JAVA_BRIDGE_COMPILE_TARGET) ;
        }
    }
    
    export JAVA_SOURCE_PATH default = $(SOURCE_ROOT)$(/)$(JAVA_SOURCE_SUBDIR) ;

    # start with the compiler-specific flags.
    if $(JAVA_COMPILER:B) = jikes {
        export JAVAC_FLAGS = $(JIKES_DEFAULT_FLAGS) ;
    }
    else if $(JAVA_COMPILER:B) = javac {
        export JAVAC_FLAGS = $(JAVAC_DEFAULT_FLAGS) ;
    }
    else {
        export JAVAC_FLAGS = ;
    }
    
    if $(JAVA_COMPILER_DISABLE_WARNINGS) = YES {
        JAVAC_FLAGS += "-nowarn" ;
    }
    if $(JAVA_COMPILER_DEPRECATED_WARNINGS) = YES {
        JAVAC_FLAGS += "-deprecation" ;
    }
    JAVAC_FLAGS += $(JAVA_COMPILER_FLAGS) ;

    if $(JAVA_COMPILER_TARGET_VM_VERSION) {
        if $(JAVA_COMPILER:B) = jikes {
            ECHO warning: Target VM version not supported by jikes ;
        }
        else {
            JAVAC_FLAGS += "-target "$(JAVA_COMPILER_TARGET_VM_VERSION) ;
        }
    }
    
    if $(JAVA_COMPILER_SOURCE_VERSION) {
        JAVAC_FLAGS += "-source "$(JAVA_COMPILER_SOURCE_VERSION) ;
    }
    
    if $(JAVA_COMPILER_DEBUGGING_SYMBOLS) = YES {
        JAVAC_FLAGS += "-g" ;
    }
    
    if $(JAVAC_SOURCE_FILE_ENCODING) {
        JAVAC_FLAGS += -encoding "$(JAVAC_SOURCE_FILE_ENCODING)" ;
    }

    if $(JAVA_FORCE_FILE_LIST) = "NO" && ( $(JAVA_USE_DEPENDENCIES) = "NO" || ( ! $($(2)_JAVA_IMPORTS) && empty$($(2)_JAVA_IMPORTS) != empty ) ) {
        # With no dependence, or dependence info usage off
        # build with combinded compiler invocations but no file list
        DEPENDS $(JAVA_COMPILE_TARGET) : $(2) ;
        ALWAYS $(JAVA_COMPILE_TARGET) ;
        JAVAC_FLAGS on $(JAVA_COMPILE_TARGET) = $(JAVAC_FLAGS) ;
        JAVA_COMPILER on $(JAVA_COMPILE_TARGET) = $(JAVA_COMPILER) ;
        if $(JAVA_COMPILER:B) = jikes {
	    JavaCompile.jikes $(JAVA_COMPILE_TARGET) : $(2) ;
        }
        else {
	    JavaCompile.default $(JAVA_COMPILE_TARGET) : $(2) ;
        }
        COMPILED_JAVA += $(2) ;
        if ! $(JAVA_COMPILE_TARGET) in $(PRODUCT_FILES) {
            ProductFile $(JAVA_COMPILE_TARGET) ;
        }
    }
    else {
        # Using dependence info, set up file list for java compiles
        JAVA_FILE_LIST default = $(TEMP_DIR)$(/)JavaFileList ;
        # define and act on target to clear list
        if ! $(CLEAR_JAVA_FILE_LIST) {
            CLEAR_JAVA_FILE_LIST = $(JAVA_FILE_LIST:G=ClearFileList) ;
            ClearJavaFileList $(CLEAR_JAVA_FILE_LIST) ;
            DEPENDS $(JAVA_COMPILE_TARGET) : $(CLEAR_JAVA_FILE_LIST) ;
        }
        # set up compile target to use file list
        if ! $(JAVA_COMPILE_TARGET) in $(PRODUCT_FILES) {
            JAVAC_FLAGS on $(JAVA_COMPILE_TARGET) = $(JAVAC_FLAGS) ;
            JAVA_COMPILER on $(JAVA_COMPILE_TARGET) = $(JAVA_COMPILER) ;
            JAVA_FILE_LIST_REFERENCE = @$(JAVA_FILE_LIST) ;
            NOTFILE $(JAVA_FILE_LIST_REFERENCE) ;
            if $(JAVA_COMPILER:B) = jikes {
	        JavaCompile.jikes $(JAVA_COMPILE_TARGET) : $(JAVA_FILE_LIST_REFERENCE) ;
            }
            else {
	        JavaCompile.default $(JAVA_COMPILE_TARGET) : $(JAVA_FILE_LIST_REFERENCE) ;
            }
            ProductFile $(JAVA_COMPILE_TARGET) ;
        }
        # set up class file dependence used to add java files to compile list
        local CLASS_FILE ;
        # use the main class, if it's there
        if $($(2)_MAIN_CLASS) {
            CLASS_FILE = $(CLASS_FILE_DIR)$(/)$($(2)_MAIN_CLASS) ;
        }
        else {
            local JAVA_SOURCE ;
            RemovePrefixPath JAVA_SOURCE : $(JAVA_SOURCE_SUBDIR) : $(2) ;
            CLASS_FILE = $(CLASS_FILE_DIR)$(/)$(JAVA_SOURCE:S=.class) ;
        }
        DEPENDS $(CLASS_FILE) : $(2) ;
        if $($(2)_JAVA_IMPORTS) {
            DEPENDS $(CLASS_FILE) : $($(2)_JAVA_IMPORTS) ;
            DEPENDS $(CLEAR_JAVA_FILE_LIST) : $($(2)_JAVA_IMPORTS) ;
        }
        DEPENDS $(JAVA_COMPILE_TARGET) : $(CLASS_FILE) ;
        JAVA_FILE_LIST on $(CLASS_FILE) = $(JAVA_FILE_LIST) ;
        AppendToJavaFileList $(CLASS_FILE) : $(2) ;
        DEPENDS $(CLEAR_JAVA_FILE_LIST) : $(2) ;
        COMPILED_JAVA += $(2) ;
    }
}

actions quietly together piecemeal ClearJavaFileList
{
    $(RM) -rf $(JAVA_FILE_LIST:Q) && $(TOUCH) $(JAVA_FILE_LIST:Q)
}

# Appends reference to list only if not already present
actions quietly together piecemeal AppendToJavaFileList
{
    _grep_result=`/usr/bin/grep -e \""$(2)"\" $(JAVA_FILE_LIST:Q)`
    if [ "x$_grep_result" = "x" ]
      then $(ECHO) \""$(2)"\" >> $(JAVA_FILE_LIST:Q)
    fi
}

actions together piecemeal JavaCompile.default {
    frameworkjars=""
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath`
    $(JAVA_COMPILER) $(JAVAC_FLAGS) $($(2)_COMPILER_FLAGS) -sourcepath $(JAVA_SOURCE_PATH:Q) -classpath "$classpath" -d "$(CLASS_FILE_DIR)" '$(2)'
}
actions together piecemeal JavaCompile.jikes {
    frameworkjars=""
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath`
    $(JAVA_COMPILER) $(JAVAC_FLAGS) $($(2)_COMPILER_FLAGS) -sourcepath $(JAVA_SOURCE_PATH:Q) -classpath "$classpath" -d $(CLASS_FILE_DIR:Q) '$(2)'
}

rule ProcessApplescripts
{
    if build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : CompileAppleScripts ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        if $(CONTEXTNAME) = ""
        {
            for FILE in $(2) {
                if $(_BUILD_PHASING) = YES {
                    ProcessAppleScript $(BUILD_PHASE) : $(FILE) : $(FILE) ;
                }
                else {
                    ProcessAppleScript $(1) : $(FILE) : $(FILE) ;
                }
            }
        }
        else
        {
            ProcessAppleScript $(1) : $(2) : $(CONTEXTNAME) ;
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

rule ProcessAppleScript
{
    if source in $(BUILD_COMPONENTS) {
        # make directory first if necessary
        if $(2:D) {
            SCRIPT_SOURCE_DIR = $(2:D:G=) ;
            Mkdir $(SCRIPT_SOURCE_DIR) ;
            SCRIPT_SOURCE_COPY = $(SCRIPT_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SCRIPT_SOURCE_COPY) : $(SCRIPT_SOURCE_DIR) ;
        }
        else {
            SCRIPT_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SCRIPT_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        # copy script to source location
        Cp $(SCRIPT_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(SCRIPT_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        if $(2) = $(3) {
            # third argument is a file (ignore subfolder for result)
            APPLESCRIPT_FILE = $(APPLESCRIPTS_DIR)$(/)$(3:BS=.scpt) ;
        }
        else {
            # third argument is a context name
            APPLESCRIPT_FILE = $(APPLESCRIPTS_DIR)$(/)$(3:S=.scpt) ;
        }
        DEPENDS $(APPLESCRIPT_FILE) : $(APPLESCRIPTS_DIR) ;
        if ! $(APPLESCRIPTS_DIR) in $(PRODUCT_FILES) {
            Mkdir $(APPLESCRIPTS_DIR) ;
            ProductFile $(APPLESCRIPTS_DIR) ;
        }
        DEPENDS $(APPLESCRIPT_FILE) : $(2) ;
        OTHER_OSAFLAGS on $(APPLESCRIPT_FILE) = $(OTHER_OSAFLAGS) $($(APPLESCRIPT_FILE)_COMPILER_FLAGS) ;
        OSACompile $(APPLESCRIPT_FILE) : $(2) ;
        ProductFile $(APPLESCRIPT_FILE) ;
    }
}

actions OSACompile
{
    $(OSAC) -d -i $(SYSTEM_LIBRARY_DIR)/Frameworks/AppleScriptKit.framework -U $(2:BSQ) -o $(1:Q) "$(OTHER_OSAFLAGS)" $(2:Q)
}

rule ProcessC
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
            PRODUCT_FILES += $(OBJECT_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_CFLAGS = $(PER_ARCH_CFLAGS_$(ARCH)) ;
        if $(JAVA_BRIDGET_TARGET) {
            DEPENDS $(OBJECT_FILE) : $(JAVA_BRIDGET_TARGET) ;
        }
        OTHER_CFLAGS on $(OBJECT_FILE) = $(OTHER_CFLAGS_$(VARIANT)) ;
        CompileC $(OBJECT_FILE) : $(2) ;
        if $(2:BS) != $(VECTOR_STUB:BS) {
            # add object file to object files and phase products
            # unless it is the compiled generated vector stub
            OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
            }
        }
        LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
        if $(2) = $(MODULE_INFO_FILE) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            # object file is added to linked files
            # unless it is the compiled generated vector stub
            if $(2:BS) != $(VECTOR_STUB:BS) {
                LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            }
        }
    }
    }
}

rule ProcessCplusplus
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_CPLUSPLUSFLAGS_$(ARCH) default = $(PER_ARCH_CFLAGS_$(ARCH)) ;
        PER_ARCH_CPLUSPLUSFLAGS = $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) ;
        OTHER_CPLUSPLUSFLAGS on $(OBJECT_FILE) = $(OTHER_CPLUSPLUSFLAGS_$(VARIANT)) ;
        CompileCplusplus $(OBJECT_FILE) : $(2) ;
        OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
        OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
        }
        if $(2) = $(MODULE_INFO_FILE_$(VARIANT)) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
            LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
        }
    }
    }
}

HDRPATTERN = "^[	 ]*#[	 ]*include[	 ]*[<\"](.*)[\">].*$" ;
HDRPATTERN += "^[	 ]*#[	 ]*import[	 ]*[<\"](.*)[\">].*$" ;

rule ProcessC.HdrRule
{
    # header reference in subdirectory source may be to header in that subdirectory
    local LOCAL_HEADERS = $(2:D=$(1:D)) ;
    # or header reference may be to elsewhere
    local FOREIGN_HEADERS = $(2) ;
    # compiled sources may include headers in subdirectories
    INCLUDES $(1) : $(LOCAL_HEADERS) $(FOREIGN_HEADERS) ;
}

rule CompileC
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_FRAMEWORK)/PrivateHeaders $(KERNEL_HEADERS) ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(2:S) = ".m" {
	# DO NOT USE THE FOLLOWING BUILD SETTINGS!
        if $(GCC_FAST_OBJC_DISPATCH) = YES {
            FLAGS on $(1) += -fobjc-direct-dispatch ;
        }
        if $(GCC_ENABLE_OBJC_GC) = YES {
            FLAGS on $(1) += -fobjc-gc ;
        }
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(GCC_VERSION) != 4.0 && $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    # Pass headermap and/or header symlinks directory.
    if $(CPP_HEADERMAP_FILE) {
        if $(GCC_VERSION) <= 3.3 {
            CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
        }
        else if $(GCC_VERSION) >= 4.0 {
            CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
        }
        else {
            ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
        }
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(INDEX_GENERATION_PIPE_NAME) != "" {
        FLAGS on $(1) += "-fgen-index=$(INDEX_GENERATION_PIPE_NAME)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            if $(PREFIX_HEADER_CFLAGS_BASE) = -include {
                # GCC v3.3 / v3.5 / v4.0 PCH
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH):S=)" ;            
            }
            else {
                # GCC v3.1 PFE
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
            }
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
            }
        }
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            # GCC v2.95.2 cpp-precomp
            PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
            }
        }
    }
}

actions CompileC
{
    $(CC) -c $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_CFLAGS)" $($(2)_COMPILER_FLAGS) $(2:Q) -o $(1:Q)
}

rule CompileCplusplus
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_FRAMEWORK)/PrivateHeaders $(KERNEL_HEADERS) ;
        if $(GCC_VERSION) != 2.x {
            KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -fno-rtti -fno-exceptions -fcheck-new -msoft-float -fapple-kext ;
        }
        else {
            KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -fno-rtti -fno-exceptions -fcheck-new -fvtable-thunks -msoft-float ;
            if $(MODULE_IOKIT) = YES {
                KERNEL_COMPILE_OPTIONS += -findirect-virtual-calls ;
            }
        }
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) ;
        if $(2:S) = .CPP {
            FLAGS on $(1) += -x c++ ;
        }
    }
    FLAGS on $(1) += -pipe ;
    if ( $(GCC_VERSION) != 2.x ) {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CC_FLAGS) ;
    # Add variant-specific flags
    local _VARIANT_FLAGS = $($(CC:BS)_$(VARIANT)_FLAGS) ;
    if $(_VARIANT_FLAGS) {
        FLAGS on $(1) += $(_VARIANT_FLAGS) ;
    }
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(2:S) = ".mm" || $(2:S) = ".M" {
	# DO NOT USE THE FOLLOWING BUILD SETTINGS!
        if $(GCC_FAST_OBJC_DISPATCH) = YES {
            FLAGS on $(1) += -fobjc-direct-dispatch ;
        }
        if $(GCC_ENABLE_OBJC_GC) = YES {
            FLAGS on $(1) += -fobjc-gc ;
        }
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(GCC_VERSION) != 4.0 && $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    # Pass headermap and/or header symlinks directory.
    if $(CPP_HEADERMAP_FILE) {
        if $(GCC_VERSION) <= 3.3 {
            CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
        }
        else if $(GCC_VERSION) >= 4.0 {
            CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
        }
        else {
            ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
        }
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            if $(PREFIX_HEADER_CFLAGS_BASE) = -include {
                # GCC v3.3 / v3.5 / v4.0 PCH
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH):S=)" ;            
            }
            else {
                # GCC v3.1 PFE
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
            }
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
            }
        }
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            # GCC v2.95.2 cpp-precomp
            PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
            }
        }
    }
    _LD_FOR_LINKING = $(LDPLUSPLUS) ;
}

actions CompileCplusplus
{
    $(CPLUSPLUS) -c $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_CFLAGS:Q) "$(OTHER_CPLUSPLUSFLAGS)" $($(2)_COMPILER_FLAGS) $(2:Q) -o $(1:Q)
}

rule ProcessAssembly
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
            PRODUCT_FILES += $(OBJECT_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_ASFLAGS = $(PER_ARCH_ASFLAGS_$(ARCH)) ;
        if $(JAVA_BRIDGET_TARGET) {
            DEPENDS $(OBJECT_FILE) : $(JAVA_BRIDGET_TARGET) ;
        }
        OTHER_ASFLAGS on $(OBJECT_FILE) = $(OTHER_ASFLAGS) $(OTHER_ASFLAGS_$(VARIANT)) ;
        CompileC $(OBJECT_FILE) : $(2) ;
        if $(2:BS) != $(VECTOR_STUB:BS) {
            # add object file to object files and phase products
            # unless it is the compiled generated vector stub
            OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
            }
        }
        LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
        if $(2) = $(MODULE_INFO_FILE) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            # object file is added to linked files
            # unless it is the compiled generated vector stub
            if $(2:BS) != $(VECTOR_STUB:BS) {
                LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            }
        }
    }
    }
}

rule CompileAssembly
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_FRAMEWORK)/PrivateHeaders $(KERNEL_HEADERS) ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_ASFLAGS) -fno-common -nostdinc $(OPTIMIZATION_ASFLAGS) $(WARNING_ASFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_ASFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_ASFLAGS) $(WARNING_ASFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add variant-specific flags
    local _VARIANT_FLAGS = $($(CC:BS)_$(VARIANT)_FLAGS) ;
    if $(_VARIANT_FLAGS) {
        FLAGS on $(1) += $(_VARIANT_FLAGS) ;
    }
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(GCC_VERSION) != 4.0 && $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    # Pass headermap and/or header symlinks directory.
    if $(CPP_HEADERMAP_FILE) {
        if $(GCC_VERSION) <= 3.3 {
            CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
        }
        else if $(GCC_VERSION) >= 4.0 {
            CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
        }
        else {
            ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
        }
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(INDEX_GENERATION_PIPE_NAME) != "" {
        FLAGS on $(1) += "-fgen-index=$(INDEX_GENERATION_PIPE_NAME)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            if $(PREFIX_HEADER_CFLAGS_BASE) = -include {
                # GCC v3.3 / v3.5 / v4.0 PCH
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH):S=)" ;            
            }
            else {
                # GCC v3.1 PFE
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
            }
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
            }
        }
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            # GCC v2.95.2 cpp-precomp
            PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
            }
        }
    }
}

actions CompileAssembly
{
    $(CC) -c $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_ASFLAGS:Q) "$(OTHER_ASFLAGS)" $($(2)_COMPILER_FLAGS) $(2:Q) -o $(1:Q)
}


rule ProcessFortran
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
            PRODUCT_FILES += $(OBJECT_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_FFLAGS = $(PER_ARCH_FFLAGS_$(ARCH)) ;
        if $(JAVA_BRIDGET_TARGET) {
            DEPENDS $(OBJECT_FILE) : $(JAVA_BRIDGET_TARGET) ;
        }
        OTHER_FFLAGS on $(OBJECT_FILE) = $(OTHER_FFLAGS) $(OTHER_FFLAGS_$(VARIANT)) ;
        CompileFortran $(OBJECT_FILE) : $(2) ;
        if $(2:BS) != $(VECTOR_STUB:BS) {
            # add object file to object files and phase products
            # unless it is the compiled generated vector stub
            OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
            }
        }
        LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
        if $(2) = $(MODULE_INFO_FILE) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            # object file is added to linked files
            # unless it is the compiled generated vector stub
            if $(2:BS) != $(VECTOR_STUB:BS) {
                LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            }
        }
    }
    }
}

rule CompileFortran
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_FRAMEWORK)/PrivateHeaders $(KERNEL_HEADERS) ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_FFLAGS) -fno-common -nostdinc $(OPTIMIZATION_FFLAGS) $(WARNING_FFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_FFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_FFLAGS) $(WARNING_FFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if $(GCC_VERSION) != 2.x {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    if $(GCC_TREAT_WARNINGS_AS_ERRORS) = YES {
        FLAGS on $(1) += -Werror ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_FFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(GCC_VERSION) != 3.3 && $(GCC_VERSION) != 3.5 && $(GCC_VERSION) != 4.0 && $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    # Pass headermap and/or header symlinks directory.
    if $(CPP_HEADERMAP_FILE) {
        if $(GCC_VERSION) <= 3.3 {
            CPP_HEADERMAP_FLAGS on $(1) = -Wp,-header-mapfile,$(CPP_HEADERMAP_FILE) ;
        }
        else if $(GCC_VERSION) >= 4.0 {
            CPP_HEADERMAP_FLAGS on $(1) = -I$(CPP_HEADERMAP_FILE) ;
        }
        else {
            ECHO jam: warning: GCC v$(GCC_VERSION) does not support headermaps ;
        }
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(INDEX_GENERATION_PIPE_NAME) != "" {
        FLAGS on $(1) += "-fgen-index=$(INDEX_GENERATION_PIPE_NAME)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            if $(PREFIX_HEADER_CFLAGS_BASE) = -include {
                # GCC v3.3 / v3.5 / v4.0 PCH
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH):S=)" ;            
            }
            else {
                # GCC v3.1 PFE
                PREFIX_HEADER_CFLAGS on $(1) = $(PREFIX_HEADER_CFLAGS_BASE) "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
            }
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
            }
        }
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        if $($(2)_COMPILER_FLAGS) {
            # When per-file flags are used the precompiled header is not valid
            FLAGS on $(1) += -include "$(PREFIX_HEADER)" ;
        }
        else {
            # GCC v2.95.2 cpp-precomp
            PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
            if $(ENABLE_PREFIX_HEADER_DEPENDENCIES) != NO {
                DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
            }
        }
    }
}

actions CompileFortran
{
    $(CC) -c $(CPP_HEADERMAP_FLAGS:Q) -I$(CPP_HEADER_SYMLINKS_DIR:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) $(FLAGS:Q) $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_FFLAGS:Q) "$(OTHER_FFLAGS)" $($(2)_COMPILER_FLAGS) $(2:Q) -o $(1:Q)
}

VECTOR_SUFFIX default = ;
rule ProcessExportsFile
{
    if $(CFM_BRIDGE) = YES {
        local DYLIB_INSTALLED_NAME ;
        VECTOR_STUB default = $(DERIVED_FILE_DIR)$(/)$(1:B)Vector.s ;
        VECTOR_OBJECT_FILE default = $(TEMP_DIR)$(/)$(1:B)Vector.o ;
        if $(VECTOR_SUFFIX) {
            VECTOR_FRAGMENT_NAME default = CFMPriv_$(1:B)$(VECTOR_SUFFIX) ;
        }
        else {
            VECTOR_FRAGMENT_NAME default = CFMPriv_$(1:B) ;
        }
        DEPENDS $(VECTOR_STUB) : $(CURRENT_VERSION_DIR) ;
        DEPENDS $(VECTOR_STUB) : $(DERIVED_FILE_DIR) ;
        Mkdir $(CURRENT_VERSION_DIR) ;
        if $(INSTALL_PATH) {
            DYLIB_INSTALLED_NAME default = $(INSTALL_PATH)$(/)$(1:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)$(1:B:G=) ;
            if $(DYNAMIC_LIBRARY_SUFFIX) {
                DYLIB_INSTALLED_NAME = $(DYLIB_INSTALLED_NAME)$(DYNAMIC_LIBRARY_SUFFIX) ;
            }
        }
        DYLIB_INSTALLED_NAME on $(1) = $(DYLIB_INSTALLED_NAME) ;
        GenerateVectorLibraryIntermediates $(VECTOR_STUB) $(VECTOR_OBJECT_FILE) : $(2) ;
        BUILD_PHASE_PRODUCTS += $(VECTOR_STUB) ;
    }
}

rule ProcessUsingMig
{
    local TEMP_FILES ;
    local FILE_BASE = $(2:B) ;

     if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    if Client in $($(2)_ATTRIBUTES) {
        TEMP_FILES = $(FILE_BASE)User.c $(FILE_BASE).h ;
    }
    if Server in $($(2)_ATTRIBUTES) {
        TEMP_FILES += $(FILE_BASE)Server.c $(FILE_BASE)Server.h ;
    }
    if Client in $($(2)_ATTRIBUTES) || Server in $($(2)_ATTRIBUTES) {
        Mig $(TEMP_FILES) : $(2) ;
        DerivedFiles $(TEMP_FILES) ;
        DERIVED_FILES += $(TEMP_FILES) ;
        ProcessFiles $(1) : $(TEMP_FILES) ;
    }
}

rule ProcessUsingLex
{
    local TEMP_FILES ;
    local FILE_BASE = $(2:B) ;

    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    switch $(2:S) {
        case ".l" : TEMP_FILES += $(FILE_BASE).c ;
        case ".lm" : TEMP_FILES += $(FILE_BASE).m ;
        case ".LM" : TEMP_FILES += $(FILE_BASE).M ;
        case ".lmm" : TEMP_FILES += $(FILE_BASE).mm ;
        case ".lpp" : TEMP_FILES += $(FILE_BASE).cpp ;
        case ".LPP" : TEMP_FILES += $(FILE_BASE).CPP ;
        case ".lxx" : TEMP_FILES += $(FILE_BASE).cxx ;
        case ".LXX" : TEMP_FILES += $(FILE_BASE).CXX ;
    }
    DEPENDS $(TEMP_FILES) : $(DERIVED_FILE_DIR) ;
    Lex $(TEMP_FILES) : $(2) ;
    DerivedFiles $(TEMP_FILES) ;
    DERIVED_FILES += $(TEMP_FILES) ;
    ProcessFiles $(1) : $(TEMP_FILES) ;
}

rule ProcessUsingYacc
{
    local TEMP_FILES ;
    local FILE_BASE = $(2:B) ;

    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    switch $(2:S) {
        case ".y" : TEMP_FILES += $(FILE_BASE).c ;
        case ".ym" : TEMP_FILES += $(FILE_BASE).m ;
        case ".YM" : TEMP_FILES += $(FILE_BASE).M ;
        case ".ymm" : TEMP_FILES += $(FILE_BASE).mm ;
        case ".ypp" : TEMP_FILES += $(FILE_BASE).cpp ;
        case ".YPP" : TEMP_FILES += $(FILE_BASE).CPP ;
        case ".yxx" : TEMP_FILES += $(FILE_BASE).cxx ;
        case ".YXX" : TEMP_FILES += $(FILE_BASE).CXX ;
    }
    TEMP_FILES += $(FILE_BASE).h ;
    DEPENDS $(TEMP_FILES) : $(DERIVED_FILE_DIR) ;
    Yacc $(TEMP_FILES) : $(2) ;
    DerivedFiles $(TEMP_FILES) ;
    DERIVED_FILES += $(TEMP_FILES) ;
    ProcessFiles $(1) : $(TEMP_FILES) ;
}

rule ProcessUsingRPCGen
{
    local FILE_BASE = $(2:B) ;

    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    local TEMP_FILES = $(FILE_BASE)_xdr.c $(FILE_BASE).h ;
    DEPENDS $(TEMP_FILES) : $(DERIVED_FILE_DIR) ;
    RPCGen $(TEMP_FILES) : $(2) ;
    DerivedFiles $(TEMP_FILES) ;
    DERIVED_FILES += $(TEMP_FILES) ;
    ProcessFiles $(1) : $(TEMP_FILES) ;
}

rule ProcessUsingBridget
{
    Bridget $(1) : $(2) ;
}
