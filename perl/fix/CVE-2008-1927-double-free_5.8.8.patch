--- embed.fnc.orig	2006-01-31 06:40:27.000000000 -0800
+++ embed.fnc	2008-07-11 11:49:50.000000000 -0700
@@ -1168,6 +1168,7 @@
 Es	|regnode*|regclass	|NN struct RExC_state_t *state
 ERs	|I32	|regcurly	|NN const char *
 Es	|regnode*|reg_node	|NN struct RExC_state_t *state|U8 op
+Es	|UV	|reg_recode	|const char value|NULLOK SV **encp
 Es	|regnode*|regpiece	|NN struct RExC_state_t *state|NN I32 *flagp
 Es	|void	|reginsert	|NN struct RExC_state_t *state|U8 op|NN regnode *opnd
 Es	|void	|regoptail	|NN struct RExC_state_t *state|NN regnode *p|NN regnode *val
--- embed.h.orig	2006-01-31 07:50:34.000000000 -0800
+++ embed.h	2008-07-11 11:51:59.000000000 -0700
@@ -1234,6 +1234,7 @@
 #define regclass		S_regclass
 #define regcurly		S_regcurly
 #define reg_node		S_reg_node
+#define reg_recode		S_reg_recode
 #define regpiece		S_regpiece
 #define reginsert		S_reginsert
 #define regoptail		S_regoptail
@@ -3277,6 +3278,7 @@
 #define regclass(a)		S_regclass(aTHX_ a)
 #define regcurly(a)		S_regcurly(aTHX_ a)
 #define reg_node(a,b)		S_reg_node(aTHX_ a,b)
+#define reg_recode(a,b)		S_reg_recode(aTHX_ a,b)
 #define regpiece(a,b)		S_regpiece(aTHX_ a,b)
 #define reginsert(a,b,c)	S_reginsert(aTHX_ a,b,c)
 #define regoptail(a,b,c)	S_regoptail(aTHX_ a,b,c)
--- MANIFEST.orig	2006-01-31 15:27:53.000000000 -0800
+++ MANIFEST	2008-07-11 11:54:25.000000000 -0700
@@ -2905,13 +2905,15 @@
 t/uni/chomp.t			See if Unicode chomp works
 t/uni/class.t			See if Unicode classes work (\p)
 t/uni/fold.t			See if Unicode folding works
+t/uni/greek.t			See if Unicode in greek works
+t/uni/latin2.t			See if Unicode in latin2 works
 t/uni/lower.t			See if Unicode casing works
 t/uni/sprintf.t			See if Unicode sprintf works
 t/uni/title.t			See if Unicode casing works
-t/uni/tr_7jis.t			See if Unicode tr/// works
-t/uni/tr_eucjp.t		See if Unicode tr/// works
-t/uni/tr_sjis.t			See if Unicode tr/// works
-t/uni/tr_utf8.t			See if Unicode tr/// works
+t/uni/tr_7jis.t			See if Unicode tr/// in 7jis works
+t/uni/tr_eucjp.t		See if Unicode tr/// in eucjp works
+t/uni/tr_sjis.t			See if Unicode tr/// in sjis works
+t/uni/tr_utf8.t			See if Unicode tr/// in utf8 works
 t/uni/upper.t			See if Unicode casing works
 t/uni/write.t			See if Unicode formats work
 t/win32/getosversion.t		Test if Win32::GetOSVersion() works
--- pod/perldiag.pod.orig	2006-01-06 15:16:08.000000000 -0800
+++ pod/perldiag.pod	2008-07-11 11:44:18.000000000 -0700
@@ -1900,6 +1900,15 @@
 (W printf) Perl does not understand the given format conversion.  See
 L<perlfunc/sprintf>.
 
+=item Invalid escape in the specified encoding in regex; marked by <-- HERE in m/%s/
+
+(W regexp) The numeric escape (for example C<\xHH>) of value < 256
+didn't correspond to a single character through the conversion
+from the encoding specified by the encoding pragma.
+The escape was replaced with REPLACEMENT CHARACTER (U+FFFD) instead.
+The <-- HERE shows in the regular expression about where the
+escape was discovered.
+
 =item Invalid [] range "%s" in regex; marked by <-- HERE in m/%s/
 
 (F) The range specified in a character class had a minimum character
--- proto.h.orig	2006-01-31 07:50:34.000000000 -0800
+++ proto.h	2008-07-11 11:56:44.000000000 -0700
@@ -1748,6 +1748,7 @@
 			__attribute__warn_unused_result__;
 
 STATIC regnode*	S_reg_node(pTHX_ struct RExC_state_t *state, U8 op);
+STATIC UV	S_reg_recode(pTHX_ const char value, SV **encp);
 STATIC regnode*	S_regpiece(pTHX_ struct RExC_state_t *state, I32 *flagp);
 STATIC void	S_reginsert(pTHX_ struct RExC_state_t *state, U8 op, regnode *opnd);
 STATIC void	S_regoptail(pTHX_ struct RExC_state_t *state, regnode *p, regnode *val);
--- regcomp.c.orig	2006-01-08 12:59:27.000000000 -0800
+++ regcomp.c	2008-07-11 12:07:52.000000000 -0700
@@ -2774,6 +2774,41 @@
     return(ret);
 }
 
+
+/*
+ * reg_recode
+ *
+ * It returns the code point in utf8 for the value in *encp.
+ *    value: a code value in the source encoding
+ *    encp:  a pointer to an Encode object
+ *
+ * If the result from Encode is not a single character,
+ * it returns U+FFFD (Replacement character) and sets *encp to NULL.
+ */
+STATIC UV
+S_reg_recode(pTHX_ const char value, SV **encp)
+{
+    STRLEN numlen = 1;
+    SV * const sv = sv_2mortal(newSVpvn(&value, numlen));
+    const char * const s = encp && *encp ? sv_recode_to_utf8(sv, *encp)
+					 : SvPVX(sv);
+    const STRLEN newlen = SvCUR(sv);
+    UV uv = UNICODE_REPLACEMENT;
+
+    if (newlen)
+	uv = SvUTF8(sv)
+	     ? utf8n_to_uvchr((U8*)s, newlen, &numlen, ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANYUV)
+	     : *(U8*)s;
+
+    if (!newlen || numlen != newlen) {
+	uv = UNICODE_REPLACEMENT;
+	if (encp)
+	    *encp = NULL;
+    }
+    return uv;
+}
+
+
 /*
  - regatom - the lowest level
  *
@@ -3166,6 +3201,8 @@
 			    ender = grok_hex(p, &numlen, &flags, NULL);
 			    p += numlen;
 			}
+			if (PL_encoding && ender < 0x100)
+			    goto recode_encoding;
 			break;
 		    case 'c':
 			p++;
@@ -3185,6 +3222,17 @@
 			    --p;
 			    goto loopdone;
 			}
+			if (PL_encoding && ender < 0x100)
+			    goto recode_encoding;
+			break;
+		    recode_encoding:
+			{
+			    SV* enc = PL_encoding;
+			    ender = reg_recode((const char)(U8)ender, &enc);
+			    if (!enc && SIZE_ONLY && ckWARN(WARN_REGEXP))
+				vWARN(p, "Invalid escape in the specified encoding");
+			    RExC_utf8 = 1;
+			}
 			break;
 		    case '\0':
 			if (p >= RExC_end)
@@ -3315,32 +3363,6 @@
 	break;
     }
 
-    /* If the encoding pragma is in effect recode the text of
-     * any EXACT-kind nodes. */
-    if (PL_encoding && PL_regkind[(U8)OP(ret)] == EXACT) {
-	STRLEN oldlen = STR_LEN(ret);
-	SV *sv        = sv_2mortal(newSVpvn(STRING(ret), oldlen));
-
-	if (RExC_utf8)
-	    SvUTF8_on(sv);
-	if (sv_utf8_downgrade(sv, TRUE)) {
-	    const char * const s = sv_recode_to_utf8(sv, PL_encoding);
-	    const STRLEN newlen = SvCUR(sv);
-
-	    if (SvUTF8(sv))
-		RExC_utf8 = 1;
-	    if (!SIZE_ONLY) {
-		DEBUG_r(PerlIO_printf(Perl_debug_log, "recode %*s to %*s\n",
-				      (int)oldlen, STRING(ret),
-				      (int)newlen, s));
-		Copy(s, STRING(ret), newlen, char);
-		STR_LEN(ret) += newlen - oldlen;
-		RExC_emit += STR_SZ(newlen) - STR_SZ(oldlen);
-	    } else
-		RExC_size += STR_SZ(newlen) - STR_SZ(oldlen);
-	}
-    }
-
     return(ret);
 }
 
@@ -3718,6 +3740,8 @@
 		    value = grok_hex(RExC_parse, &numlen, &flags, NULL);
 		    RExC_parse += numlen;
 		}
+		if (PL_encoding && value < 0x100)
+		    goto recode_encoding;
 		break;
 	    case 'c':
 		value = UCHARAT(RExC_parse++);
@@ -3725,13 +3749,24 @@
 		break;
 	    case '0': case '1': case '2': case '3': case '4':
 	    case '5': case '6': case '7': case '8': case '9':
-            {
-                I32 flags = 0;
-		numlen = 3;
-		value = grok_oct(--RExC_parse, &numlen, &flags, NULL);
-		RExC_parse += numlen;
-		break;
-            }
+		{
+		    I32 flags = 0;
+		    numlen = 3;
+		    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);
+		    RExC_parse += numlen;
+		    if (PL_encoding && value < 0x100)
+			goto recode_encoding;
+		    break;
+		}
+	    recode_encoding:
+		{
+		    SV* enc = PL_encoding;
+		    value = reg_recode((const char)(U8)value, &enc);
+		    if (!enc && SIZE_ONLY && ckWARN(WARN_REGEXP))
+			vWARN(RExC_parse,
+			      "Invalid escape in the specified encoding");
+		    break;
+		}
 	    default:
 		if (!SIZE_ONLY && isALPHA(value) && ckWARN(WARN_REGEXP))
 		    vWARN2(RExC_parse,
--- t/uni/greek.t.orig	2008-07-11 11:44:18.000000000 -0700
+++ t/uni/greek.t	2008-07-11 11:44:18.000000000 -0700
@@ -0,0 +1,119 @@
+BEGIN {
+    if ($ENV{'PERL_CORE'}){
+        chdir 't';
+        @INC = '../lib';
+    }
+    require Config; import Config;
+    if ($Config{'extensions'} !~ /\bEncode\b/) {
+      print "1..0 # Skip: Encode was not built\n";
+      exit 0;
+    }
+    if (ord("A") == 193) {
+        print "1..0 # Skip: EBCDIC\n";
+        exit 0;
+    }
+    unless (PerlIO::Layer->find('perlio')){
+        print "1..0 # Skip: PerlIO required\n";
+        exit 0;
+    }
+    if ($ENV{PERL_CORE_MINITEST}) {
+        print "1..0 # Skip: no dynamic loading on miniperl, no Encode\n";
+        exit 0;
+    }
+    $| = 1;
+    require './test.pl';
+}
+
+plan tests => 72;
+
+use encoding "greek"; # iso 8859-7
+
+# U+0391, \xC1, \301, GREEK CAPITAL LETTER ALPHA
+# U+03B1, \xE1, \341, GREEK SMALL LETTER ALPHA
+
+ok("\xC1"    =~ /\xC1/,     '\xC1 to /\xC1/');
+ok("\x{391}" =~ /\xC1/,     '\x{391} to /\xC1/');
+ok("\xC1"    =~ /\x{C1}/,   '\xC1 to /\x{C1}/');
+ok("\x{391}" =~ /\x{C1}/,   '\x{391} to /\x{C1}/');
+ok("\xC1"    =~ /\301/,     '\xC1 to /\301/');
+ok("\x{391}" =~ /\301/,     '\x{391} to /\301/');
+ok("\xC1"    =~ /\x{391}/,  '\xC1 to /\x{391}/');
+ok("\x{391}" =~ /\x{391}/,  '\x{391} to /\x{391}/');
+
+ok("\xC1"    =~ /\xC1/i,    '\xC1 to /\xC1/i');
+ok("\xE1"    =~ /\xC1/i,    '\xE1 to /\xC1/i');
+ok("\xC1"    =~ /\xE1/i,    '\xC1 to /\xE1/i');
+ok("\xE1"    =~ /\xE1/i,    '\xE1 to /\xE1/i');
+ok("\xC1"    =~ /\x{391}/i, '\xC1 to /\x{391}/i');
+ok("\xE1"    =~ /\x{391}/i, '\xE1 to /\x{391}/i');
+ok("\xC1"    =~ /\x{3B1}/i, '\xC1 to /\x{3B1}/i');
+ok("\xE1"    =~ /\x{3B1}/i, '\xE1 to /\x{3B1}/i');
+
+ok("\xC1"    =~ /[\xC1]/,     '\xC1 to /[\xC1]/');
+ok("\x{391}" =~ /[\xC1]/,     '\x{391} to /[\xC1]/');
+ok("\xC1"    =~ /[\x{C1}]/,   '\xC1 to /[\x{C1}]/');
+ok("\x{391}" =~ /[\x{C1}]/,   '\x{391} to /[\x{C1}]/');
+ok("\xC1"    =~ /[\301]/,     '\xC1 to /[\301]/');
+ok("\x{391}" =~ /[\301]/,     '\x{391} to /[\301]/');
+ok("\xC1"    =~ /[\x{391}]/,  '\xC1 to /[\x{391}]/');
+ok("\x{391}" =~ /[\x{391}]/,  '\x{391} to /[\x{391}]/');
+
+ok("\xC1"    =~ /[\xC1]/i,    '\xC1 to /[\xC1]/i');
+ok("\xE1"    =~ /[\xC1]/i,    '\xE1 to /[\xC1]/i');
+ok("\xC1"    =~ /[\xE1]/i,    '\xC1 to /[\xE1]/i');
+ok("\xE1"    =~ /[\xE1]/i,    '\xE1 to /[\xE1]/i');
+ok("\xC1"    =~ /[\x{391}]/i, '\xC1 to /[\x{391}]/i');
+ok("\xE1"    =~ /[\x{391}]/i, '\xE1 to /[\x{391}]/i');
+ok("\xC1"    =~ /[\x{3B1}]/i, '\xC1 to /[\x{3B1}]/i');
+ok("\xE1"    =~ /[\x{3B1}]/i, '\xE1 to /[\x{3B1}]/i');
+
+ok("\xC1"    =~ '\xC1',       '\xC1 to \'\xC1\'');
+ok("\xC1"    =~ '\x{C1}',     '\xC1 to \'\x{C1}\'');
+ok("\xC1"    =~ '\301',       '\xC1 to \'\301\'');
+ok("\xC1"    =~ '\x{391}',    '\xC1 to \'\x{391}\'');
+ok("\xC1"    =~ '[\xC1]',     '\xC1 to \'[\xC1]\'');
+ok("\xC1"    =~ '[\x{C1}]',   '\xC1 to \'[\x{C1}]\'');
+ok("\xC1"    =~ '[\301]',     '\xC1 to \'[\301]\'');
+ok("\xC1"    =~ '[\x{391}]',  '\xC1 to \'[\x{391}]\'');
+
+ok("\xC1"    =~ /¡/,     '\xC1 to /<ALPHA>/');
+ok("\xE1"    !~ /¡/,     '\xE1 to /<ALPHA>/');
+ok("\xC1"    =~ /¡/i,    '\xC1 to /<ALPHA>/i');
+ok("\xE1"    =~ /¡/i,    '\xE1 to /<ALPHA>/i');
+ok("\xC1"    =~ /[¡]/,   '\xC1 to /[<ALPHA>]/');
+ok("\xE1"    !~ /[¡]/,   '\xE1 to /[<ALPHA>]/');
+ok("\xC1"    =~ /[¡]/i,  '\xC1 to /[<ALPHA>]/i');
+ok("\xE1"    =~ /[¡]/i,  '\xE1 to /[<ALPHA>]/i');
+
+ok("\xC1\xC1"  =~ /¡\xC1/,    '\xC1\xC1 to /<ALPHA>\xC1/');
+ok("\xC1\xC1"  =~ /\xC1¡/,    '\xC1\xC1 to /\xC1<ALPHA>/');
+ok("\xC1\xC1"  =~ /¡\xC1/i,   '\xC1\xC1 to /<ALPHA>\xC1/i');
+ok("\xC1\xC1"  =~ /\xC1¡/i,   '\xC1\xC1 to /\xC1<ALPHA>/i');
+ok("\xC1\xE1"  =~ /¡\xC1/i,   '\xC1\xE1 to /<ALPHA>\xC1/i');
+ok("\xC1\xE1"  =~ /\xC1¡/i,   '\xC1\xE1 to /\xC1<ALPHA>/i');
+ok("\xE1\xE1"  =~ /¡\xC1/i,   '\xE1\xE1 to /<ALPHA>\xC1/i');
+ok("\xE1\xE1"  =~ /\xC1¡/i,   '\xE1\xE1 to /\xC1<ALPHA>/i');
+
+# U+038A, \xBA, GREEK CAPITAL LETTER IOTA WITH TONOS
+# U+03AF, \xDF, GREEK SMALL LETTER IOTA WITH TONOS
+
+ok("\x{38A}"  =~ /\xBA/,      '\x{38A} to /\xBA/');
+ok("\x{38A}"  !~ /\xDF/,      '\x{38A} to /\xDF/');
+ok("\x{38A}"  =~ /\xBA/i,     '\x{38A} to /\xBA/i');
+ok("\x{38A}"  =~ /\xDF/i,     '\x{38A} to /\xDF/i');
+ok("\x{38A}"  =~ /[\xBA]/,    '\x{38A} to /[\xBA]/');
+ok("\x{38A}"  !~ /[\xDF]/,    '\x{38A} to /[\xDF]/');
+ok("\x{38A}"  =~ /[\xBA]/i,   '\x{38A} to /[\xBA]/i');
+ok("\x{38A}"  =~ /[\xDF]/i,   '\x{38A} to /[\xDF]/i');
+
+# \xDF is not LATIN SMALL LETTER SHARP S
+
+ok("SS"   !~ /\xDF/i,   'SS to /\xDF/i');
+ok("Ss"   !~ /\xDF/i,   'Ss to /\xDF/i');
+ok("sS"   !~ /\xDF/i,   'sS to /\xDF/i');
+ok("ss"   !~ /\xDF/i,   'ss to /\xDF/i');
+ok("SS"   !~ /ﬂ/i,      'SS to /<iota-tonos>/i');
+ok("Ss"   !~ /ﬂ/i,      'Ss to /<iota-tonos>/i');
+ok("sS"   !~ /ﬂ/i,      'sS to /<iota-tonos>/i');
+ok("ss"   !~ /ﬂ/i,      'ss to /<iota-tonos>/i');
+
--- t/uni/latin2.t.orig	2008-07-11 11:44:18.000000000 -0700
+++ t/uni/latin2.t	2008-07-11 11:44:18.000000000 -0700
@@ -0,0 +1,153 @@
+BEGIN {
+    if ($ENV{'PERL_CORE'}){
+        chdir 't';
+        @INC = '../lib';
+    }
+    require Config; import Config;
+    if ($Config{'extensions'} !~ /\bEncode\b/) {
+      print "1..0 # Skip: Encode was not built\n";
+      exit 0;
+    }
+    if (ord("A") == 193) {
+        print "1..0 # Skip: EBCDIC\n";
+        exit 0;
+    }
+    unless (PerlIO::Layer->find('perlio')){
+        print "1..0 # Skip: PerlIO required\n";
+        exit 0;
+    }
+    if ($ENV{PERL_CORE_MINITEST}) {
+        print "1..0 # Skip: no dynamic loading on miniperl, no Encode\n";
+        exit 0;
+    }
+    $| = 1;
+    require './test.pl';
+}
+
+plan tests => 94;
+
+use encoding "latin2"; # iso 8859-2
+
+# U+00C1, \xC1, \301, LATIN CAPITAL LETTER A WITH ACUTE
+# U+0102, \xC3, \402, LATIN CAPITAL LETTER A WITH BREVE
+# U+00E1, \xE1, \303, LATIN SMALL LETTER A WITH ACUTE
+# U+0103, \xE3, \403, LATIN SMALL LETTER A WITH BREVE
+
+ok("\xC1"    =~ /\xC1/,     '\xC1 to /\xC1/');
+ok("\x{C1}"  =~ /\x{C1}/,   '\x{C1} to /\x{C1}/');
+ok("\xC3"    =~ /\xC3/,     '\xC3 to /\xC3/');
+ok("\x{102}" =~ /\xC3/,     '\x{102} to /\xC3/');
+ok("\xC3"    =~ /\x{C3}/,   '\xC3 to /\x{C3}/');
+ok("\x{102}" =~ /\x{C3}/,   '\x{102} to /\x{C3}/');
+ok("\xC3"    =~ /\x{102}/,  '\xC3 to /\x{102}/');
+ok("\x{102}" =~ /\x{102}/,  '\x{102} to /\x{102}/');
+
+ok("\xC1"    =~ /\xC1/i,    '\xC1 to /\xC1/i');
+ok("\xE1"    =~ /\xC1/i,    '\xE1 to /\xC1/i');
+ok("\xC1"    =~ /\xE1/i,    '\xC1 to /\xE1/i');
+ok("\xE1"    =~ /\xE1/i,    '\xE1 to /\xE1/i');
+ok("\x{102}" =~ /\xC3/i,    '\x{102} to /\xC3/i');
+ok("\x{103}" =~ /\xC3/i,    '\x{103} to /\xC3/i');
+ok("\x{102}" =~ /\xE3/i,    '\x{102} to /\xE3/i');
+ok("\x{103}" =~ /\xE3/i,    '\x{103} to /\xE3/i');
+
+ok("\xC1"    =~ /[\xC1]/,     '\xC1 to /[\xC1]/');
+ok("\x{C1}"  =~ /[\x{C1}]/,   '\x{C1} to /[\x{C1}]/');
+ok("\xC3"    =~ /[\xC3]/,     '\xC3 to /[\xC3]/');
+ok("\x{102}" =~ /[\xC3]/,     '\x{102} to /[\xC3]/');
+ok("\xC3"    =~ /[\x{C3}]/,   '\xC3 to /[\x{C3}]/');
+ok("\x{102}" =~ /[\x{C3}]/,   '\x{102} to /[\x{C3}]/');
+ok("\xC3"    =~ /[\x{102}]/,  '\xC3 to /[\x{102}]/');
+ok("\x{102}" =~ /[\x{102}]/,  '\x{102} to /[\x{102}]/');
+
+ok("\xC1"    =~ /[\xC1]/i,  '\xC1 to /[\xC1]/i');
+ok("\xE1"    =~ /[\xC1]/i,  '\xE1 to /[\xC1]/i');
+ok("\xC1"    =~ /[\xE1]/i,  '\xC1 to /[\xE1]/i');
+ok("\xE1"    =~ /[\xE1]/i,  '\xE1 to /[\xE1]/i');
+ok("\x{102}" =~ /[\xC3]/i,  '\x{102} to /[\xC3]/i');
+ok("\x{103}" =~ /[\xC3]/i,  '\x{103} to /[\xC3]/i');
+ok("\x{102}" =~ /[\xE3]/i,  '\x{102} to /[\xE3]/i');
+ok("\x{103}" =~ /[\xE3]/i,  '\x{103} to /[\xE3]/i');
+
+ok("\xC1"    =~ '\xC1',       '\xC1 to \'\xC1\'');
+ok("\xC1"    =~ '\x{C1}',     '\xC1 to \'\x{C1}\'');
+ok("\xC3"    =~ '\303',       '\xC3 to \'\303\'');
+ok("\xC3"    =~ '\x{102}',    '\xC3 to \'\x{102}\'');
+ok("\xC1"    =~ '[\xC1]',     '\xC1 to \'[\xC1]\'');
+ok("\xC1"    =~ '[\x{C1}]',   '\xC1 to \'[\x{C1}]\'');
+ok("\xC3"    =~ '[\303]',     '\xC3 to \'[\303]\'');
+ok("\xC3"    =~ '[\x{102}]',  '\xC3 to \'[\x{102}]\'');
+
+ok("\xC1"    =~ /¡/,     '\xC1 to /<A-acute>/');
+ok("\xE1"    !~ /¡/,     '\xE1 to /<A-acute>/');
+ok("\xC1"    =~ /¡/i,    '\xC1 to /<A-acute>/i');
+ok("\xE1"    =~ /¡/i,    '\xE1 to /<A-acute>/i');
+ok("\xC1"    =~ /[¡]/,   '\xC1 to /[<A-acute>]/');
+ok("\xE1"    !~ /[¡]/,   '\xE1 to /[<A-acute>]/');
+ok("\xC1"    =~ /[¡]/i,  '\xC1 to /[<A-acute>]/i');
+ok("\xE1"    =~ /[¡]/i,  '\xE1 to /[<A-acute>]/i');
+
+ok("\xC1\xC1"  =~ /¡\xC1/,    '\xC1\xC1 to /<A-acute>\xC1/');
+ok("\xC1\xC1"  =~ /\xC1¡/,    '\xC1\xC1 to /\xC1<A-acute>/');
+ok("\xC1\xC1"  =~ /¡\xC1/i,   '\xC1\xC1 to /<A-acute>\xC1/i');
+ok("\xC1\xC1"  =~ /\xC1¡/i,   '\xC1\xC1 to /\xC1<A-acute>/i');
+ok("\xC1\xE1"  =~ /¡\xC1/i,   '\xC1\xE1 to /<A-acute>\xC1/i');
+ok("\xC1\xE1"  =~ /\xC1¡/i,   '\xC1\xE1 to /\xC1<A-acute>/i');
+ok("\xE1\xE1"  =~ /¡\xC1/i,   '\xE1\xE1 to /<A-acute>\xC1/i');
+ok("\xE1\xE1"  =~ /\xC1¡/i,   '\xE1\xE1 to /\xC1<A-acute>/i');
+
+# \xDF is LATIN SMALL LETTER SHARP S
+
+ok("\xDF" =~ /\xDF/,    '\xDF to /\xDF/');
+ok("\xDF" =~ /\xDF/i,   '\xDF to /\xDF/i');
+ok("\xDF" =~ /[\xDF]/,  '\xDF to /[\xDF]/');
+ok("\xDF" =~ /[\xDF]/i, '\xDF to /[\xDF]/i');
+ok("\xDF" =~ /ﬂ/,       '\xDF to /<sharp-s>/');
+ok("\xDF" =~ /ﬂ/i,      '\xDF to /<sharp-s>/i');
+ok("\xDF" =~ /[ﬂ]/,     '\xDF to /[<sharp-s>]/');
+ok("\xDF" =~ /[ﬂ]/i,    '\xDF to /[<sharp-s>]/i');
+
+ok("SS"   =~ /\xDF/i,   'SS to /\xDF/i');
+ok("Ss"   =~ /\xDF/i,   'Ss to /\xDF/i');
+ok("sS"   =~ /\xDF/i,   'sS to /\xDF/i');
+ok("ss"   =~ /\xDF/i,   'ss to /\xDF/i');
+ok("SS"   =~ /ﬂ/i,      'SS to /<sharp-s>/i');
+ok("Ss"   =~ /ﬂ/i,      'Ss to /<sharp-s>/i');
+ok("sS"   =~ /ﬂ/i,      'sS to /<sharp-s>/i');
+ok("ss"   =~ /ﬂ/i,      'ss to /<sharp-s>/i');
+
+ok("\xC3" =~ /\303/,     '\xC1 to /\303/');
+ok("\303" =~ /\303/,     '\303 to /\303/');
+ok("\xC3" =~ /\303/i,    '\xC1 to /\303/i');
+ok("\xE3" =~ /\303/i,    '\xC1 to /\303/i');
+ok("\xC3" =~ /[\303]/,   '\xC1 to /[\303]/');
+ok("\303" =~ /[\303]/,   '\303 to /[\303]/');
+ok("\xC3" =~ /[\303]/i,  '\xC1 to /[\303]/i');
+ok("\xE3" =~ /[\303]/i,  '\xC1 to /[\303]/i');
+
+ok("\xC3" =~ /\402/,     '\xC1 to /\402/');
+ok("\402" =~ /\402/,     '\402 to /\402/');
+ok("\xC3" =~ /\402/i,    '\xC1 to /\402/i');
+ok("\xE3" =~ /\402/i,    '\xC1 to /\402/i');
+ok("\xC3" =~ /[\402]/,   '\xC1 to /[\402]/');
+ok("\402" =~ /[\402]/,   '\402 to /[\402]/');
+ok("\xC3" =~ /[\402]/i,  '\xC1 to /[\402]/i');
+ok("\xE3" =~ /[\402]/i,  '\xC1 to /[\402]/i');
+
+{
+    my $re = '(?i:\xC1)';
+
+    ok("\xC1" =~ $re, '\xC1 to (?i:\xC1)');
+    ok("\xE1" =~ $re, '\xE1 to (?i:\xC1)');
+
+    utf8::downgrade($re);
+
+    ok("\xC1" =~ $re, '\xC1 to (?i:\xC1) down');
+    ok("\xE1" =~ $re, '\xE1 to (?i:\xC1) down');
+
+    utf8::upgrade($re);
+
+    ok("\xC1" =~ $re, '\xC1 to (?i:\xC1) up');
+    ok("\xE1" =~ $re, '\xE1 to (?i:\xC1) up');
+}
+
--- t/uni/tr_utf8.t.orig	2004-06-25 01:53:16.000000000 -0700
+++ t/uni/tr_utf8.t	2008-07-11 11:44:18.000000000 -0700
@@ -31,7 +31,7 @@
 }
 
 use strict;
-use Test::More tests => 7;
+use Test::More tests => 8;
 
 use encoding 'utf8';
 
@@ -67,4 +67,12 @@
   $line =~ tr/bcdeghijklmnprstvwxyz$02578/◊ë◊¶◊ì◊¢◊í◊î◊ô◊≤◊ß◊ú◊û◊†◊§÷º◊®◊°◊ò◊∞◊©◊õ◊ô◊ñ◊©◊±◊™◊≤◊ó◊ê/;
   is($line, "a◊ë◊¶◊ì◊¢f◊í◊î◊ô◊≤◊ß◊ú◊û◊†o◊§q÷º◊®◊°u◊ò◊∞◊©◊õ◊ô◊ñ◊©1◊±34◊™6◊≤◊ó9", "[perl #16843]");
 }
+
+{
+  # [perl #40641]
+  my $str = qq/Geb√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§ude/;
+  my $reg = qr/Geb√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§√§ude/;
+  ok($str =~ /$reg/, "[perl #40641]");
+}
+
 __END__
