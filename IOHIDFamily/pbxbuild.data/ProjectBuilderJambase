# ProjectBuilder Jambase
# Copyright (c) 1999,2000 Apple Computer, Inc.
# All rights reserved.

CROSS_ROOT default = "" ;

JAMBASE_DIR default = $(JAMBASE:D) ;

OS default = macos ;
if $(OS) = MACOS {
    OS = macos ;
}

if OS != "" {
    include $(JAMBASE_DIR)/platform-$(OS).jam ;
}

# Copyright (c) 1999-2002 Apple Computer, Inc.
# All rights reserved.

# This file defines various functions for transforming text and
# manipulating variables

/ default = / ;

# NonObjectFiles <non-object files returned> : <list of files>
# Returns only files not in $(OBJECT_FILES_$(VARIANT)
# or $(OBJECT_FILES_$(VARIANT)_$(ARCH)) for ARCH in $(ARCHS)
rule NonObjectFiles
{
    $(1) = ;
    for X in $(2) {
        if ! $(X) in $(OBJECT_FILES_$(VARIANT)) {
            REJECT = ;
            for ARCH in $(ARCHS) {
                if $(X) in $(OBJECT_FILES_$(VARIANT)_$(ARCH)) {
                    REJECT = YES ;
                }
            }
            if ! $(REJECT) {
                $(1) += $(X) ;
            }
        }
    }
}

#
# RemovePrefixPath <variable> : <prefix> : <path-with-prefix>
#  removes the given prefix from the path and puts the result
# in the given variable
#
rule RemovePrefixPath
{
    local newname = $(3:BS) ;
    local newdir = $(3:D) ;
    local INDEX ;
    if $(2) != "." {
	for INDEX in 1 2 3 4 5 6 7 8 9 10 {
	    if $(newdir) != $(2) {
		newname = $(newdir:BS)/$(newname) ;
		newdir = $(newdir:D) ;
	    }
	}
    }
    else {
	newname = $(3) ;
    }
    $(1) = $(newname) ;
}
# Copyright (c) 1999-2002 Apple Computer, Inc.
# All rights reserved.

# Built-in definitions of common build settings.  These can be
# overridden by any higher layer (project-level, target-level,
# build-phase-level, command-line etc).

# the four 'root' directories
export deferred SRCROOT = $(PWD) ;
export deferred OBJROOT = $(SYMROOT) ;
export deferred SYMROOT = $(SRCROOT)/build ;
export deferred DSTROOT = /tmp/$(PROJECT_NAME).dst ;

# synonyms for the above
export deferred SOURCE_ROOT = $(SRCROOT) ;
export deferred TEMP_ROOT = $(OBJROOT) ;
export deferred BUILD_ROOT = $(SYMROOT) ;
export deferred INSTALL_ROOT = $(DSTROOT) ;

# more specific directories inside the TEMP_ROOT
export deferred TEMP_DIR = $(OBJROOT)/$(PROJECT_NAME).build/$(TARGET_NAME).build ;
export deferred DERIVED_FILE_DIR = $(TEMP_DIR)/DerivedSources ;
       deferred OBJECT_FILE_DIR = $(TEMP_DIR)/Objects ;
       deferred CLASS_FILE_DIR = $(TEMP_DIR)/JavaClasses ;
       deferred FILE_LIST = $(OBJECT_FILE_DIR)/LinkFileList ;
       deferred PRECOMP_TRUSTFILE = $(TEMP_DIR)/TrustedPrecomps.txt ;

# more specific directories inside the BUILD_ROOT
export deferred BUILD_DIR = $(SYMROOT) ;

# more specific directories inside the INSTALL_ROOT
export deferred INSTALL_DIR = $(DSTROOT)/$(INSTALL_PATH) ;

# installation parameters
export deferred INSTALL_OWNER = $(USER) ;
export deferred INSTALL_GROUP = $(GROUP) ;
export deferred INSTALL_MODE_FLAG = "a-w,a+rX" ;

# language-independent code generation settings
       deferred OPTIMIZATION_LEVEL = 0 ;
       deferred OPTIMIZATION_CFLAGS = -Os ;
       deferred DEBUGGING_SYMBOLS = YES ;
       deferred PROFILING_CODE = NO ;
       deferred PREBINDING = YES ;

# Java-specific (some are marginally obsolete)
       deferred JAVA_ARCHIVE_CLASSES = YES ;
       deferred JAVA_ARCHIVE_TYPE = JAR ;
       deferred JAVA_APP_STUB = $(SYSTEM_LIBRARY_DIR)/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub ;
       deferred JAVA_JAR_FLAGS = cv ;
       deferred JAVA_SOURCE_SUBDIR = . ;
       deferred JAVA_FRAMEWORK_RESOURCES_DIRS = Resources ;
       deferred JAVA_FRAMEWORK_JARS = ;
       deferred JAVA_USE_DEPENDENCIES = YES ;
       deferred JAVA_ZIP_FLAGS = -urg ;
       deferred JAVAC_SOURCE_FILE_ENCODING = MACINTOSH ;

# miscellaneous
export deferred DEVELOPMENT_LANGUAGE = English ;
export deferred FRAMEWORK_VERSION = A ;
       deferred REMOVE_CVS_FROM_RESOURCES = YES ;
       deferred COPY_PHASE_STRIP = NO ;
       deferred CLONE_HEADERS = NO ;
       deferred KEEP_PRIVATE_EXTERNS = YES ;   # this currently affects the master.o file only


rule ConditionalDefinitions
{
    # default mapping of build actions to build variants
    switch $(ACTION) {
        case build : deferred BUILD_COMPONENTS = headers build ;
        case copysrc : deferred BUILD_COMPONENTS = source ;
        case copyhdrs : deferred BUILD_COMPONENTS = headers ;
        case copyrsrcs : deferred BUILD_COMPONENTS = resources ;
        case install : deferred BUILD_COMPONENTS = headers build ; 
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
        case installdebugonly : deferred BUILD_COMPONENTS = build ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
         deferred BUILD_VARIANTS = debug ;
        case installprofileonly : deferred BUILD_COMPONENTS = build ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
         deferred BUILD_VARIANTS = profile ;
        case installdebugprofileonly : deferred BUILD_COMPONENTS = build ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
         deferred BUILD_VARIANTS = debug profile ;
        case installhdrs : deferred BUILD_COMPONENTS = headers ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
        case installsrc : deferred BUILD_COMPONENTS = source ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
        case installrsrcs : deferred BUILD_COMPONENTS = resources ;
         deferred DEPLOYMENT_LOCATION = YES ;
         deferred DEPLOYMENT_POSTPROCESSING = YES ;
    }

    # conditional locations enabling install-in-place
    if $(DEPLOYMENT_LOCATION) = YES {
        if $(SKIP_INSTALL) || ! $(INSTALL_PATH) {
            # !!!:cmolick:20020301 uninstalled products might best go to
            #  the built products dir, or a subfolder if there are asides
            export deferred TARGET_BUILD_DIR = $(TEMP_ROOT)/UninstalledProducts ;
        }
        else {
            export deferred TARGET_BUILD_DIR = $(INSTALL_ROOT)/$(INSTALL_PATH) ;
        }
        deferred BASE_PROJECT_HEADER_DIR = $(TEMP_ROOT)/ProjectHeaders ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES {
            # built products go in subfolder when there are asides
            export deferred BUILT_PRODUCTS_DIR = $(BUILD_ROOT)/BuiltProducts ;
        }
        else {
            # built products go in build folder when there are no asides
            export deferred BUILT_PRODUCTS_DIR = $(BUILD_ROOT) ;
        }
    }
    else {
        export deferred TARGET_BUILD_DIR = $(BUILD_DIR) ;
        export deferred BUILT_PRODUCTS_DIR = $(BUILD_DIR) ;
        deferred BASE_PROJECT_HEADER_DIR = $(BUILD_ROOT)/ProjectHeaders ;
    }
}
# Copyright (c) 1999-2002 Apple Computer, Inc.
# All rights reserved.

# old skool...
# Source root is SRCROOT, or ., or working directory
# Root values are overridden by default
#SRCROOT default = $(PWD) ;
#SRCROOT default = . ;
#SOURCE_ROOT default = $(SRCROOT) ;

# Maps legacy Makefile variables to modern Jambase variables
# Set global C flags, architectures, and architecture flags for linking
GLOBAL_CFLAGS default = $(RC_NONARCH_CFLAGS) ;
ARCHITECTURES default = $(RC_ARCHS) ;
SUPPORTED_ARCHITECTURES = i386 ppc ;
VALID_ARCHS default = i386 ppc ;
for ARCH in $(SUPPORTED_ARCHITECTURES) {
    if $(RC_$(ARCH)) = YES {
        $(ARCH) = YES ;
    }
}

# More compatibility definitions for things that we have
# renamed that we had already told external users about
export deferred TEMP_FILES_DIR = $(TEMP_DIR) ;
export deferred DERIVED_SOURCES_DIR = $(DERIVED_FILE_DIR) ;
export deferred BUILD_PATH = $(TEMP_ROOT) ;

export deferred PROJECT = $(PROJECT_NAME) ;
export deferred TARGETNAME = $(TARGET_NAME) ;

# (the following four are build settings to the generated package files
#  written by PBXCore -- the new names have underscores to indicate that
#  they are private, and they have more consistent names -- we should
#  be able to remove the old compatibility settings soon)
export deferred PRODUCT_SETTINGS_PATH = $(_INFO_PLIST_FILE_PATH) ;
export deferred PKGINFO_FILE_PATH = $(_PKGINFO_FILE_PATH) ;
export deferred VERSION_SETTINGS_PATH = $(_VERSION_PLIST_FILE_PATH) ;
export deferred DEVELOPMENT_SETTINGS_PATH = $(_PBDEVELOPMENT_PLIST_FILE_PATH) ;
# Copyright (c) 1999-2002 Apple Computer, Inc.
# All rights reserved.

# !!!cmolick:20000821 hardcoded tool paths because variables not set yet
APPLE_INTERNAL_TOOLS default = /AppleInternal/Developer/Tools ;
SYSTEM_DEVELOPER_TOOLS default = /Developer/Tools ;
# Variables for invoking commands using explict paths
# except where built in shell functions should be used
ASM		default = /usr/bin/as ;
BRIDGET         default = /usr/bin/bridget ;
# !!!:anders:20020110  The following has been moved to the BeginProduct rule, so that
# definitions of USE_GCC3 in the target or build style can take effect.
# CC           default = /usr/bin/cc ;
CD		default = cd ;
CHMOD		default = /bin/chmod ;
CHOWN		default = /usr/sbin/chown ;
CP		default = /bin/cp ;
DITTO		default = /usr/bin/ditto ;
ECHO            default = echo ;
EGREP		default = /usr/bin/egrep ;
FASTCP		default = /usr/lib/fastcp ;
FIXPRECOMPS	default = /usr/bin/fixPrecomps ;
FIND		default = /usr/bin/find ;
GATHERHEADERDOC default = /usr/bin/gatherHeaderDoc ;
HEADERDOC2HTML	default = /usr/bin/headerdoc2html ;
INTERFACER	default = $(APPLE_INTERNAL_TOOLS)/Interfacer ;
JAR		default = /usr/bin/jar ;
export JAVA_COMPILER	default = /usr/bin/javac ;
export JAVACONFIG	default = /usr/bin/javaconfig ;
# !!!:anders:20020110  The following has been moved to the BeginProduct rule, so that
# definitions of USE_GCC3 in the target or build style can take effect.
# LD           default = /usr/bin/cc ;
LEX		default = /usr/bin/lex ;
LIBTOOL		default = /usr/bin/libtool ;
LN		default = /bin/ln ;
LNRESOLVE       default = $(SYSTEM_DEVELOPER_TOOLS)/lnresolve ;
MAKEPSEUDOLIB	default = $(APPLE_INTERNAL_TOOLS)/MakePseudoLibrary ;
MERGEINFO	default = /usr/lib/mergeInfo ;
MKDIR		default = /bin/mkdir ;
MIG		default = /usr/bin/mig ;
MV		default = /bin/mv ;
NMEDIT		default = /usr/bin/nmedit ;
OSAC		default = /usr/bin/osacompile ;
OSAL		default = /usr/bin/osalang ;
OSAS		default = /usr/bin/osascript ;
PAX		default = /bin/pax ;
PBXCP		default = $(SYSTEM_DEVELOPER_TOOLS)/pbxcp ;
RANLIB		default = /usr/bin/ranlib ;
REGGEN		default = reggen ;
RESMERGER	default = $(SYSTEM_DEVELOPER_TOOLS)/ResMerger ;
RESOURCE_PRESERVING_CP default = $(SYSTEM_DEVELOPER_TOOLS)/CpMac ;
REZ		default = $(SYSTEM_DEVELOPER_TOOLS)/Rez ;
RM		default = /bin/rm ;
RPCGEN		default = /usr/bin/rpcgen ;
SED		default = /usr/bin/sed ;
SETFILE		default = $(SYSTEM_DEVELOPER_TOOLS)/SetFile ;
SH		default = /bin/sh ;
STRIP		default = /usr/bin/strip ;
TOUCH		default = /usr/bin/touch ;
UNZIP		default = /usr/bin/unzip ;
XARGS		default = /usr/bin/xargs ;
YACC		default = /usr/bin/yacc ;
ZIP		default = /usr/bin/zip ;

# Basic operations:

# Rm <files>
# Removes <files> from the filesystem.  Note that the actions are only
# executed once, no matter how many times the rule is invoked.
actions together piecemeal Rm
{
    $(RM) -r "$(1)"
}

# RelativeRm <files> : <location>
# Removes <files> from <location> after removing grist.
actions together piecemeal RelativeRm
{
    $(RM) -rf "$(2)$(/)$(1:G=)"
}

# Mkdir <directory>
# Creates <directory>
rule Mkdir
{
    # Only existence of the directory matters
    NOUPDATE $(1) ;
}
actions together piecemeal Mkdir
{
    $(MKDIR) -p "$(1)"
}

# MkEmptyDir <directory>
# Makes a directory if necessary, and insures it is empty
actions together MkEmptyDir
{
    ( $(MKDIR) -p "$(1)" && $(CD) "$(1)" && $(RM) -rf "*" )
}

# SymLink <link> : <to>
# Makes a symbolic link to the path indicated.
# Link target is treated as a nonfile to preserve the value
rule SymLink
{
    if ! $(2) in $(PRODUCT_FILES) && $(2) != $(PRODUCT_CLASS_FILE_DIR) {
        NOTFILE $(2) ;
    }
}
actions SymLink
{
    $(LN) -sf "$(2)" "$(1)"
}

# Touch <files>
# Touches files in the filesystem.
actions Touch
{
    $(TOUCH) "$(1)"
}

# TouchConditionally <fileToTouch> : <fileToCompareAgainst>
# Touches a file in the filesystem if <fileToCompareAgainst> is newer.
rule TouchConditionally
{
	DEPENDS $(1) : $(2) ;
}
actions TouchConditionally
{
    $(TOUCH) "$(1:G=)"
}

# Echo <file> : <text>
# Echoes text into a file.
rule Echo
{
    local FILE ;
    NOTFILE $(2) ;
    Echo.remove $(1) ;
    for FILE in $(2) {
        Echo.append $(1) : $(FILE) ;
    }
}
actions together piecemeal quietly Echo.remove
{
    $(RM) -rf "$(1)"
}
actions quietly Echo.append
{
    $(ECHO) "$(2)" >> "$(1)"
}

# ChangeOwnerAndGroup and ChangeMode to use when installing files
# All these use the -H option to avoid traversing bad symbolic links
rule ChangeOwnerAndGroup
{
    if $(INSTALL_OWNER) {
        if $(INSTALL_GROUP) {
            ChangeOwnerAndGroup.Action $(1) ;
        }
        else {
            ChangeOwner.Action $(1) ;
        }
    }
}
actions ChangeOwnerAndGroup.Action
{
    if [ -e "$(1)" ]
      then $(CHOWN) -RH $(INSTALL_OWNER):$(INSTALL_GROUP) "$(1)"
    fi
}
actions ChangeOwner.Action
{
    if [ -e "$(1)" ]
      then $(CHOWN) -RH $(INSTALL_OWNER) "$(1)"
    fi
}
actions ChangeMode
{
    if [ -e "$(1)" ]
      then $(CHMOD) -RH $(INSTALL_MODE_FLAG) "$(1)"
    fi
}

# Strip <target>
# Runs strip to remove debugging symbols from the executable of the target
actions Strip
{
    $(STRIP) $(STRIPFLAGS) "$(1)"
}

# SetFile <fork file>
# Appends type and creator to a file
rule SetFile
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -t '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -c '$(MACOS_CREATOR)' ;
    }
    SETFILEFLAGS on $(1) = $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) "$(OTHER_SETFILEFLAGS)" ;
}
actions SetFile
{
    $(SETFILE) $(SETFILEFLAGS) "$(1)"
}

# Rez <fork file> : <target file>
# Appends resource fork data to a file
rule Rez
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    DEPENDS $(1) : $(2) ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -t '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -c '$(MACOS_CREATOR)' ;
    }
    REZFLAGS on $(1) = -append -d SystemSevenOrLater=1 $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) $(OTHER_REZFLAGS) ;
    if ! $(REZ_EXECUTABLE) = "YES" {
        # by default use data forks
        REZFLAGS on $(1) += -useDF ;
    }
}
actions Rez
{
    $(REZ) "$(2)" "$(REZFLAGS)" -o "$(1)"
}

# ResMerge <fork file> : <rsrc file>
# Merges the resources from binary resource file 'rsrc file' into 'fork file'
rule ResMerge
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    DEPENDS $(1) : $(2) ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -fileType '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -fileCreator '$(MACOS_CREATOR)' ;
    }
    RESMERGEFLAGS on $(1) = -append $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) $(OTHER_RESMERGERFLAGS) ;
    if ! $(REZ_EXECUTABLE) = "YES" {
        # by default use data forks
        RESMERGEFLAGS on $(1) += -dstIs DF ;
    }
}
actions ResMerge
{
    $(RESMERGER) "$(2)" "$(RESMERGEFLAGS)" -o "$(1)"
}

# RezCollector and ResMergerCollector either compile
# resource manager resources together, or split compiles
# by file with the first compile being treated differently.
# This code assumes collectors will be declared product files
# only after the first Collector rule evaluation.
rule RezCollector
{
    DEPENDS $(1) : $(2) ;
    REZFLAGS on $(1) = -d SystemSevenOrLater=1 -useDF $(OTHER_REZFLAGS) ;
    if $(REZ_TOGETHER) = YES {
        RezCollector.together $(1) : $(2) ;
    }
    else {
        if ! $(1) in $(PRODUCT_FILES) {
            RezCollector.initial $(1) : $(2) ;
        }
        else {
            RezCollector.append $(1) : $(2) ;
        }
    }
}
actions together piecemeal RezCollector.together
{
    if [ -f "$(1)" ]; then
        _appendoption=-append
    fi
    $(REZ) -o "$(1)" $_appendoption "$(REZFLAGS)" "$(2)"
}
actions RezCollector.initial
{
    $(RM) -f "$(1)" && \
    $(REZ) -o "$(1)" "$(REZFLAGS)" "$(2)"
}
actions RezCollector.append
{
    $(REZ) -o "$(1)" -append "$(REZFLAGS)" "$(2)"
}

rule ResMergerCollector
{
    DEPENDS $(1) : $(2) ;
    RESMERGEFLAGS on $(1) = -dstIs DF $(OTHER_RESMERGERFLAGS) ;
    if $(REZ_TOGETHER) = YES {
        ResMergerCollector.together $(1) : $(2) ;
    }
    else {
        if ! $(1) in $(PRODUCT_FILES) {
            ResMergerCollector.initial $(1) : $(2) ;
        }
        else {
            ResMergerCollector.append $(1) : $(2) ;
        }
    }
}
actions together piecemeal ResMergerCollector.together
{
    if [ -f "$(1)" ]; then
        _appendoption=-append
    fi
    $(RESMERGER) -o "$(1)" $_appendoption "$(RESMERGEFLAGS)" "$(2)"
}
actions ResMergerCollector.initial
{
    $(RM) -f "$(1)" && \
    $(RESMERGER) -o "$(1)" "$(RESMERGEFLAGS)" "$(2)"
}
actions ResMergerCollector.append
{
    $(RESMERGER) -o "$(1)" -append "$(RESMERGEFLAGS)" "$(2)"
}

# ResMergerProduct - used to transfer collector resources to final destination
rule ResMergerProduct
{
    local MACOS_TYPE_ARG ;
    local MACOS_CREATOR_ARG ;
    DEPENDS $(1) : $(2) ;
    if $(MACOS_TYPE) {
        MACOS_TYPE_ARG = -fileType '$(MACOS_TYPE)' ;
    }
    if $(MACOS_CREATOR) {
        MACOS_CREATOR_ARG = -fileCreator '$(MACOS_CREATOR)' ;
    }
    RESMERGEFLAGS on $(1) = $(MACOS_TYPE_ARG) $(MACOS_CREATOR_ARG) -srcIs DF $(OTHER_RESMERGERFLAGS) ;
    if $(REZ_EXECUTABLE) = "YES" {
        ResMergerProductResourceFork $(1) : $(2) ;
    }
    else {
        RESMERGEFLAGS on $(1) += -dstIs DF ;
        ResMergerProductDataFork $(1) : $(2) ;
    }
}
actions ResMergerProductResourceFork
{
    $(REZ) -o "$(1)" < /dev/null && \
    $(RESMERGER) "$(2)" $(RESMERGEFLAGS) -o "$(1)"
}
actions ResMergerProductDataFork
{
    $(RM) -f "$(1)" && \
    $(RESMERGER) "$(2)" $(RESMERGEFLAGS) -o "$(1)"
}

# Fixprecomps <precomp> : <header>
# Ensures that the precompiled header is up to date
if $(FIXPRECOMPS) {
    rule Fixprecomps
    {
        DEPENDS $(1) : $(2) ;
    }
    actions Fixprecomps
    {
        $(FIXPRECOMPS) -precomps "$(1)"
    }
} else {
    rule Fixprecomps
    {
        # if we don't have a fixprecomps command, we'll just
        # quietly do nothing
        NOTFILE $(1) ;
    }
}


# Copy operations:

# Cp <destination> : <source>
# Reliably copies files only.
# Leaf names of the source and destination are expected to match.
rule Cp
{
    DEPENDS $(1) : $(2) ;
}
# !!!:cmolick:20020130 use of lnresolve allows references to be symbolic links
actions together piecemeal Cp
{
    _source=`$(LNRESOLVE) "$(2)"`
    $(CP) "$(CPFLAGS)" "$_source" "$(1)"
}

# PBXCp <destination-file> : <source-file>
# Reliably copies files only.  Does not currently respect Mac OS
# Finder info or resource forks, but it does skip CVS directories
# and it does optionally strip Mach-O executables.
# Leaf names of the source and destination are expected to match.
rule PBXCp
{
    if $(ACTION) != installhdrs {
        DEPENDS $(1) : $(2) ;
    }
    PBXCP_FLAGS on $(1) = ;
    VERBOSE_PBXCP default = NO ;
    if $(VERBOSE_PBXCP) = YES {
        PBXCP_FLAGS on $(1) += -V ;
    }
    PBXCP_FLAGS on $(1) += -exclude .DS_Store ;
    if $(REMOVE_CVS_FROM_RESOURCES) = YES {
        PBXCP_FLAGS on $(1) += -exclude CVS ;
    }
    if $(COPY_PHASE_STRIP) = YES  &&  $(ACTION) != installhdrs {
        PBXCP_FLAGS on $(1) += -strip-debug-symbols ;
    }
    # Because any content copied may have been generated, and so may be
    # in the form of a symlink to the actual content, it is necessary
    # to resolve one level of symbolic link for all sources copied.
    PBXCP_FLAGS on $(1) += -resolve-src-symlinks ;

    PBXCp.CopyToDirectory $(1) : $(2) ;
}
actions together piecemeal updated PBXCp.CopyToDirectory
{
    $(PBXCP) $(PBXCP_FLAGS:Q) $(2:Q) $(1:DQ)
}

# Ditto <destination> : <source>
# Directory to directory copies.
rule Ditto
{
    DEPENDS $(1) : $(2) ;
}
actions Ditto
{
    $(DITTO) $(2:Q) $(1:Q)
}

# RobustCp <destination> : <source>
# RobustCp is like Cp, but is made more robust by first removing
# any previous copy results and then conditionally removing CVS
# directories from the destination.
rule RobustCp
{
    if ! $(ACTION) = installhdrs {
        DEPENDS $(1) : $(2) ;
    }
    if $(REMOVE_CVS_FROM_RESOURCES) = YES && $(DEPLOYMENT_POSTPROCESSING) = YES {
        RobustCp.CleanBeforeAndAfter $(1) : $(2) ;
    }
    else {
        RobustCp.CleanBefore $(1) : $(2) ;
    }
    if $(COPY_PHASE_STRIP) = YES && ! $(ACTION) = installhdrs {
        StripBinaries $(1) ;
    }
}
actions RobustCp.CleanBeforeAndAfter
{
    if [ -d "$(1)" ]
        then $(RM) -r "$(1)"
    fi
    if [ -e "$(2)" ]
        then
        _source=`$(LNRESOLVE) "$(2)"`
        $(CP) -fRP "$_source" "$(1)"
        if [ -d "$_source" ]
            then
            $(FIND) "$(1)" -name CVS -type d -prune -print0 | $(XARGS) -0 rm -r
        fi
    fi
}
actions RobustCp.CleanBefore
{
    if [ -d "$(1)" ]
        then $(RM) -r "$(1)"
    fi
    if [ -e "$(2)" ]
        then _source=`$(LNRESOLVE) "$(2)"`
        $(CP) -fRP "$_source" "$(1)"
    fi
}

# StripBinaries <starting directory>
# Uses find to run strip -s on all binaries starting from a file or directory
actions StripBinaries
{
    if [ -f "$(1)" ]; then
        filetype=`file "$(1)"`
        macho=`echo $filetype | fgrep Mach-O | sed 's/:.*//'`
        ararch=`echo $filetype | fgrep ar\ archive | sed 's/:.*//'`
        if [ "x$macho" != "x" ]; then
            $(STRIP) -S "$macho"
        fi
        if [ "x$ararch" != "x" ]; then
            $(STRIP) -S "$ararch"
        fi
    else
        machos=`cd "$(1)"; $(FIND) . -type f -print0 | xargs -0 file | fgrep Mach-O | sed 's/:.*//'`
        ararchs=`cd "$(1)"; $(FIND) . -type f -print0 | xargs -0 file | fgrep ar\ archive | sed 's/:.*//'`
        if [ "x$machos" != "x" ]; then
            cd "$(1)"; 
	    origIFS=$IFS
	    IFS="
"
	    for curbinary in $machos ; do
	    	$(STRIP) -S "$curbinary"
	    done
	    IFS=$oldIFS
        fi
        if [ "x$ararchs" != "x" ]; then
            cd "$(1)"; 
	    origIFS=$IFS
	    IFS="
"
	    for curbinary in $ararchs ; do
	    	$(STRIP) -S "$curbinary"
	    done
	    IFS=$oldIFS
        fi
    fi
}

# ResourcePreservingCp <destination> : <source>
# where the leaf names of <destination> and <source> are the same
# and CpMac is to be used to insure resources are preserved.
# Although CpMac is invoked with -r, this command is only reliable
# for individual file copies becaues there is no preremove of
# a directory destination which could cause nesting of the copy.
rule ResourcePreservingCp
{
    DEPENDS $(1) : $(2) ;
}
actions together piecemeal ResourcePreservingCp
{
    $(RESOURCE_PRESERVING_CP) -r "$(2)" "$(1)"
}

# ResourcePreservingMv <destination> : <source> : <junk>
# where the leaf names of <destination> and <source> are the same
# and CpMac is to be used to insure resources are preserved.
# The <junk> is removed after copying.
rule ResourcePreservingMv
{
    DEPENDS $(1) : $(2) ;
}
actions together piecemeal ResourcePreservingMv
{
    $(RESOURCE_PRESERVING_CP) -r "$(2)" "$(1)"
}

# CloneHeader <primary target> : <header> : <target directory>
# Writes in the target directory a stub clone of the header
# which contains only an #import directive with the path
# to the real header in quotes.
# Individual header clones depend on the PROJECT_HEADER_CLONE
# nonfile target which is depended on by the product and object files.
rule CloneHeader
{
    # derive name of header clone and find full path to header
    local HEADER_CLONE ;
    if $(3) = $(PUBLIC_HEADER_CLONE_DIR) {
        HEADER_CLONE = $(2:BSG=PublicHeaderClone) ;
    }
    else {
        if $(3) = $(PRIVATE_HEADER_CLONE_DIR) {
            HEADER_CLONE = $(2:BSG=PrivateHeaderClone) ;
        }
        else {
            HEADER_CLONE = $(2:BSG=ProjectHeaderClone) ;
        }
    }
    local HEADER_PATH ;
    if AbsolutePath in $($(2:G=)_ATTRIBUTES) {
        HEADER_PATH = $(2:G=) ;
    } 
    else {
        HEADER_PATH = $(SOURCE_ROOT)$(/)$(2:G=) ;
    } 
    LOCATE on $(HEADER_CLONE) = $(3) ;
    DEPENDS $(HEADER_CLONE) : $(3) ;
    if ! $(3) in $(PRODUCT_FILES) {
        Mkdir $(3) ;
        ProductFile $(3) ;
    }
    if $(3) = $(PRIVATE_HEADER_CLONE_DIR) && $(PRIVATE_HEADER_CLONE_LINK) {
        DEPENDS $(HEADER_CLONE) : $(PRIVATE_HEADER_CLONE_LINK) ;
        if ! $(PRIVATE_HEADER_CLONE_LINK) in $(PRODUCT_FILES) {
            SymLink $(PRIVATE_HEADER_CLONE_LINK) : $(PRIVATE_HEADER_CLONE_LINK_PATH) ;
            ProductFile $(PRIVATE_HEADER_CLONE_LINK) ;
        }
    }
    if $(3) = $(PUBLIC_HEADER_CLONE_DIR) && $(PUBLIC_HEADER_CLONE_LINK) {
        DEPENDS $(HEADER_CLONE) : $(PUBLIC_HEADER_CLONE_LINK) ;
        if ! $(PUBLIC_HEADER_CLONE_LINK) in $(PRODUCT_FILES) {
            SymLink $(PUBLIC_HEADER_CLONE_LINK) : $(PUBLIC_HEADER_CLONE_LINK_PATH) ;
            ProductFile $(PUBLIC_HEADER_CLONE_LINK) ;
        }
    }
    # make clone and record as build phase product
    ImportStub $(HEADER_CLONE) : $(HEADER_PATH) ;
    ProductFile $(HEADER_CLONE) ;
    LOCATE on $(HEADER_CLONE) = $(3) ;
}

# ImportStub <stub file> : <stub import file>
# Generates a file with one line which is an #import directive
# and the second parameter quoted which should be a full path
# to the real file to be imported.
rule ImportStub
{
    DEPENDS $(1) : $(2) ;
    NOUPDATE $(1) ;
}
actions ImportStub
{
    echo "#import" \""$(2)"\" > "$(1)"
}

# AbsolutePathImportStub <stub file> : <stub import file>
# Generates a file with one line which is an #import directive
# and the second parameter quoted which should be a full path
# to the real file to be imported.  
# If $2 is not an absolute path, $(SRCROOT) will be prepended to make it absolute.
rule AbsolutePathImportStub
{
    DEPENDS $(1) : $(2) ;
    NOUPDATE $(1) ;
}
actions AbsolutePathImportStub
{
    firstChar=`echo "$(2)" | colrm 2`
    if [ z$firstChar = z"/" -o z$firstChar = z"~" ] ; then
        includePath="$(2)"
    else
        includePath="$(SRCROOT)/$(2)"
    fi
    echo "#include" \""${includePath}"\" > "$(1)"
}

# HeaderDoc <headerdoc target (table of contents for header)> : <header>
rule HeaderDoc
{
    DEPENDS $(1) : $(2) ;
}
actions HeaderDoc
{
    $(HEADERDOC2HTML) -o "$(HEADERDOC_DIR)" "$(2)"
}

# GatheredHeaderDoc <gathered headerdoc target>
rule GatheredHeaderDoc
{
}
actions GatheredHeaderDoc
{
    $(GATHERHEADERDOC) "$(HEADERDOC_DIR)"
}

# Source derivation operations:

# Lex <file>.{c|m} : <file>.l[m]
# Runs lex to generate <file>.c or <file>.m based on scanner input
rule Lex
{
    DEPENDS $(1) : $(2) ;
}

actions Lex
{
    $(LEX) $(LEXFLAGS) "-o$(1)" "$(2)"
}

# Yacc <file>.h <file>.{c|m} : <file>.y[m]
# Uses yacc to generate parser from description
rule Yacc
{
    DEPENDS $(1) : $(2) ;
}

actions Yacc
# Generate result by noting location, going to derived source directory,
# running yacc, then copying the results to what is desired.
{
    origin=`/bin/pwd` && $(CD) "$(1[1]:D)" && $(YACC) $(YACCFLAGS) -d "$origin/$(2)" && $(CP) y.tab.h "$(1[1])" && $(CP) y.tab.c "$(1[2])"
}

# RPCGen <proto>.h <proto>_xdr.c : <proto>.x
# Generates RPC stubs from specifications
#
rule RPCGen
{
    DEPENDS $(1) : $(2) ;
}

# Generate header and C code with two calls to rpcgen
actions RPCGen
{
    $(RPCGEN) $(RPCGENFLAGS) -h -o "$(1[1])" "$(2)"
    $(RPCGEN) $(RPCGENFLAGS) -c -o "$(1[2])" "$(2)"
}

# Mig <file>.h <file>User.c : <file>.defs OR
# Mig <file>Server.h <file>Server.c : <file>.defs
# Runs mig to create client and server files from a definition file.
rule Mig
{
    DEPENDS $(1) : $(2) ;
    # was: $(MACH_SERVER) = YES || $(MACH_CLIENT_AND_SERVER) = YES
    if Server in $($(2)_ATTRIBUTES) {
        Mig.server $(1) : $(2) ;
    }
    else {
        Mig.client $(1) : $(2) ;
    }
}
actions Mig.client
{
    origin=`pwd` && $(CD) "$(1[1]:D)" && $(MIG) $(OTHER_MIGFLAGS) "$origin/$(2)"
}
actions Mig.server
{
    origin=`pwd` && $(CD) "$(1[1]:D)" && $(MIG) $(OTHER_MIGFLAGS) -sheader "$(2:B)Server.h" "$origin/$(2)"
}

# Bridget <primary target> : <jobs file>
rule Bridget
{
    # set up common settings and paths needed for bridget usage
    JAVA_HEADERS default = /Developer/Java/Headers /System/Library/Frameworks/JavaVM.framework/Headers ;
    if ! $(BRIDGET_FILES_DIR) {
        BRIDGET_FILES_DIR = $(DERIVED_FILE_DIR)$(/)JavaBridgeFiles ;
        Mkdir $(BRIDGET_FILES_DIR) ;
        ProductFile $(BRIDGET_FILES_DIR) ;
    }
    if $(BRIDGE_JAVA) = YES {
        # produce the file list draft
        # conditionally update the file list from the draft
        BRIDGET_DERIVED_JAVA_FILE_LIST = $(FILE_LIST:G=BridgetDerivedJavaFileList)BridgetDerivedJavaFileList ;
        NOTFILE $(BRIDGET_DERIVED_JAVA_FILE_LIST) ;
        DEPENDS $(1) : $(BRIDGET_DERIVED_JAVA_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(2) ;
        DEPENDS $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(OBJECT_FILE_DIR) ;
        Bridget.UpdateJavaFileList $(BRIDGET_DERIVED_JAVA_FILE_LIST) : $(2) ;
        # derive files using file list
        # compile derived files (nonfile target?)
        BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG = $(FILE_LIST:G=BridgetDeriveAndCompileJavaTag)BridgetDeriveAndCompileJavaTag ;
        ProductFile $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) ;
        DEPENDS $(1) : $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(BRIDGET_DERIVED_JAVA_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(CLASS_FILE_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(2) ;
        if $(JAVA_COMPILER:B) = jikes {
            Bridget. DeriveAndCompileJava.jikes $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(2) ;
        }
        else {
            Bridget.DeriveAndCompileJava.javac $(BRIDGET_DERIVE_AND_COMPILE_JAVA_TAG) : $(2) ;
        }
    }
    if $(BRIDGE_OBJC) = YES {
        # Produce the derived C file list draft
        # and conditionally update the file list from the draft.
        BRIDGET_DERIVED_C_FILE_LIST = $(FILE_LIST:G=BridgetDerivedCFileList)BridgetDerivedCFileList ;
        NOTFILE $(BRIDGET_DERIVED_C_FILE_LIST) ;
        DEPENDS $(1) : $(BRIDGET_DERIVED_C_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVED_C_FILE_LIST) : $(2) ;
        DEPENDS $(BRIDGET_DERIVED_C_FILE_LIST) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVED_C_FILE_LIST) : $(OBJECT_FILE_DIR) ;
        Bridget.UpdateCFileList $(BRIDGET_DERIVED_C_FILE_LIST) : $(2) ;
        BRIDGET_DERIVE_AND_COMPILE_C_TAG = $(FILE_LIST:G=BridgetDeriveAndCompileCTag)BridgetDeriveAndCompileCTag ;
        ProductFile $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) ;
        DEPENDS $(1) : $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(BRIDGET_DERIVED_C_FILE_LIST) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(BRIDGET_FILES_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(OBJECT_FILE_DIR) ;
        DEPENDS $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(2) ;
        # derive files using file list
        # compile derived files (nonfile target?)
        BRIDGET_FILE_LIST default = $(FILE_LIST)Bridget ;
        BRIDGET_CFLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;
        BRIDGET_CFLAGS on $(1) += -pipe ;
        # seed search paths with target-wide values
        HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
        FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

        # We must compile with the extension-specific build flags
        BRIDGET_CFLAGS on $(1) += $($(2:S)_CFLAGS) ;
        # Add debug flags, if appropriate.
        if $(DEBUGGING_SYMBOLS) = YES {
            BRIDGET_CFLAGS on $(1) += -g ;
        }
        # Add profiling flags, if appropriate.
        if $(PROFILING_CODE) = YES {
            BRIDGET_CFLAGS on $(1) += -pg ;
        }
        # Pass the trusted-precomp file name to the compiler to keep track
        # of which precompiled headers it has already sanity checked.
        if $(OS) in MACOS DARWIN {
            BRIDGET_CFLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
        }
        if $(CPP_HEADERMAP_FILE) {
            BRIDGET_CFLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
        }
        if YES in $(GENERATE_CPP_ILOG_FILES) {
            local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
            BRIDGET_CFLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
        }
        if $(PREFIX_HEADER) {
            PREFIX_HEADER_CFLAGS on $(1) += -include $(PREFIX_HEADER) ;
        }
        Bridget.DeriveAndCompileC $(BRIDGET_DERIVE_AND_COMPILE_C_TAG) : $(2) ;
    }
}
# Bridget.UpdateJavaFileList <list update target> <bridget file> generates draft
# and updates definitive list if it is missing or out of date
actions Bridget.UpdateJavaFileList
{
    $(BRIDGET) -listjava "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" >> "$(1:G=)Draft" && \
    if [ ! -e "$(1:G=)" ]; then
        cp "$(1:G=)Draft" "$(1:G=)"
    else 
        _file_list_diffs=`diff --brief "$(1:G=)Draft" "$(1:G=)"`
        if [ "x$_file_list_diffs" != "x" ]; then
            cp "$(1:G=)Draft" "$(1:G=)"
        fi
    fi
}
actions Bridget.DeriveAndCompileJava.javac
{
    $(BRIDGET) -java -o "$(BRIDGET_FILES_DIR)" "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" && \
    frameworkjars="" && \
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done && \
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath` && \
    cd "$(BRIDGET_FILES_DIR)" && \
    $(JAVA_COMPILER) $(JAVAC_FLAGS) -sourcepath "$(JAVA_SOURCE_PATH)" -classpath "$classpath" -d "$(CLASS_FILE_DIR)" @"$(BRIDGET_DERIVED_JAVA_FILE_LIST:G=)" && \
    /usr/bin/touch "$(1:G=)"
}
actions Bridget.DeriveAndCompileJava.jikes
{
    $(BRIDGET) -java -o "$(BRIDGET_FILES_DIR)" "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" && \
    frameworkjars="" && \
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done && \
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath` && \
    cd "$(BRIDGET_FILES_DIR)" && \
    $(JAVA_COMPILER) +E $(JAVAC_FLAGS) -classpath "$classpath" -d "$(CLASS_FILE_DIR)" `cat "$(BRIDGET_DERIVED_JAVA_FILE_LIST:G=)"` && \
    /usr/bin/touch "$(1:G=)"
}

# Bridget.CompileC.UpdateFileList <list update target> <bridget file> generates draft
# and updates definitive list if it is missing or out of date
actions Bridget.UpdateCFileList
{
    $(BRIDGET) -listobjc "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" >> "$(1:G=)Draft" && \
    if [ ! -e "$(1:G=)" ]; then
        cp "$(1:G=)Draft" "$(1:G=)"
    else 
        _file_list_diffs=`diff --brief "$(1:G=)Draft" "$(1:G=)"`
        if [ "x$_file_list_diffs" != "x" ]; then
            cp "$(1:G=)Draft" "$(1:G=)"
        fi
    fi
}
actions Bridget.DeriveAndCompileC
{
    $(BRIDGET) -stub -init -o "$(BRIDGET_FILES_DIR)" "-I$(BRIDGET_FILES_DIR)" "-I$(SOURCE_ROOT)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(JAVA_HEADERS_DIR)" "$(BRIDGETFLAGS)" "$(OTHER_BRIDGETFLAGS)" "$(2)" && \
    cd "$(BRIDGET_FILES_DIR)" && \
    $(CC) -c $(ARCH_FLAGS) -O -fno-common -no-cpp-precomp -dynamic "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(HEADER_SEARCH_PATHS)" "-I$(JAVA_HEADERS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(TARGET_BUILD_DIR)/$(PUBLIC_HEADER_DIR:G=)" "-I$(TARGET_BUILD_DIR)/$(PRIVATE_HEADER_DIR:G=)" "$(BRIDGET_CFLAGS)" $(PREFIX_HEADER_CFLAGS) `cat "$(BRIDGET_DERIVED_C_FILE_LIST:G=)"` && \
    find "$(BRIDGET_FILES_DIR)" -type f -name '*.o' -print > "$(BRIDGET_FILE_LIST:G=)" && \
    /usr/bin/touch "$(1:G=)"
}

# GenerateVectorLibraryIntermediates <vector stub> <vector object file> : <exports file>
# Generates and compiles vector stub
rule GenerateVectorLibraryIntermediates
{
    DEPENDS $(1) : $(2) ;
    LOCATE on $(2) = $(SOURCE_ROOT) ;
    VECTOR_STUB on $(1) = $(VECTOR_STUB) ;
    VECTOR_OBJECT_FILE on $(1) = $(VECTOR_OBJECT_FILE) ;
    VECTOR_FRAGMENT_NAME on $(1) = $(VECTOR_FRAGMENT_NAME) ;
    DYLIB_INSTALLED_NAME on $(1) = $(DYLIB_INSTALLED_NAME) ;
    DEPENDS $(VECTOR_STUB) : $(DERIVED_FILE_DIR) ;
}
actions GenerateVectorLibraryIntermediates
{
    $(MAKEPSEUDOLIB) "$(2)" -p -strip -fragname "$(VECTOR_FRAGMENT_NAME)" -vector "$(VECTOR_STUB)" -dylibpath "$(DYLIB_INSTALLED_NAME)"
    $(CC) -Wa,-L -c $(ARCH_FLAGS) -O -fno-common -no-cpp-precomp -dynamic "$(FLAGS)" $(GLOBAL_CFLAGS) -o "$(VECTOR_OBJECT_FILE)" "$(VECTOR_STUB)"
}

MASTER_INTERFACES default = /AppleInternal/Carbon/interfaces ;
# !!!:cmolick:20010412 Apple internal RC_ settings nonempty in offical builds
INTERFACER_TARGET_UPDATE default = \"$(RC_ProjectName)-$(RC_ProjectSourceVersion)~$(RC_ProjectBuildVersion)\" ;

rule InterfacerHeaders
{
    INTERFACER_CACHE default = $(TEMP_DIR)$(/)InterfacerCache ;
    local BUILD_DIR_AND_SEPARATOR = $(TARGET_BUILD_DIR)$(/) ;
    INTERFACER_HEADERS = $(1:G=InterfacerHeaders) ;
    if $(INTERFACER_TARGET_UPDATE) {
        INTERFACER_HEADER_OPTIONS += -externalHeader $(INTERFACER_TARGET_UPDATE) ;
    }
    FULL_PUBLIC_HEADER_DIR = $(BUILD_DIR_AND_SEPARATOR)$(PUBLIC_HEADER_DIR:G=) ;
    FULL_PUBLIC_HEADER_DIR on $(INTERFACER_HEADERS) = $(FULL_PUBLIC_HEADER_DIR) ;
    FULL_PRIVATE_HEADER_DIR = $(BUILD_DIR_AND_SEPARATOR)$(PRIVATE_HEADER_DIR:G=) ;
    FULL_PRIVATE_HEADER_DIR on $(INTERFACER_HEADERS) = $(FULL_PRIVATE_HEADER_DIR) ;
   # Create symlink to public header dir in versioned frameworks
    if $(PUBLIC_HEADER_LINK)
      && ! $(PUBLIC_HEADER_LINK) in $(PRODUCT_FILES) {
        SymLink $(PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
        ProductFile $(PUBLIC_HEADER_LINK) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PUBLIC_HEADER_LINK default = $(PUBLIC_HEADER_LINK:G=aside) ;
            SymLink $(ASIDE_PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
            ProductFileAside $(ASIDE_PUBLIC_HEADER_LINK) ;
        }
        NOUPDATE $(PUBLIC_HEADER_LINK) ;
    }
    # Create symlink to private header dir in versioned frameworks
    if $(PRIVATE_HEADER_LINK)
      && ! $(PRIVATE_HEADER_LINK) in $(PRODUCT_FILES) {
        SymLink $(PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
        ProductFile $(PRIVATE_HEADER_LINK) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PRIVATE_HEADER_LINK default = $(PRIVATE_HEADER_LINK:G=aside) ;
            SymLink $(ASIDE_PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
            ProductFileAside $(ASIDE_PRIVATE_HEADER_LINK) ;
        }
        NOUPDATE $(PRIVATE_HEADER_LINK) ;
    }

    if $(_BUILD_PHASING) = YES {
        BUILD_PHASE_PRODUCTS += $(INTERFACER_HEADERS) ;
    }

#    Mkdir $(FULL_PUBLIC_HEADER_DIR) ;
#    DEPENDS $(INTERFACER_HEADERS) : $(FULL_PUBLIC_HEADER_DIR) ;
#    DEPENDS $(INTERFACER_HEADERS) : $(BUILD_DIR_AND_SEPARATOR)$(PUBLIC_HEADER_DIR:G=) ;
#    if ! $(PUBLIC_HEADER_LINK) in $(PRODUCT_FILES) {
#        SymLink $(BUILD_DIR_AND_SEPARATOR)$(PUBLIC_HEADER_LINK:G=) : $(PUBLIC_HEADER_LINK_PATH) ;
#    }
#    Mkdir $(FULL_PRIVATE_HEADER_DIR) ;
#    DEPENDS $(INTERFACER_HEADERS) : $(FULL_PRIVATE_HEADER_DIR) ;
#    DEPENDS $(INTERFACER_HEADERS) : $(BUILD_DIR_AND_SEPARATOR)$(PRIVATE_HEADER_DIR:G=) ;
#    if ! $(PRIVATE_HEADER_LINK) in $(PRODUCT_FILES) {
#        SymLink $(BUILD_DIR_AND_SEPARATOR)$(PRIVATE_HEADER_LINK:G=) : $(PRIVATE_HEADER_LINK_PATH) ;
#    }
#    if $(_BUILD_PHASING) = YES {
#        BUILD_PHASE_PRODUCTS += $(FULL_PUBLIC_HEADER_DIR) ;
#        BUILD_PHASE_PRODUCTS += $(FULL_PRIVATE_HEADER_DIR) ;
#        BUILD_PHASE_PRODUCTS += $(BUILD_DIR_AND_SEPARATOR)$(PUBLIC_HEADER_LINK:G=) ;
#        BUILD_PHASE_PRODUCTS += $(BUILD_DIR_AND_SEPARATOR)$(PRIVATE_HEADER_LINK:G=) ;
#    }
    # Create a public header directory
    if ! $(PUBLIC_HEADER_DIR) in $(PRODUCT_FILES) {
        Mkdir $(PUBLIC_HEADER_DIR) ;
        ProductFile $(PUBLIC_HEADER_DIR) ;
        DEPENDS $(INTERFACER_HEADERS) : $(PUBLIC_HEADER_DIR) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PUBLIC_HEADER_DIR default = $(PUBLIC_HEADER_DIR:G=aside) ;
            Mkdir $(ASIDE_PUBLIC_HEADER_DIR) ;
            ProductFileAside $(ASIDE_PUBLIC_HEADER_DIR) ;
        }
    }
    # Create a private header directory
    if ! $(PRIVATE_HEADER_DIR) in $(PRODUCT_FILES) {
        Mkdir $(PRIVATE_HEADER_DIR) ;
        ProductFile $(PRIVATE_HEADER_DIR) ;
        DEPENDS $(INTERFACER_HEADERS) : $(PRIVATE_HEADER_DIR) ;
        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
            ASIDE_PRIVATE_HEADER_DIR default = $(PRIVATE_HEADER_DIR:G=aside) ;
            Mkdir $(ASIDE_PRIVATE_HEADER_DIR) ;
            ProductFileAside $(ASIDE_PRIVATE_HEADER_DIR) ;
        }
    }

    Interfacer.Headers $(INTERFACER_HEADERS) ;
    # Interfacer headers are required (ideally these should be phase products)
    DEPENDS $(1) : $(INTERFACER_HEADERS) ;
}

actions Interfacer.Headers
{
    $(INTERFACER) -masterInterfaces "$(MASTER_INTERFACES)/" -cacheFolder "$(INTERFACER_CACHE)/" $(INTERFACER_HEADER_OPTIONS) -c -rez -framework "$(1:D=:S=:G=)" -p -generated "c=$(FULL_PUBLIC_HEADER_DIR:G=)/" -generatedPriv "c=$(FULL_PRIVATE_HEADER_DIR:G=)/" -generated "rez=$(FULL_PUBLIC_HEADER_DIR:G=)/" -generatedPriv "rez=$(FULL_PRIVATE_HEADER_DIR:G=)/"
}

rule InterfacerExportSetsAndGlue
{
    INTERFACER_CACHE default = $(TEMP_DIR)$(/)InterfacerCache ;
    EXPORT_SETS_DIR default = $(DERIVED_FILE_DIR)$(/)ExportSets ;
    UPP_GLUE_DIR default = $(DERIVED_FILE_DIR)$(/)UPPGlue ;
    COMPONENT_GLUE_DIR default = $(DERIVED_FILE_DIR)$(/)ComponentGlue ;
    RAW_GENERATED_EXPORTS_FILE default = $(EXPORT_SETS_DIR)$(/)fw_$(PRODUCT_NAME)_X.exp ;
    RAW_GENERATED_PRIVATE_EXPORTS_FILE default = $(EXPORT_SETS_DIR)$(/)fw_$(PRODUCT_NAME)Priv_X.exp ;
    # !!!:cmolick:20000602 private exports file optional...bad depend?
    PROCESSED_EXPORTS_FILE default = $(DERIVED_FILE_DIR)$(/)$(PRODUCT_NAME).exp ;
    DEPENDS $(RAW_GENERATED_EXPORTS_FILE) : $(DERIVED_FILE_DIR) ;
    DEPENDS $(RAW_GENERATED_PRIVATE_EXPORTS_FILE) : $(DERIVED_FILE_DIR) ;
    DEPENDS $(PROCESSED_EXPORTS_FILE) : $(DERIVED_FILE_DIR) ;
    # object file dir needs to be in place for glue object file list
    # !!!:cmolick:20020105 this dependence appears superfluous
    # DEPENDS $(PROCESSED_EXPORTS_FILE) : $(RAW_GENERATED_EXPORTS_FILE) ;
    DEPENDS $(1) : $(PROCESSED_EXPORTS_FILE) ;
    if $(GENERATE_HEADERS) = YES {
        DEPENDS $(RAW_GENERATED_EXPORTS_FILE) : $(INTERFACER_HEADERS) ;
        DEPENDS $(PROCESSED_EXPORTS_FILE) : $(INTERFACER_HEADERS) ;
    }
    if $(_BUILD_PHASING) = YES {
        BUILD_PHASE_PRODUCTS += $(RAW_GENERATED_EXPORTS_FILE) $(PROCESSED_EXPORTS_FILE) ;
    }
    HEADER_SEARCH_PATHS on $(RAW_GENERATED_EXPORTS_FILE) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(RAW_GENERATED_EXPORTS_FILE) = $(FRAMEWORK_SEARCH_PATHS) ;
    if $(GENERATE_COMPONENT_GLUE) = YES {
        INTERFACER_FLAGS += -componentGlueC ;
        INTERFACER_COMPONENT_GLUE_FLAGS = -generated "componentGlueC=$(COMPONENT_GLUE_DIR)/" -generatedPriv "componentGlueC=$(COMPONENT_GLUE_DIR)/" ;
    }
    for VARIANT in $(BUILD_VARIANTS) {
        DEPENDS $(PROCESSED_EXPORTS_FILE) : $(OBJECT_FILE_DIR_$(VARIANT)) ;
    }
    GLUE_FILE_LIST default = $(TEMP_DIR)$(/)GlueFileList ;
    #!!!:cmolick:20020319 bad build_variants reference was here at one time
    Interfacer.RawExportSetsAndGlue $(RAW_GENERATED_EXPORTS_FILE) $(GLUE_FILE_LIST) : $(1) ;
    ProductFile $(RAW_GENERATED_EXPORTS_FILE) ;
    ProductFile $(GLUE_FILE_LIST) ;
    ADDITIONAL_EXPORTS_FILE on $(PROCESSED_EXPORTS_FILE) = $(ADDITIONAL_EXPORTS_FILE) ;
    ADDITIONAL_TRADITIONAL_EXPORTS_FILE on $(PROCESSED_EXPORTS_FILE) = $(ADDITIONAL_TRADITIONAL_EXPORTS_FILE) ;
    Interfacer.PrepareExportList $(PROCESSED_EXPORTS_FILE) : $(RAW_GENERATED_EXPORTS_FILE) ;
    ProductFile $(PROCESSED_EXPORTS_FILE) ;
    #!!!:cmolick:200203019 this dependence seems necessary for correct order
    DEPENDS $(PROCESSED_EXPORTS_FILE) : $(RAW_GENERATED_EXPORTS_FILE) ;
    EXPORTED_SYMBOLS_FILE default = $(PROCESSED_EXPORTS_FILE) ;
    ProcessFile $(1) : $(EXPORTED_SYMBOLS_FILE) ;
}

actions Interfacer.RawExportSetsAndGlue
# Generates export sets and UPP glue with Interfacer,
# then attempts to compile UPP glue and add resulting
# object files to a list to use at link time.
{
    $(INTERFACER) -masterInterfaces "$(MASTER_INTERFACES)/" -cacheFolder "$(INTERFACER_CACHE)/" -exportset -uppGlueC "$(INTERFACER_FLAGS)" -framework "$(2[1]:G=:D=:S=)" -p -generated "exportset=$(EXPORT_SETS_DIR)/" -generatedPriv "exportset=$(EXPORT_SETS_DIR)/" -generated "uppGlueC=$(UPP_GLUE_DIR)/" -generatedPriv "uppGlueC=$(UPP_GLUE_DIR)/" $(INTERFACER_COMPONENT_GLUE_FLAGS)
    if [ -e "$(UPP_GLUE_DIR)" ]; then
        _upp_glue_modules=`ls "$(UPP_GLUE_DIR)"`
        if [ ! "$_upp_glue_modules" = x"$_upp_glue_modules" ]; then
            cd "$(UPP_GLUE_DIR)"
            for _upp_glue in *.c ; do
                $(CC) -c $(ARCH_FLAGS) -O -fno-common -no-cpp-precomp -dynamic -Wmost -Wno-four-char-constants -fpascal-strings -fwritable-strings -fexceptions -DCARBON_THRASH=1 -DforCarbon=1 -DACCESSORS_CALLS_ARE_FUNCTIONS=1 -DUSE_INVOKEUPP_C_GLUE=1 "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(BUILT_PRODUCTS_DIR)/$(PUBLIC_HEADER_DIR:G=)" "-I$(BUILT_PRODUCTS_DIR)/$(PRIVATE_HEADER_DIR:G=)" $_upp_glue
            done
            find "$(UPP_GLUE_DIR)" -type f -name '*.i.o' -print > "$(GLUE_FILE_LIST)"
        fi
    fi
    if [ -e "$(COMPONENT_GLUE_DIR)" ]; then
        _component_glue_modules=`ls "$(COMPONENT_GLUE_DIR)"`
        if [ ! "$_component_glue_modules" = x"$_component_glue_modules" ]; then
            cd "$(COMPONENT_GLUE_DIR)"
            for _component_glue in *.c ; do
                $(CC) -c $(ARCH_FLAGS) -O -fno-common -no-cpp-precomp -dynamic -Wmost -Wno-four-char-constants -fpascal-strings -fwritable-strings -fexceptions -DCARBON_THRASH=1 -DforCarbon=1 -DACCESSORS_CALLS_ARE_FUNCTIONS=1 -DUSE_INVOKEUPP_C_GLUE=1 "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(HEADER_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(BUILT_PRODUCTS_DIR)/$(PUBLIC_HEADER_DIR:G=)" "-I$(BUILT_PRODUCTS_DIR)/$(PRIVATE_HEADER_DIR:G=)" $_component_glue
            done
            find "$(COMPONENT_GLUE_DIR)" -type f -name '*.i.o' -print >> "$(GLUE_FILE_LIST)"
        fi
    fi
}

actions Interfacer.PrepareExportList
# Translates PEF-oriented Interfacer export list output into
# nmedit-compatible export lists for use with mach-o.
{
    _initial_working_dir=`pwd`
    cd "$(EXPORT_SETS_DIR)"
    ls | $(EGREP) '^fw_$(PRODUCT_NAME)(Priv)?_.+.exp$' > "$(EXPORT_SETS_DIR)$(/)_GeneratedExports"
    cat `cat "$(EXPORT_SETS_DIR)$(/)_GeneratedExports"` > "$(EXPORT_SETS_DIR)$(/)_Generated.exp"
    cat "$(EXPORT_SETS_DIR)$(/)_Generated.exp" | grep -v ^\* | grep -v ^# | grep -v ^\$ | sort | uniq -u | sed -e '1,$ s/^/_/' > "$(1)"
    cd "$_initial_working_dir"
    _additional_exports_file="$(ADDITIONAL_EXPORTS_FILE)"
    if [ "x$_additional_exports_file" != "x" ]; then
        if [ -f "$_additional_exports_file" ]; then
            cat "$_additional_exports_file" >> "$(1)"
        fi
    fi
    _additional_traditional_exports_file="$(ADDITIONAL_TRADITIONAL_EXPORTS_FILE)"
    if [ "x$_additional_traditional_exports_file" != "x" ]; then
        if [ -f "$_additional_traditional_exports_file" ]; then
            cat "$_additional_traditional_exports_file" |
             grep -v ^\* | grep -v ^# | grep -v ^\$ | sort | uniq -u | sed -e '1,$ s/^/_/' >> "$(1)"
        fi
    fi
}


# Linking, class archive generation, and related operations:
#
# Variables used by linking operations:
# FLAGS.o of target, LDFLAGS, SECTORDER_FLAGS
# LIBRARY_SEARCH_PATHS, FRAMEWORK_SEARCH_PATHS,
# and optionally LINK_FILE_LIST and INIT_ROUTINE

# ClassArchive <archive> : <class file dir>
# Generates an archive that stores class files in the given directory
rule ClassArchive {
    if $(JAVA_ARCHIVE_TYPE) = JAR {
        local JARFLAGS = $(JAVA_JAR_FLAGS) ;
        if $(JAVA_MANIFEST_FILE) {
            DEPENDS $(1) : $(JAVA_MANIFEST_FILE) ;
            JAVA_MANIFEST_FILE on $(1) = $(SOURCE_ROOT)$(/)$(JAVA_MANIFEST_FILE) ;
            JARFLAGS = $(JARFLAGS)m ;
        }
        JARFLAGS = $(JARFLAGS)f ;
        if $(JAVA_ARCHIVE_COMPRESSION) != YES {
            JARFLAGS = $(JARFLAGS)0 ;
        }
        JARFLAGS += -J-Dfile.encoding=UTF8 ;
        JARFLAGS on $(1) = $(JARFLAGS) ;
	CLASS_FILE_DIR on $(1) = $(CLASS_FILE_DIR) ;
        ClassArchive.jarArchive $(1) : $(2) ;
    }
    else {
        if $(JAVA_ARCHIVE_TYPE) = ZIP {
            local ZIPFLAGS = $(JAVA_ZIP_FLAGS) ;
            if $(JAVA_ARCHIVE_COMPRESSION) != YES {
                ZIPFLAGS = $(ZIPFLAGS)0 ;
            }
            ZIPFLAGS on $(1) = $(ZIPFLAGS) ;
	    CLASS_FILE_DIR on $(1) = $(CLASS_FILE_DIR) ;
            ClassArchive.zipArchive $(1) : $(2) ;
        }
    }
}
# Use jar command to generate an archive
# from the class file list after removing "./" from each file path
actions ClassArchive.jarArchive {
    cd "$(2)" && $(MKDIR) -p "$(1:D)" && $(JAR) $(JARFLAGS) $(OTHER_JARFLAGS) "$(JAVA_MANIFEST_FILE)" "$(1)" .
}
# Use zip command to generate an archive
# from the class file list after removing "./" from each file path
actions ClassArchive.zipArchive {
    cd "$(2)" && $(MKDIR) -p "$(1:D)" && $(ZIP) $(ZIPFLAGS) $(OTHER_ZIPFLAGS) "$(1)" .
}

# Bulk copy of class files
# ClassCopy <product class file dir> : <compiled class file dir>
actions ClassCopy {
    $(MKDIR) -p "$(1:G=)" && cd "$(2:G=)" && $(PAX) -pe -rw . "$(1:G=)"
}

# Unarchive <location> : <archive>
rule Unarchive
{
    _DESTINATION_DIR = $(1:G=) ;
    if ! $(_DESTINATION_DIR) in $(PRODUCT_FILES) {
        Mkdir $(_DESTINATION_DIR) ;
        ProductFile $(_DESTINATION_DIR) ;
    }
    DEPENDS $(1) : $(_DESTINATION_DIR) ;
    DEPENDS $(1) : $(2) ;
    switch $(2:S) {
        case ".jar" : UnarchiveJar $(1) : $(2) ;
        case ".zip" : UnarchiveZip $(1) : $(2) ;
    }
}

# we use unzip to unarchive jars since it's much faster than jar, and we can exclude the manifest file
actions UnarchiveJar
{
    $(UNZIP) -oq "$(2)" -x META-INF/MANIFEST.MF -d "$(1:G=)"
}

actions UnarchiveZip
{
    $(UNZIP) -oq "$(2)" -d "$(1:G=)"
}

# ProcessSingleObjectLink <executable> : <inputs> : <rule>
# Calls link rule which then calls ProcessLink
# in order to generate a master object file
# which is also used for symbol editing
rule ProcessSingleObjectLink
{
    local OTHER_LINKED_FILES ;
    # Master object file kept in other directory to avoid name conflict

    MASTER_OBJECT_FILE_$(VARIANT) default = $(OBJECT_FILE_DIR_$(VARIANT))$(/)ProjectBuilderMasterObjectFile.o ;
    NonObjectFiles OTHER_LINKED_FILES : $(LINKED_FILES_$(VARIANT)) ;
    MasterObjectFile $(MASTER_OBJECT_FILE_$(VARIANT)) : $(OBJECT_FILES_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE) ;
    if $(OTHER_LINKED_FILES) = "" {
        OTHER_LINKED_FILES = $(MASTER_OBJECT_FILE_$(VARIANT)) ;
    }
    else {
        OTHER_LINKED_FILES += $(MASTER_OBJECT_FILE_$(VARIANT)) ;
    }
    if $(VECTOR_OBJECT_FILE) {
        OTHER_LINKED_FILES += $(VECTOR_OBJECT_FILE) ;
    }
    $(3) $(INNER_PRODUCT_$(VARIANT)) : $(OTHER_LINKED_FILES) ;
}

# ProcessLinkWithArchitectureSpecificEditing <executable> : <inputs> : <rule>
rule ProcessLinkWithArchitectureSpecificEditing
{
    for ARCH in $(ARCHS) {
        MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT) default = $(OBJECT_FILE_DIR_$(VARIANT))$(/)ProjectBuilderMasterObjectFile$(ARCH).o ;
        MasterObjectFile $(MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT)) : $(OBJECT_FILES_$(ARCH)_$(VARIANT)) : $(EXPORTED_SYMBOLS_FILE_$(ARCH)) ;
    }
    NonObjectFiles OTHER_LINKED_FILES : $(LINKED_FILES_$(VARIANT)) ;
    for ARCH in $(ARCHS) {
        if $(OTHER_LINKED_FILES) = "" {
            OTHER_LINKED_FILES = $(MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT)) ;
        }
        else {
            OTHER_LINKED_FILES += $(MASTER_OBJECT_FILE_$(ARCH)_$(VARIANT)) ;
        }
    }
    if $(VECTOR_OBJECT_FILE) {
        OTHER_LINKED_FILES += $(VECTOR_OBJECT_FILE) ;
    }
    $(3) $(INNER_PRODUCT_$(VARIANT)) : $(OTHER_LINKED_FILES) ;
}

# ProcessLink <executable> : <inputs> : <rule>
# Processes <inputs> into <rule>.ARGUMENTS for later use by the <rule> rule
# where <inputs> are object files, libraries, frameworks, object file lists,
# and such and where <rule> is one of StaticLibrary, DynamicLibrary, or
# StandaloneExecutable.
rule ProcessLink
{
    local RULE = $(3) ;
    # Link as standalone executable unless another rule is specified
    RULE default = StandaloneExecutable ;
    # Set rule-specific flags such as StandaloneExecutable.FILELIST_FLAG
    # and store the values in local variables
    local FILELIST_FLAG = $($(RULE).FILELIST_FLAG:G=) ;
    local LIBRARY_FLAG = $($(RULE).LIBRARY_FLAG:G=) ;
    local FRAMEWORK_FLAG = $($(RULE).FRAMEWORK_FLAG:G=) ;
    local FILELIST_NOSPACE = $($(RULE).FILELIST_FLAG:G) ;
    local LIBRARY_NOSPACE = $($(RULE).LIBRARY_FLAG:G) ;
    local FRAMEWORK_NOSPACE = $($(RULE).FRAMEWORK_FLAG:G) ;
    local BATCH_OFILES = $($(RULE).BATCH_OFILES) ;
    # The product depends on all of the input files, although
    # library and framework references may not be resolvable.
    DEPENDS $(1) : $(2) ;
    # link depends on file list
    LINK_FILE_LIST_$(VARIANT) = $(FILE_LIST_$(VARIANT)) ;
    DEPENDS $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    # Deal with each input file in turn
    local LINKED ;
    local ARGUMENT ;
    for LINKED in $(2) {
        $(RULE).FILES$(LINKED:S) on $(1) += $(LINKED) ;
        switch $(LINKED:BS) {
            case *.o :
                # If $(BATCH_OFILES) is true then object file lists are generated.
                if $(BATCH_OFILES) != NO {
                    ClearFileList $(LINK_FILE_LIST_$(VARIANT)) ;
                    AppendToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
                    DEPENDS $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
                } else {
                    $(RULE).ARGUMENTS on $(1) += $(LINKED) ;
                }
            case *.objects :
                if $(FILELIST_NOSPACE) {
                    ARGUMENT = $(FILELIST_FLAG)$(LINKED) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    NOTFILE $(FILELIST_FLAG) ;
                    ARGUMENT = $(FILELIST_FLAG) $(LINKED) ;
                }
                $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
            case lib*.a :
                if $(LIBRARY_FLAG) {
                    LINKED = $(LINKED:A) ;
                }
                NOCARE $(LINKED) ;
                if $(LIBRARY_NOSPACE) {
                    ARGUMENT = $(LIBRARY_FLAG)$(LINKED) ;
                } else {
                    ARGUMENT = $(LIBRARY_FLAG) $(LINKED) ;
                }
                $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                NOTFILE $(ARGUMENT) ;
            case *.lib :
                NOCARE $(LINKED) ;
                if $(LIBRARY_FLAG) {
                    if $(LIBRARY_NOSPACE) {
                        ARGUMENT = $(LIBRARY_FLAG)$(LINKED:A) ;
                    } else {
                        ARGUMENT = $(LIBRARY_FLAG) $(LINKED:A) ;
                    }
                    $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    ECHO jam: warning: For target $(1), rule $(RULE) will ignore $(LINKED) ;
                }
            case *.dylib :
                NOCARE $(LINKED) ;
                if $(LIBRARY_FLAG) {
                    if $(LIBRARY_NOSPACE) {
                        ARGUMENT = $(LIBRARY_FLAG)$(LINKED:A) ;
                    } else {
                        ARGUMENT = $(LIBRARY_FLAG) $(LINKED:A) ;
                    }
                    $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    ECHO jam: warning: For target $(1), rule $(RULE) will ignore $(LINKED) ;
                }
            case *.framework :
                NOCARE $(LINKED) ;
                if $(FRAMEWORK_FLAG) {
                    if $(FRAMEWORK_NOSPACE) {
                        ARGUMENT = $(FRAMEWORK_FLAG)$(LINKED:B) ;
                    } else {
                        ARGUMENT = $(FRAMEWORK_FLAG) $(LINKED:B) ;
                    }
                    $(RULE).ARGUMENTS on $(1) += $(ARGUMENT) ;
                    NOTFILE $(ARGUMENT) ;
                } else {
                    ECHO jam: warning: For target $(1), rule $(RULE) will ignore $(LINKED) ;
                }
	    case *.jar :
		# silently ignore Java archives since they are valid, but not used for native linking
	    case *.zip :
		# silently ignore Java archives since they are valid, but not used for native linking
            case * :
                ECHO Warning: $(RULE): Unknown extension on "$(LINKED:BS)" when linking with $(RULE) ;
        }
    }
    # include any object files compiled from objc generated with bridget
    if $(BRIDGET_FILE_LIST) {
        AppendFileToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(BRIDGET_FILE_LIST) ;
    }
    if $(BATCH_OFILES) != NO {
        $(RULE).LinkUsingFileList $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    }
    else {
        $(RULE).Link $(1) ;
    }
}

actions quietly together piecemeal ClearFileList
{
    $(RM) -rf "$(1)"
}

actions quietly together piecemeal AppendToFileList
{
    for file_reference in "$(2)"
    do
        $(ECHO) "$file_reference" >> "$(1)"
    done
}

actions quietly together piecemeal AppendFileToFileList
{
    cat "$(2)" >> "$(1)"
}

# StaticLibrary <library> : <inputs>
# Stores <inputs> in <library> where <inputs> are object files,
# libraries, frameworks, object file lists, and such
rule StaticLibrary
{
    LIBRARY_SEARCH_PATHS on $(1) = $(LIBRARY_SEARCH_PATHS) ;
    ProcessLink $(1) : $(2) : StaticLibrary ;
    FLAGS.o on $(1) = $(LDFLAGS) $(SECTORDER_FLAGS) ;
}
actions together StaticLibrary
{
}
actions quietly together piecemeal StaticLibrary.Link bind StaticLibrary.ARGUMENTS
{
    ( $(LIBTOOL) -o "$(1)" "$(2)" "-L$(LIBRARY_SEARCH_PATHS)" "$(StaticLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) && $(RANLIB) "$(1)" )
}
actions quietly together piecemeal StaticLibrary.LinkUsingFileList bind StaticLibrary.ARGUMENTS
{
    ( $(LIBTOOL) -o "$(1)" "-L$(LIBRARY_SEARCH_PATHS)" -filelist "$(2)" "$(StaticLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) && $(RANLIB) "$(1)" )
}
StaticLibrary.FRAMEWORK_FLAG = ;
StaticLibrary.LIBRARY_FLAG = ;
StaticLibrary.BATCH_OFILES default = YES ;

# StandaloneExecutable <executable> : <inputs>
# Links <inputs> to produce <executable>, where <inputs> are objects,
# libraries, frameworks, and such.
rule StandaloneExecutable
{
    ProcessLink $(1) : $(2) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    LIBRARY_SEARCH_PATHS on $(1) = $(LIBRARY_SEARCH_PATHS) ;
    FLAGS.o on $(1) = $(ARCH_FLAGS) $(LDFLAGS) $(SECTORDER_FLAGS) ;
    if $(INIT_ROUTINE) {
        FLAGS.o on $(1) += -init $(INIT_ROUTINE) ;
    }
}
StandaloneExecutable.FILELIST_FLAG = -filelist ;
StandaloneExecutable.FRAMEWORK_FLAG = -framework ;
StandaloneExecutable.LIBRARY_FLAG = <nospace>-l ;
StandaloneExecutable.BATCH_OFILES default = YES ;
actions together StandaloneExecutable
{
}
actions quietly together StandaloneExecutable.Link bind StandaloneExecutable.ARGUMENTS
{
    $(_LD_FOR_LINKING) -o "$(1)" "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) "$(StandaloneExecutable.ARGUMENTS)"
}
actions quietly together StandaloneExecutable.LinkUsingFileList bind StandaloneExecutable.ARGUMENTS
{
    $(_LD_FOR_LINKING) -o "$(1)" "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" -filelist "$(2)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG) "$(StandaloneExecutable.ARGUMENTS)"
}


# DynamicLibrary <library> : <objects> : <libraries>
# Links <objects> and <libraries> to produce <library>, using $(FLAGS.o)
rule DynamicLibrary
{
    LIBRARY_SEARCH_PATHS on $(1) = $(LIBRARY_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    ProcessLink $(1) : $(2) : DynamicLibrary ;
    FLAGS.o on $(1) = $(ARCH_FLAGS) $(LDFLAGS) $(SECTORDER_FLAGS) ;
    if $(INIT_ROUTINE) {
        FLAGS.o on $(1) += -init $(INIT_ROUTINE) ;
    }
}
actions together DynamicLibrary
{
}
actions quietly together DynamicLibrary.Link bind DynamicLibrary.ARGUMENTS DynamicLibrary.DEFFILE
{
    $(_LD_FOR_LINKING) -o "$(1)" $(DynamicLibrary.DEFFILE_FLAG)"$(DynamicLibrary.DEFFILE)" "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" "$(DynamicLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG)
}
actions quietly together DynamicLibrary.LinkUsingFileList bind DynamicLibrary.ARGUMENTS DynamicLibrary.DEFFILE
{
    $(_LD_FOR_LINKING) -o "$(1)" $(DynamicLibrary.DEFFILE_FLAG)"$(DynamicLibrary.DEFFILE)" "-L$(LIBRARY_SEARCH_PATHS)" "-F$(FRAMEWORK_SEARCH_PATHS)" -filelist "$(2)" "$(DynamicLibrary.ARGUMENTS)" "$(FLAGS.o)" $(INSTALLED_NAME_FLAG)
}
DynamicLibrary.DEFFILE_FLAG = "-Xlinker -DEF:" ;
DynamicLibrary.FILELIST_FLAG = -filelist ;
DynamicLibrary.FRAMEWORK_FLAG = -framework ;
DynamicLibrary.LIBRARY_FLAG = <nospace>-l ;
DynamicLibrary.BATCH_OFILES default = YES ;

# MasterObjectFile <master object file> : <object files> : <exports file> : [<arch>]
# Merges many object files into one in order to edit
# the list of exported symbols
rule MasterObjectFile
{
    local OBJECT_FILE ;
    if $(4) {
        LINK_FILE_LIST_$(VARIANT) = $(FILE_LIST_$(VARIANT))Prelink_$(4) ;
    }
    else {
        LINK_FILE_LIST_$(VARIANT) = $(FILE_LIST_$(VARIANT))Prelink ;
    }
    # object files must be present before master can be assembled
    DEPENDS $(1) : $(2) ;
    # list object files in a file to limit link line length
    DEPENDS $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    ClearFileList $(LINK_FILE_LIST_$(VARIANT)) ;
    for LINKED in $(2) {
        AppendToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
        DEPENDS $(LINK_FILE_LIST_$(VARIANT)) : $(LINKED) ;
    }
    if $(KEEP_PRIVATE_EXTERNS) != NO {
        KEEP_PRIVATE_EXTERNS_FLAG on $(1) = -keep_private_externs ;
    }
    if $(GLUE_FILE_LIST) {
        DEPENDS $(LINK_FILE_LIST_$(VARIANT)) : $(GLUE_FILE_LIST) ;
        AppendFileToFileList $(LINK_FILE_LIST_$(VARIANT)) : $(GLUE_FILE_LIST) ;
    }
    PRELINK_FLAGS on $(1) = $(PRELINK_FLAGS) ;
    PRELINK_LIBS on $(1) = $(PRELINK_LIBS) ;
    if $(_BUILD_PHASING) = YES {
        BUILD_PHASE_PRODUCTS += $(1) ;
    }
    MasterObjectFile.Combine $(1) : $(LINK_FILE_LIST_$(VARIANT)) ;
    if $(3) {
        INCLUDES $(1) : $(3) ;
        MasterObjectFile.EditExports $(1) : $(3) ;
    }
}
actions MasterObjectFile.Combine
{
    $(_LD_FOR_LINKING) $(ARCH_FLAGS) $(KEEP_PRIVATE_EXTERNS_FLAG) $(GLOBAL_CFLAGS) "$(PRELINK_FLAGS)" -nostdlib -filelist "$(2)" -r -o "$(1)" "$(PRELINK_LIBS)"
}
actions MasterObjectFile.EditExports
{
    $(NMEDIT) -s "$(2)" "$(1)" -o "$(1)"
}

# Ranlib <library>
# Ranlib for static library
actions Ranlib
{
    $(RANLIB) "$(1)"
}

# VersioningSystem_next-cvs <product>
# Handles automatic generation of CVSVersionInfo.txt file for projects that use NeXT CVS-style versioning.
rule VersioningSystem_next-cvs
{
    local VERSION_INFO_FILE ;
    VERSION_INFO_FILE default = $(1:B)_vers.c ;
    # Make sure that the C file containing the version string gets created.
    VersioningSystem_next-cvs.Create $(VERSION_INFO_FILE) : $(1:B) ;
    DerivedFiles $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = YES ;
    ProcessFile $(1) : $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = NO ;

    # Set up default values for the variables.
    CVS_VERS_FILE default = CVSVersionInfo.txt ;
}
rule VersioningSystem_next-cvs.Create
{
    DEPENDS $(1) : $(CVS_VERS_FILE) ;
}
actions VersioningSystem_next-cvs.Create
{
    versFile="$(CVS_VERS_FILE)"
    awk=/usr/bin/awk
    user=`$awk '/\\$\Id:/ {print $7;}' $versFile`
    timestamp=`$awk '/\\$\Id:/ {print $5 " " $6;}' $versFile`
    fileVers=`$awk '/\\$\Id:/ {print $4;}' $versFile`
    name=`$awk '/^ProjectName:/ {print $2;}' $versFile`
    tag=`$awk '/\\$\Name:/ {print $3;}' $versFile`
    versNum=`$awk '/^ProjectVersion:/ {print $2;}' $versFile`
    proj="$(2:B)"
    clean_proj_name=`echo $proj | sed 's/[^0-9A-Za-z]/_/g'`
    # the keyword name is the current tag and only gets filled in if the files are extracted at
    # that tag. If the tag has a value, then it is a released version, if the tag is '$' then
    # it has no value and is a development version.
    case $tag in '$') vers="$versNum.dev";; *) vers=$versNum;; esac
    q='"'
    vers_str="Project:$proj Version:$vers (Checkpoint by:$user on:$timestamp revision:$fileVers)"
    vers_suffix="$(CURRENT_PROJECT_VERSION_SUFFIX)"
    echo "const char "$clean_proj_name"_VERS_STRING[] = $q@(#)$vers_str$q;" > "$(1)"
    echo "const char "$clean_proj_name"_VERS_NUM[] = $q$vers$vers_suffix$q;" >> "$(1)"
}

# VersioningSystem_apple-generic <product>
# Generates <product>_vers.c to define version symbol
rule VersioningSystem_apple-generic
{
    # Set values to use
    local VERSION_INFO_FILE ;
    VERSION_INFO_FILE default = $(1:B)_vers.c ;

    # variables used need to be defined on the version info file target
    CURRENT_PROJECT_VERSION on $(VERSION_INFO_FILE) = $(CURRENT_PROJECT_VERSION) ;
    VERSION_INFO_EXPORT_DECL on $(VERSION_INFO_FILE) default = $(VERSION_INFO_EXPORT_DECL) ;
    VERSION_INFO_PREFIX on $(VERSION_INFO_FILE) default = $(VERSION_INFO_PREFIX) ;
    VERSION_INFO_SUFFIX on $(VERSION_INFO_FILE) default = $(VERSION_INFO_SUFFIX) ;
    VERSION_INFO_BUILDER on $(VERSION_INFO_FILE) default = $(USER) ;

    # Create versioning code
    VersioningSystem_apple-generic.Create $(VERSION_INFO_FILE) : $(1) ;
    DerivedFiles $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = YES ;
    ProcessFile $(1) : $(VERSION_INFO_FILE) ;
    SUPPRESS_PREFIX_HEADER = NO ;
}
actions VersioningSystem_apple-generic.Create
{
    raw_project_name="$(PROJECT)"
    project_name=`echo $raw_project_name | sed 's/[^0-9A-Za-z]/_/g'`
    raw_target_name="$(2:B)"
    target_name=`echo $raw_target_name | sed 's/[^0-9A-Za-z]/_/g'`
    project_vers="$(CURRENT_PROJECT_VERSION)"
    vers_info_export_decl="$(VERSION_INFO_EXPORT_DECL)"
    vers_info_prefix="$(VERSION_INFO_PREFIX)"
    vers_info_suffix="$(VERSION_INFO_SUFFIX)"
    vers_info_builder="$(VERSION_INFO_BUILDER)"
    echo ${vers_info_export_decl} " const unsigned char ${vers_info_prefix}${target_name}VersionString${vers_info_suffix}[] =  \"@(#)PROGRAM:${target_name}  PROJECT:${project_name}-${project_vers}  DEVELOPER:${vers_info_builder}  BUILT:\" __DATE__  \" \" __TIME__ \"\n\";" > "$(1)"
    echo ${vers_info_export_decl} " const double ${vers_info_prefix}${target_name}VersionNumber${vers_info_suffix} = (double)${project_vers};" >> "$(1)"
}

# KernelModuleGeneratedSource
# Creates a kernel module source stub based on the values
# of MODULE_VERSION, MODULE_START, and MODULE_STOP
rule KernelModuleGeneratedSource
{
    MODULE_INFO_FILE_$(VARIANT) default = $(1:B)_info.c ;
    DerivedFiles $(MODULE_INFO_FILE_$(VARIANT)) ;
    DEPENDS $(MODULE_INFO_FILE_$(VARIANT)) : $(MODULE_INFO_PLIST) ;
    MODULE_VERSION on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_VERSION) ;
    MODULE_NAME on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_NAME) ;
    if $(MODULE_IOKIT) = "YES" {
        MODULE_START on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
        MODULE_STOP on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
    }
    else {
        if $(MODULE_START) = "" {
            MODULE_START on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
        } else {
            MODULE_START on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_START) ;
        }
        if $(MODULE_STOP) = "" {
            MODULE_STOP on $(MODULE_INFO_FILE_$(VARIANT)) = 0 ;
        } else {
            MODULE_STOP on $(MODULE_INFO_FILE_$(VARIANT)) = $(MODULE_STOP) ;
        }
    }
    KernelModuleGeneratedSource.Create $(MODULE_INFO_FILE_$(VARIANT)) ;
    SUPPRESS_PREFIX_HEADER = YES ;
    ProcessFile $(1) : $(MODULE_INFO_FILE_$(VARIANT)) ;
    SUPPRESS_PREFIX_HEADER = NO ;
}
actions KernelModuleGeneratedSource.Create
{
    /bin/echo "#include <mach/mach_types.h>" > "$(1)"
    /bin/echo " " >> "$(1)"
    /bin/echo "extern kern_return_t _start(kmod_info_t *ki, void *data);" >> "$(1)"
    /bin/echo "extern kern_return_t _stop(kmod_info_t *ki, void *data);" >> "$(1)"
    if [ $(MODULE_START) != 0 ]; then
        /bin/echo "__private_extern__ kern_return_t $(MODULE_START)(kmod_info_t *ki, void *data);" >> "$(1)"
    fi
    if [ $(MODULE_STOP) != 0 ]; then
        /bin/echo "__private_extern__ kern_return_t $(MODULE_STOP)(kmod_info_t *ki, void *data);" >> "$(1)"
    fi
    /bin/echo " " >> "$(1)"
    /bin/echo "KMOD_EXPLICIT_DECL($(MODULE_NAME), \"$(MODULE_VERSION)\", _start, _stop)" >> "$(1)"
    /bin/echo "__private_extern__ kmod_start_func_t *_realmain = $(MODULE_START);" >> "$(1)"
    /bin/echo "__private_extern__ kmod_stop_func_t *_antimain = $(MODULE_STOP);" >> "$(1)"
}

# GenerateFrameworkStub <framework stub>
# Invokes a custom tool to generate a Mach-O framework executable stub at the specified path
# Also be sure to the FRAMEWORK_INSTALL_NAME variable on the <framework stub>
actions GenerateFrameworkStub
{
    $(MKDIR:Q) -p $(DERIVED_FILE_DIR:Q)
    dummy_class_name=`echo -n $(1:B) | tr -c '[:alnum:]' '_'`
    $(ECHO:Q) "@interface NSFramework_${dummy_class_name}" > $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(ECHO:Q) "@end" >> $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(ECHO:Q) "@implementation NSFramework_${dummy_class_name}" >> $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(ECHO:Q) "@end" >> $(DERIVED_FILE_DIR:Q)/framework_stub.m
    $(CC:Q) -c $(DERIVED_FILE_DIR:Q)/framework_stub.m -o $(DERIVED_FILE_DIR:Q)/framework_stub.o
    $(_LD_FOR_LINKING:Q) -dynamiclib $(INSTALLED_NAME_FLAG) $(DYLIB_VERSION_FLAGS:Q) -L$(LIBRARY_SEARCH_PATHS:Q) -F$(FRAMEWORK_SEARCH_PATHS:Q) $(DynamicLibrary.ARGUMENTS:Q) $(DERIVED_FILE_DIR:Q)/framework_stub.o -o $(1:Q)
    $(STRIP:Q) $(STRIPFLAGS:Q) $(1:Q)
}
# Copyright (c) 1999-2002 Apple Computer, Inc.
# All rights reserved.

# Define reasonable base locations, to be overridden by default

# Build intermediates go into TEMP_ROOT which defaults to
# build/intermediates in current directory, or OBJROOT if defined
TEMP_ROOT default = $(OBJROOT) ;

# Builds go into the BUILD_ROOT which defaults to
# build/products in current directory, or SYMROOT if defined
BUILD_ROOT default = $(SYMROOT) ;

# Installation root defaults to root, or DSTROOT if defined
INSTALL_ROOT default = $(DSTROOT) ;

# Set initial values for installation information and framework version
_BUILD_PHASING default = YES ;
export INSTALL_OWNER default = $(USER) ;
export INSTALL_GROUP default = $(GROUP) ;
export INSTALL_MODE_FLAG default = "ugo-w,o+rX" ;
export FRAMEWORK_VERSION default = "A" ;
REMOVE_CVS_FROM_RESOURCES default = YES ;
COPY_PHASE_STRIP default = NO ;
PREBINDING default = YES ;
SET_DIR_MODE_OWNER_GROUP default = YES ;
SET_FILE_MODE_OWNER_GROUP default = NO ;

# Set initial optimization level, debug, and profile settings
export OPTIMIZATION_LEVEL default = 0 ;
export DEBUGGING_SYMBOLS default = YES ;
export PROFILING_CODE default = NO ;

# Default settings for Java builds
JAVA_ARCHIVE_CLASSES default = YES ;
JAVA_ARCHIVE_TYPE default = JAR ;
JAVA_APP_STUB default = /System/Library/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub ;
JAVA_JAR_FLAGS default = cv ;
JAVA_SOURCE_SUBDIR default = . ;
JAVA_FRAMEWORK_RESOURCES_DIRS default = Resources ;
export JAVA_FRAMEWORK_JARS default = ;
JAVA_USE_DEPENDENCIES default = YES ;
JAVA_ZIP_FLAGS default = -urg ;

JAVA_COMPILER_DEBUGGING_SYMBOLS default = YES ;
JAVA_COMPILER_DISABLE_WARNINGS default = NO ;
JAVA_COMPILER_DEPRECATED_WARNINGS default = NO ;

# These default flags probably shouldn't be overridden by users.
JAVAC_DEFAULT_FLAGS default = -J-Xms64m -J-XX:NewSize=4M -J-Dfile.encoding=UTF8 ;
JIKES_DEFAULT_FLAGS default = +E +OLDCSO ;

# Default variants and flags
# !!!:cmolick:20020226 using all three is an interesting test case
# BUILD_VARIANTS default = normal debug profile ;
BUILD_VARIANTS default = normal ;
_BUILD_PHASES = ;
cc_normal_FLAGS default = ;
cc_debug_FLAGS default = -g ;
cc_profile_FLAGS default = -pg ;

# !!!:cmolick:20020109 Installed product asides on by default for debugging
#INSTALLED_PRODUCT_ASIDES default = YES ;

# BeginProduct <product>
#
# Initializes the directory and file list variables
#
# Variable references:
# BUILD_ROOT			Base directory for builds
# TARGET_NAME			Name of the target that builds this product
# PRODUCT_NAME			Name of the product that's built
# TEMP_ROOT			Base directory for intermediates
# BASE_PROJECT_HEADER_DIR	Base directory for project headers
# HEADER_SUBDIRECTORY		Path prefix in header #include lines
# INSTALL_ROOT			Base directory for installations
# INSTALL_PATH			Subdirectory where product is installed
# PUBLIC_HEADER_DIR		Location for public headers
#
# Variables set:
# HEADER_SUBDIRECTORY		Base product name
# BUILD_COMPONENTS		List may include: headers, build, source
# OPTIMIZATION_CFLAGS		Optimization flags for C compiles
# OTHER_CPLUSPLUSFLAGS		C++ flags default to C values
# WARNING_CPLUSPLUSFLAGS
# INCLUDED_ARCHS		Architectures intended for this build
# NATIVE_ARCH			Architecture of the build machine
# ARCHS				Architectures used for this build
# ARCH_FLAGS			Architecture flags used for most tools
# SOURCE_DIR			
# BUILD_DIR			Target-specific directory for builds
# TEMP_DIR			For target-specific intermediates
# BASE_PROJECT_HEADER_DIR	Location for header clone folders
# PROJECT_HEADER_DIR		Project header file directory in $(TEMP_DIR)
# OBJECT_FILE_DIR		Object file directory in $(TEMP_DIR)
# CLASS_FILE_DIR		Class file directory in $(TEMP_DIR)
# FILE_LIST			Base name for lists of files generated
# DERIVED_FILE_DIR		Derived source directory in $(TEMP_DIR)
# INSTALL_DIR			Directory in $(INSTALL_ROOT) for installations
# HEADER_SEARCH_PATHS		Project header directories prepended
# FRAMEWORK_SEARCH_PATHS	Product build root appended
# DERIVED_FILES			Initialized empty
# OBJECT_FILES			Initialized empty
# LINKED_FILES			Initialized empty
# PRODUCT_FILES			Initialized empty
# PRECOMP_TRUSTFILE		List of trusted precompiled headers
#
rule BeginProduct
{
    # target representing the build must be a nonfile pseudotarget
    NOTFILE $(1) ;

    # define the header subdirectory early since we'll use it to
    # compute the project header directory
    HEADER_SUBDIRECTORY = $(1:B) ;

    # the following sequence of tests sets up CC, CPLUSPLUS, LD, and LDPLUSPLUS appropriately,
    # depending on whether we're using GCC 2.95.2 or GCC 3.x (either explicitly or implicitly)

    # hack to detect attempt to use GCC 3, and to set the 'USE_GCC3' build setting accordingly
    if ( $(CC) = "/usr/bin/gcc3" ) {
        USE_GCC3 default = YES ;
    }
    # if USE_GCC2 has not been explicitly set to YES, and if the default compiler (as detected
    # by pbxbuild) is GCC 3, we set USE_GCC3 to YES so the rest of the logic knows it can do
    # GCC 3 specific stuff
    if ( $(USE_GCC2) != YES )  &&  ( $(_DEFAULT_GCC_VERSION) != "" )  &&  ( $(_DEFAULT_GCC_VERSION) != "2.95.2" ) {
        USE_GCC3 default = YES ;
    }

    # set up CC, CPLUSPLUS, LD, and LDPLUSPLUS appropriately (this logic is temporary, and is
    # expected to be phased out once we have per-build-phase compiler choices)
    if $(USE_GCC3) = YES {
        CC default = /usr/bin/gcc3 ;
        CPLUSPLUS default = /usr/bin/g++3 ;
        # for GCC 3, we use -precomp support (as opposed to PFE support) by default for now
        USE_GCC3_PFE_SUPPORT default = NO ;
    }
    else if $(USE_GCC2) = YES {
        if $(_DEFAULT_GCC_VERSION) = "2.95.2" {
            CC default = /usr/bin/cc ;
            CPLUSPLUS default = /usr/bin/c++ ;
        }
        else {
            CC default = /usr/bin/gcc2 ;
            CPLUSPLUS default = /usr/bin/g++2 ;
        }
    }
    else {
        CC default = /usr/bin/cc ;
        CPLUSPLUS default = /usr/bin/c++ ;
    }
    LD default = $(CC) ;
    LDPLUSPLUS default = $(CPLUSPLUS) ;
    _LD_FOR_LINKING = $(LD) ;   # this might get reset to $(LDPLUSPLUS) in the CompileCplusplus rule

    # Variant suffixes
    for VARIANT in $(BUILD_VARIANTS) {
        if $(VARIANT) = normal {
            VARIANT_SUFFIX_$(VARIANT) = "" ;
        }
        else {
            VARIANT_SUFFIX_$(VARIANT) = _$(VARIANT) ;
        }
    }
    # Set reasonable optimization flags for installs if not already set
    OPTIMIZATION_CFLAGS default = -Os ;
    # C++ options match C options by default
    OTHER_CPLUSPLUSFLAGS default = $(OTHER_CFLAGS) ;
    WARNING_CPLUSPLUSFLAGS default = $(WARNING_CFLAGS) ;
    # Set up architecture options for product
    INCLUDED_ARCHS default = $(SUPPORTED_ARCHITECTURES) ;
    SUPPORTED_ARCHITECTURE_FLAGS = ;
    ARCHS = ;
    if ! $(RC_ARCHS) {
	$(NATIVE_ARCH) = YES ;
        RC_$(NATIVE_ARCH) = YES ;
    }
    for SUPPORTED_ARCHITECTURE in $(SUPPORTED_ARCHITECTURES) {
        if $($(SUPPORTED_ARCHITECTURE)) = YES
         && ( $(SUPPORTED_ARCHITECTURE) in $(INCLUDED_ARCHS) )
         && ( $(SUPPORTED_ARCHITECTURE) in $(VALID_ARCHS) ) {
            SUPPORTED_ARCHITECTURE_FLAGS += -arch $(SUPPORTED_ARCHITECTURE) ;
            ARCHS += $(SUPPORTED_ARCHITECTURE) ;
        }
    }
    ARCH_FLAGS default = $(SUPPORTED_ARCHITECTURE_FLAGS) ;
    # Initialize the directory variables
    # SOURCE_DIR is the location of installed sources
    SOURCE_DIR default = $(INSTALL_ROOT) ;
    BUILD_DIR default = $(BUILD_ROOT) ;
    # create base build dir
    Mkdir $(BUILD_DIR) ;
    ProductFile $(BUILD_DIR) ;
    # create active build dir
    if $(TARGET_BUILD_DIR) && ($(TARGET_BUILD_DIR) != $(BUILD_DIR)) {
        Mkdir $(TARGET_BUILD_DIR) ;
    }
    # asides
    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
        ASIDE_DIR default = $(BUILD_ROOT) ;
        Mkdir $(ASIDE_DIR) ;
        ProductFile $(ASIDE_DIR) ;
    }
    # define other important locations
    TEMP_DIR default = $(TEMP_ROOT)$(/)$(PROJECT_NAME).build$(/)$(TARGET_NAME).build ;
    if $(CLONE_HEADERS) = YES {
        if $(HEADER_SUBDIRECTORY) {
            PROJECT_HEADER_DIR default = $(BASE_PROJECT_HEADER_DIR)$(/)$(HEADER_SUBDIRECTORY) ;
        }
        else {
            PROJECT_HEADER_DIR default = $(BASE_PROJECT_HEADER_DIR) ;
        }
    }
    OBJECT_FILE_DIR default = $(TEMP_DIR)$(/)Objects ;
    export CLASS_FILE_DIR default = $(TEMP_DIR)$(/)JavaClasses ;
    for VARIANT in $(BUILD_VARIANTS) {
        OBJECT_FILE_DIR_$(VARIANT) default = $(OBJECT_FILE_DIR)-$(VARIANT) ;
        FILE_LIST_$(VARIANT) default = $(OBJECT_FILE_DIR_$(VARIANT))$(/)LinkFileList ;
        # initialize file lists
        OBJECT_FILES_$(VARIANT) = ;
        LINKED_FILES_$(VARIANT) = ;
    }
    if $(JAVA_ARCHIVE_CLASSES) != YES && ( $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Library ) {
        export PRODUCT_CLASS_FILE_DIR default = $(TARGET_BUILD_DIR)$(/)$(PRODUCT_NAME) ;
    }
    DERIVED_FILE_DIR default = $(TEMP_DIR)$(/)DerivedSources ;
    if $(INSTALL_PATH) {
        INSTALL_DIR default = $(INSTALL_ROOT)$(/)$(INSTALL_PATH) ;
    }
    else {
        INSTALL_DIR default = $(INSTALL_ROOT) ;
    }
    # Initialize the search paths
    if $(CLONE_HEADERS) = YES {
        if $(TARGET_BUILD_DIR) != $(BUILD_DIR) {
            HEADER_SEARCH_PATHS = $(PROJECT_HEADER_DIR) $(TARGET_BUILD_DIR)$(/)include $(BUILD_DIR)$(/)include $(HEADER_SEARCH_PATHS) ;
        }
        else {
            HEADER_SEARCH_PATHS = $(PROJECT_HEADER_DIR) $(BUILD_DIR)$(/)include $(HEADER_SEARCH_PATHS) ;
        }
        FRAMEWORK_SEARCH_PATHS = $(BASE_PROJECT_HEADER_DIR) $(BUILD_ROOT) $(INSTALL_DIR) $(FRAMEWORK_SEARCH_PATHS) ;
    }
    else {
        if $(TARGET_BUILD_DIR) != $(BUILD_DIR) {
            HEADER_SEARCH_PATHS = $(TARGET_BUILD_DIR)$(/)include $(BUILD_DIR)$(/)include $(HEADER_SEARCH_PATHS) ;
        }
        else {
            HEADER_SEARCH_PATHS = $(BUILD_DIR)$(/)include $(HEADER_SEARCH_PATHS) ;
        }
        FRAMEWORK_SEARCH_PATHS = $(BUILD_ROOT) $(FRAMEWORK_SEARCH_PATHS) ;
    }
    LIBRARY_SEARCH_PATHS = $(BUILD_ROOT) $(LIBRARY_SEARCH_PATHS) ;
    if $(DEPLOYMENT_LOCATION) = YES && $(BUILT_PRODUCTS_DIR) {
        HEADER_SEARCH_PATHS = $(BUILT_PRODUCTS_DIR)$(/)include $(HEADER_SEARCH_PATHS) ;
        FRAMEWORK_SEARCH_PATHS = $(BUILT_PRODUCTS_DIR) $(FRAMEWORK_SEARCH_PATHS) ;
        LIBRARY_SEARCH_PATHS = $(BUILT_PRODUCTS_DIR) $(LIBRARY_SEARCH_PATHS) ;
    }
    # Initialize the file lists
    DERIVED_FILES = ;
    PRODUCT_FILES = ;
    PRECOMP_TRUSTFILE default = $(TEMP_DIR)$(/)TrustedPrecomps.txt ;
    # Make symlink to product in products dir,
    # and also set product mode and ownership
    # unless there is no nonempty product name.
    if $(DEPLOYMENT_LOCATION) = YES {
        if $(WRAPPER)
         && $(PRODUCT_TYPE) != Tool
         && $(PRODUCT_TYPE) != Library {
            # Use WRAPPER when defined for bundle product
            _INSTALLED_PRODUCT = $(TARGET_BUILD_DIR)$(/)$(WRAPPER) ;
            _PRODUCT_REFERENCE default = $(BUILT_PRODUCTS_DIR:G=ProductRef)$(/)$(WRAPPER) ;
            #!!!:cmolick:20020517:this may be bad for non-deployment location
            if $(DEPLOYMENT_POSTPROCESSING) = YES {
                SetModeOwnerAndGroup $(_INSTALLED_PRODUCT:G=ModeOwnerGroup) : $(_INSTALLED_PRODUCT) ;
            }
            SymLink $(_PRODUCT_REFERENCE) : $(_INSTALLED_PRODUCT) ;
            DEPENDS $(_PRODUCT_REFERENCE) : $(BUILT_PRODUCTS_DIR) ;
            DEPENDS $(1) : $(_PRODUCT_REFERENCE) ;
        }
        else {
            if $(1:G=) {
                # Use nonempty, ungristed primary target for tool or library product
                _INSTALLED_PRODUCT = $(TARGET_BUILD_DIR)$(/)$(1:G=) ;
                _PRODUCT_REFERENCE default = $(BUILT_PRODUCTS_DIR:G=ProductRef)$(/)$(1:G=) ;
                SymLink $(_PRODUCT_REFERENCE) : $(_INSTALLED_PRODUCT) ;
                DEPENDS $(_PRODUCT_REFERENCE) : $(BUILT_PRODUCTS_DIR) ;
                DEPENDS $(1) : $(_PRODUCT_REFERENCE) ;
            }
        }
    }
    # Run the hack script to build debug and profile variants, if appropriate.
    if $(INTERNAL_BUILD_VARIANTS)
     && ( $(RC_JASPER) || $(INTERNAL_BUILD_VARIANTS_ONLY_IN_JASPER) != YES )
     && ( $(ACTION) = build || $(ACTION) = install ) {
        # build variants list should be used only by this call in this case
        _INTERNAL_BUILD_VARIANTS = $(INTERNAL_BUILD_VARIANTS) ;
        INTERNAL_BUILD_VARIANTS = ;
        INTERNAL_BUILD_VARIANTS on $(1) = $(_INTERNAL_BUILD_VARIANTS) ;
        RunVariantHackScript $(1) ;
    }
}

# EndProduct <product>
#
# Creates BUILD_DIR, OBJECT_FILE_DIR, CLASS_FILE_DIR, DERIVED_FILE_DIR,
# and the PROJECT_HEADER_DIR if necessary, then sets up the build action.
rule EndProduct
{
    # Create required directories.  This is done here to allow
    # variables to be overridden before this rule is evaluated.
    if $(CLONE_HEADERS) = YES && $(PROJECT_HEADER_DIR) {
        Mkdir $(PROJECT_HEADER_DIR) ;
        PRODUCT_FILES += $(PROJECT_HEADER_DIR) ;
        DEPENDS $(1) : $(PROJECT_HEADER_DIR) ;
    }
    for VARIANT in $(BUILD_VARIANTS) {
        Mkdir $(OBJECT_FILE_DIR_$(VARIANT)) ;
        PRODUCT_FILES += $(OBJECT_FILE_DIR_$(VARIANT)) ;
        DEPENDS $(1) : $(OBJECT_FILE_DIR_$(VARIANT)) ;
    }
    if $(DEPLOYMENT_LOCATION) {
        Mkdir $(BUILT_PRODUCTS_DIR) ;
        PRODUCT_FILES += $(BUILT_PRODUCTS_DIR) ;
        DEPENDS $(1) : $(BUILT_PRODUCTS_DIR) ;
    }
    Mkdir $(CLASS_FILE_DIR) ;
    PRODUCT_FILES += $(CLASS_FILE_DIR) ;
    DEPENDS $(1) : $(CLASS_FILE_DIR) ;
    Mkdir $(DERIVED_FILE_DIR) ;
    PRODUCT_FILES += $(DERIVED_FILE_DIR) ;
    DEPENDS $(1) : $(DERIVED_FILE_DIR) ;
    # Set up post-phase processing
    if $(POST_PHASE_PRODUCTS) {
        DEPENDS $(1) : $(POST_PHASE_PRODUCTS) ;
        DEPENDS $(POST_PHASE_PRODUCTS) : $(_BUILD_PHASES) ;
    }
    # Alternative catch-all mechanism to set mode and ownership of files
    # that for some reason require this post build processing.
    if $(ACTION) = install {
    for ALTERNATE_PERMISSIONS_FILE in $(ALTERNATE_PERMISSIONS_FILES) {
        ALTERNATE_PERMISSIONS_FILE_PATH = $(INSTALL_DIR)$(/)$(ALTERNATE_PERMISSIONS_FILE) ;
        ALTERNATE_PERMISSIONS_TARGET = $(ALTERNATE_PERMISSIONS_FILE:G=AlternatePermissions) ;
        NOTFILE $(ALTERNATE_PERMISSIONS_TARGET) ;
        DEPENDS $(1) : $(ALTERNATE_PERMISSIONS_TARGET) ;
        DEPENDS $(ALTERNATE_PERMISSIONS_TARGET) : $(_BUILD_PHASES) ;
        if $(ALTERNATE_MODE) {
            INSTALL_MODE_FLAG on $(ALTERNATE_PERMISSIONS_TARGET) = $(ALTERNATE_MODE) ;
        }
        if $(ALTERNATE_OWNER) {
            INSTALL_OWNER on $(ALTERNATE_PERMISSIONS_TARGET) = $(ALTERNATE_OWNER) ;
        }
        if $(ALTERNATE_GROUP) {
            INSTALL_GROUP on $(ALTERNATE_PERMISSIONS_TARGET) = $(ALTERNATE_GROUP) ;
        }
        SetModeOwnerAndGroup $(ALTERNATE_PERMISSIONS_TARGET) : $(ALTERNATE_PERMISSIONS_FILE_PATH) ;
    }
    }
    # Define actions for this target
    Actions $(1) ;
}

# BeginWrappedProduct <product>
#
# Sets additional variables required for wrapped products,
# primarily to assign locations within the product wrapper.
# WRAPPER			Local convenience variable
# WRAPPER_SUFFIX		Based on WRAPPER_EXTENSION by default
# RESOURCE_DIR			Base bundle resources location
# APPLESCRIPTS_DIR		Compiled AppleScript files folder
# [PUBLIC|PRIVATE]_HEADER_[CLONE_][DIR|LINK|LINK_PATH] Header folders
# WRAPPER_CLONE_DIR		Base location for header clone framework
# CURRENT_VERSION[_CLONE]_[DIR|LINK|LINK_PATH]
# HEADERDOC_DIR			Headerdoc output folder
# PRODUCT_CLASS_FILE_DIR	Defined if JAVA_ARCHIVE_CLASSES	is set
# 
rule BeginWrappedProduct
{
    # define wrapper using appropriate extension and suffix
    if $(WRAPPER_EXTENSION) {
        WRAPPER_SUFFIX = .$(WRAPPER_EXTENSION) ;
    }
    if $(WRAPPER_SUFFIX) {
        WRAPPER = $(1:G=:S=$(WRAPPER_SUFFIX)) ;
    }
    else {
        WRAPPER = $(1:G=) ;
    }
    # set up the basic product variables
    BeginProduct $(1) ;
    # define and create wrapper and make primary nonfile target depend on it
    LOCATE on $(WRAPPER) = $(TARGET_BUILD_DIR) ;
    Mkdir $(WRAPPER) ;
    PRODUCT_FILES += $(WRAPPER) ;
    DEPENDS $(1) : $(WRAPPER) ;
    if $(PRODUCT_TYPE) = Application {
        # Application wrappers
        if $(PURE_JAVA) = YES {
            RESOURCE_DIR default = $(WRAPPER) ;
        }
        else {
            RESOURCE_DIR default = $(WRAPPER)$(/)Contents$(/)Resources ;
        }
        LOCATE on $(RESOURCE_DIR) = $(TARGET_BUILD_DIR) ;
        RESOURCE_LINK = "" ;
        APPLESCRIPTS_DIR default = $(RESOURCE_DIR)$(/)Scripts ;
        LOCATE on $(APPLESCRIPTS_DIR) = $(TARGET_BUILD_DIR) ;
        PUBLIC_HEADER_DIR default = $(WRAPPER)$(/)"Contents"$(/)Headers ;
        LOCATE on $(PUBLIC_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        PUBLIC_HEADER_LINK default = "" ;
        PRIVATE_HEADER_DIR default = $(WRAPPER)$(/)"Contents"$(/)PrivateHeaders ;
        LOCATE on $(PRIVATE_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        PRIVATE_HEADER_LINK default = "" ;
        CURRENT_VERSION_DIR default = "" ;
        CURRENT_VERSION_LINK default = "" ;
        if $(CLONE_HEADERS) = YES {
            WRAPPER_CLONE_DIR = $(BASE_PROJECT_HEADER_DIR)$(/)$(WRAPPER) ;
            PUBLIC_HEADER_CLONE_DIR default = $(WRAPPER_CLONE_DIR)$(/)"Contents"$(/)Headers ;
            LOCATE on $(PUBLIC_HEADER_CLONE_DIR) = $(TARGET_BUILD_DIR) ;
            PUBLIC_HEADER_CLONE_LINK default = "" ;
            PRIVATE_HEADER_CLONE_DIR default = $(WRAPPER_CLONE_DIR)$(/)"Contents"$(/)PrivateHeaders ;
            LOCATE on $(PRIVATE_HEADER_CLONE_DIR) = $(TARGET_BUILD_DIR) ;
            PRIVATE_HEADER_CLONE_LINK default = "" ;
            CURRENT_VERSION_CLONE_DIR default = "" ;
            CURRENT_VERSION_CLONE_LINK default = "" ;
        }
    } # application wrappers
    else if $(PRODUCT_TYPE) = Framework {
        # Framework wrappers
        RESOURCE_DIR default = $(WRAPPER)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)Resources ;
        LOCATE on $(RESOURCE_DIR) = $(TARGET_BUILD_DIR) ;
        RESOURCE_LINK default = $(WRAPPER)$(/)Resources ;
        LOCATE on $(RESOURCE_LINK) = $(TARGET_BUILD_DIR) ;
        RESOURCE_LINK_PATH default = Versions$(/)Current$(/)Resources ;
        APPLESCRIPTS_DIR default = $(RESOURCE_DIR)$(/)Scripts ;
        LOCATE on $(APPLESCRIPTS_DIR) = $(TARGET_BUILD_DIR) ;
        HAS_PUBLIC_HEADERS = "NO" ;
        PUBLIC_HEADER_DIR default = $(WRAPPER)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)Headers ;
        LOCATE on $(PUBLIC_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        PUBLIC_HEADER_LINK default = $(WRAPPER)$(/)Headers ;
        LOCATE on $(PUBLIC_HEADER_LINK) = $(TARGET_BUILD_DIR) ;
        PUBLIC_HEADER_LINK_PATH default = Versions$(/)Current$(/)Headers ;
        PRIVATE_HEADER_DIR default = $(WRAPPER)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)PrivateHeaders ;
        LOCATE on $(PRIVATE_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
        PRIVATE_HEADER_LINK default = $(WRAPPER)$(/)PrivateHeaders ;
        LOCATE on $(PRIVATE_HEADER_LINK) = $(TARGET_BUILD_DIR) ;
        PRIVATE_HEADER_LINK_PATH default = Versions$(/)Current$(/)PrivateHeaders ;
        CURRENT_VERSION_DIR default = $(WRAPPER:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION) ;
        LOCATE on $(CURRENT_VERSION_DIR) = $(TARGET_BUILD_DIR) ;
        CURRENT_VERSION_LINK default = $(WRAPPER:G=)$(/)Versions$(/)Current ;
        LOCATE on $(CURRENT_VERSION_LINK) = $(TARGET_BUILD_DIR) ;
        CURRENT_VERSION_LINK_PATH default = Versions$(/)Current ;
        if $(CLONE_HEADERS) = YES {
            WRAPPER_CLONE_DIR = $(BASE_PROJECT_HEADER_DIR)$(/)$(WRAPPER) ;
            PUBLIC_HEADER_CLONE_DIR default = $(WRAPPER_CLONE_DIR)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)Headers ;
            LOCATE on $(PUBLIC_HEADER_CLONE_DIR) = $(TARGET_BUILD_DIR) ;
            PUBLIC_HEADER_CLONE_LINK default = $(WRAPPER_CLONE_DIR)$(/)Headers ;
            LOCATE on $(PUBLIC_HEADER_CLONE_LINK) = $(TARGET_BUILD_DIR) ;
            PUBLIC_HEADER_CLONE_LINK_PATH default = Versions$(/)Current$(/)Headers ;
            PRIVATE_HEADER_CLONE_DIR default = $(WRAPPER_CLONE_DIR)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)PrivateHeaders ;
            LOCATE on $(PRIVATE_HEADER_CLONE_DIR) = $(TARGET_BUILD_DIR) ;
            PRIVATE_HEADER_CLONE_LINK default = $(WRAPPER_CLONE_DIR)$(/)PrivateHeaders ;
            LOCATE on $(PRIVATE_HEADER_CLONE_LINK) = $(TARGET_BUILD_DIR) ;
            PRIVATE_HEADER_CLONE_LINK_PATH default = Versions$(/)Current$(/)PrivateHeaders ;
            CURRENT_VERSION_CLONE_DIR default = $(WRAPPER_CLONE_DIR)$(/)Versions$(/)$(FRAMEWORK_VERSION) ;
            CURRENT_VERSION_CLONE_LINK default = $(WRAPPER_CLONE_DIR)$(/)Versions$(/)Current ;
            CURRENT_VERSION_CLONE_LINK_PATH default = Versions$(/)Current ;
        }
        if $(ASIDE_DIR) {
            ASIDE_CURRENT_VERSION_DIR default = $(WRAPPER:G=aside)$(/)Versions$(/)$(FRAMEWORK_VERSION) ;
            ASIDE_CURRENT_VERSION_LINK default = $(WRAPPER:G=aside)$(/)Versions$(/)Current ;
            ASIDE_CURRENT_VERSION_LINK_PATH default = Versions$(/)Current ;
            ASIDE_CURRENT_VERSION_LINK_PATH = $(ASIDE_CURRENT_VERSION_LINK_PATH:G=aside) ;
            Mkdir $(ASIDE_CURRENT_VERSION_DIR) ;
            ProductFileAside $(ASIDE_CURRENT_VERSION_DIR) ;
            DEPENDS $(1) : $(ASIDE_CURRENT_VERSION_DIR) ;
            NOUPDATE $(ASIDE_CURRENT_VERSION_DIR) ;
            SymLink $(ASIDE_CURRENT_VERSION_LINK) : $(FRAMEWORK_VERSION) ;
            ProductFileAside $(ASIDE_CURRENT_VERSION_LINK) ;
            DEPENDS $(1) : $(ASIDE_CURRENT_VERSION_LINK) ;
            DEPENDS $(ASIDE_CURRENT_VERSION_LINK) : $(ASIDE_CURRENT_VERSION_DIR) ;
            NOUPDATE $(ASIDE_CURRENT_VERSION_LINK) ;
        }
        # Create current version directory and link now because
        # they are implicit and needed by almost everything else:
        # Current version dir
        Mkdir $(CURRENT_VERSION_DIR) ;
        ProductFile $(CURRENT_VERSION_DIR) ;
        DEPENDS $(1) : $(CURRENT_VERSION_DIR) ;  # need this or build phase
        NOUPDATE $(CURRENT_VERSION_DIR) ;
        # Current version link
        SymLink $(CURRENT_VERSION_LINK) : $(FRAMEWORK_VERSION) ;
        ProductFile $(CURRENT_VERSION_LINK) ;
        DEPENDS $(1) : $(CURRENT_VERSION_LINK) ;  # need this or build phase
        DEPENDS $(CURRENT_VERSION_LINK) : $(CURRENT_VERSION_DIR) ;
        NOUPDATE $(CURRENT_VERSION_LINK) ;
        if $(CLONE_HEADERS) = YES {
            Mkdir $(CURRENT_VERSION_CLONE_DIR) ;
            ProductFile $(CURRENT_VERSION_CLONE_DIR) ;
            NOUPDATE $(CURRENT_VERSION_CLONE_DIR) ;
            # Current version link
            SymLink $(CURRENT_VERSION_CLONE_LINK) : $(FRAMEWORK_VERSION) ;
            ProductFile $(CURRENT_VERSION_CLONE_LINK) ;
            DEPENDS $(1) : $(CURRENT_VERSION_CLONE_LINK) ;
            DEPENDS $(CURRENT_VERSION_CLONE_LINK) : $(CURRENT_VERSION_CLONE_DIR) ;
            NOUPDATE $(CURRENT_VERSION_CLONE_LINK) ;
            # Make sure someone depends on the clone current symlink so it will get created.
            DEPENDS $(PUBLIC_HEADER_CLONE_LINK) : $(CURRENT_VERSION_CLONE_LINK) ;
            DEPENDS $(PRIVATE_HEADER_CLONE_LINK) : $(CURRENT_VERSION_CLONE_LINK) ;
        }
    } # framework wrappers
    else {
        # Default bundle wrappers
        if $(BUNDLE_STYLE) = SHALLOW {
            # shallow bundles do not have the Contents/Resources folders
            RESOURCE_DIR default = $(WRAPPER) ;
            LOCATE on $(RESOURCE_DIR) = $(TARGET_BUILD_DIR) ;
            APPLESCRIPTS_DIR default = $(WRAPPER)$(/)Scripts ;
            LOCATE on $(APPLESCRIPTS_DIR) = $(TARGET_BUILD_DIR) ;
            PUBLIC_HEADER_DIR default = $(WRAPPER)$(/)Headers ;
            LOCATE on $(PUBLIC_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
            PRIVATE_HEADER_DIR default = $(WRAPPER)$(/)PrivateHeaders ;
            LOCATE on $(PRIVATE_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
            if $(CLONE_HEADERS) = YES {
                WRAPPER_CLONE_DIR = $(BASE_PROJECT_HEADER_DIR)$(/)$(WRAPPER) ;
                PUBLIC_HEADER_CLONE_DIR default = $(WRAPPER_CLONE_DIR)$(/)Headers ;
                LOCATE on $(PUBLIC_HEADER_CLONE_DIR) = $(TARGET_BUILD_DIR) ;
                PRIVATE_HEADER_CLONE_DIR default = $(WRAPPER_CLONE_DIR)$(/)PrivateHeaders ;
                LOCATE on $(PRIVATE_HEADER_CLONE_DIR) = $(TARGET_BUILD_DIR) ;
            }
        }
        else {
            # else, BUNDLE_STYLE=DEEP bundles do have Contents/Resources folders
            RESOURCE_DIR default = $(WRAPPER)$(/)Contents$(/)Resources ;
            LOCATE on $(RESOURCE_DIR) = $(TARGET_BUILD_DIR) ;
            APPLESCRIPTS_DIR default = $(RESOURCE_DIR)$(/)Scripts ;
            LOCATE on $(APPLESCRIPTS_DIR) = $(TARGET_BUILD_DIR) ;
            PUBLIC_HEADER_DIR default = $(WRAPPER)$(/)Contents$(/)Headers ;
            LOCATE on $(PUBLIC_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
            PRIVATE_HEADER_DIR default = $(WRAPPER)$(/)Contents$(/)PrivateHeaders ;
            LOCATE on $(PRIVATE_HEADER_DIR) = $(TARGET_BUILD_DIR) ;
            if $(CLONE_HEADERS) = YES {
                WRAPPER_CLONE_DIR = $(BASE_PROJECT_HEADER_DIR)$(/)$(WRAPPER) ;
                PUBLIC_HEADER_CLONE_DIR default = $(WRAPPER_CLONE_DIR)$(/)Contents$(/)Headers ;
                LOCATE on $(PUBLIC_HEADER_CLONE_DIR) = $(TARGET_BUILD_DIR) ;
                PRIVATE_HEADER_CLONE_DIR default = $(WRAPPER_CLONE_DIR)$(/)Contents$(/)PrivateHeaders ;
                LOCATE on $(PRIVATE_HEADER_CLONE_DIR) = $(TARGET_BUILD_DIR) ;
            }
        }
        RESOURCE_LINK default = "" ;
        PUBLIC_HEADER_LINK default = "" ;
        PRIVATE_HEADER_LINK default = "" ;
        CURRENT_VERSION_DIR default = "" ;
        CURRENT_VERSION_LINK default = "" ;
        if $(CLONE_HEADERS) = YES {
            PUBLIC_HEADER_CLONE_LINK default = "" ;
            PRIVATE_HEADER_CLONE_LINK default = "" ;
            CURRENT_VERSION_CLONE_DIR default = "" ;
            CURRENT_VERSION_CLONE_LINK default = "" ;
        }
    } # all bundle layouts
    # define location for optional header documentation generation
    if $(GENERATE_HEADERDOC) = YES && $(RESOURCE_DIR) {
        HEADERDOC_DIR default = $(TARGET_BUILD_DIR)$(/)$(RESOURCE_DIR)$(/)Documentation ;
        Mkdir $(HEADERDOC_DIR) ;
        ProductFile $(HEADERDOC_DIR) ;
    }

    # wrapped products may define a location for unarchived classes
    if $(JAVA_ARCHIVE_CLASSES) != YES {
        export PRODUCT_CLASS_FILE_DIR default = $(TARGET_BUILD_DIR)$(/)$(RESOURCE_DIR)$(/)Java ;
    }
}

# EndWrappedProduct <product>
#
# Sets up additional dependence related to object files.
# Files depended on by object files should be in compile rules,
# and dependence on object files should be in link rules.
rule EndWrappedProduct
{
    # Wrapper touch updates base container directory timestamp
    # This must be conditional on the "build" component,
    # otherwize installhdrs builds with no headers will fail.
    if build in $(BUILD_COMPONENTS) {
        WRAPPER_TOUCH = $(1:G=Touch) ;
        LOCATE on $(WRAPPER_TOUCH) = $(TARGET_BUILD_DIR) ;
        DEPENDS $(WRAPPER_TOUCH) : $(BUILD_PHASE) ;
        DEPENDS $(1) : $(WRAPPER_TOUCH) ;
        Touch $(WRAPPER_TOUCH) ;
    }
    # wrapper logic complete, now handle final build issues
    EndProduct $(1) ;
}
# Copyright (c) 1999-2002 Apple Computer, Inc.
# All rights reserved.

# Rules for target types include Begin and End rules
# for Tool, Library, Bundle, Application, and Framework

TOOL_SUFFIX default = "" ;
rule BeginTool
{
    export PRODUCT_TYPE = Tool ;
    BeginProduct $(1) ;
}

rule EndTool
{
    EndProduct $(1) ;
}

# Library variable names have the form: $(OS)_$(LIBRARY_STYLE)_LIBRARY_$(VARIABLENAME)
MACOS_STATIC_LIBRARY_PREFIX = lib ;
MACOS_STATIC_LIBRARY_SUFFIX = .a ;
MACOS_DYNAMIC_LIBRARY_PREFIX = "" ;
MACOS_DYNAMIC_LIBRARY_SUFFIX = "" ;
DARWIN_STATIC_LIBRARY_PREFIX = lib ;
DARWIN_STATIC_LIBRARY_SUFFIX = .a ;
DARWIN_DYNAMIC_LIBRARY_PREFIX = "" ;
DARWIN_DYNAMIC_LIBRARY_SUFFIX = "" ;
DYNAMIC_LIBRARY_PREFIX = $($(OS)_DYNAMIC_LIBRARY_PREFIX) ;
DYNAMIC_LIBRARY_SUFFIX = $($(OS)_DYNAMIC_LIBRARY_SUFFIX) ;

rule BeginLibrary
{
    # These evaluations here to pick up style from target settings
    LIBRARY_PREFIX = $($(OS)_$(LIBRARY_STYLE)_LIBRARY_PREFIX) ;
    LIBRARY_SUFFIX = $($(OS)_$(LIBRARY_STYLE)_LIBRARY_SUFFIX) ;
    export PRODUCT_TYPE = Library ;
    BeginProduct $(1) ;
}

rule EndLibrary
{
    EndProduct $(1) ;
}

rule BeginBundle
{
    export PRODUCT_TYPE = Bundle ;
    BeginWrappedProduct $(1) ;
}

rule EndBundle
{
    EndWrappedProduct $(1) ;
}

rule BeginApplication
{
    export PRODUCT_TYPE = Application ;
    BeginWrappedProduct $(1) ;
}

rule EndApplication
{
    EndWrappedProduct $(1) ;
}

rule BeginFramework
{
    export PRODUCT_TYPE = Framework ;
    BeginWrappedProduct $(1) ;
}

rule EndFramework
{
    EndWrappedProduct $(1) ;
}
# Copyright (c) 1999-2002 Apple Computer, Inc.
# All rights reserved.

# Variables referenced:
# BUILD_DIR		Location of built product
# RESOURCE_DIR 		Directory for resource files in product
# *_LINK, *_LINK_PATH	Wrapper versioning information
# *_HEADER_DIR		Directories for headers of product
# _INFO_PLIST_FILE_PATH	Path to Info.plist file (if any), generated by PBXCore
# _PKGINFO_FILE_PATH	Path to PkgInfo file (if any), generated by PBXCore
# _VERSION_PLIST_FILE_PATH     Path to version.plist file (if any), generated by PBXCore
# _PBDEVELOPMENT_PLIST_FILE_PATH       Path to pbdevelopment.plist file (if any), generated by PBXCore
# VERSIONING_SYSTEM	Versioning system to use for product
# JAVA_COMPILE_TARGET	Nonfile target representing all java compiles
# REZ_EXECUTABLE	Run Rez directly on executable to produce fork if YES
# PRESERVE_RESOURCES	Files to be recopied with CpMac after install tar copy
# APPLESCRIPTS_DIR	Directory for compiled AppleScripts
#
# Variables set:
# DERIVED_FILES		Intermediate sources
# OBJECT_FILES		Object files produced by compilations
# LINKED_FILES		Files to be used by a link rule
# PRODUCT_FILES		Files that belong in the built product
# INFO_PLIST_FILE	Info.plist file in product wrapper, copied from PRODUCT_SETTINGS_PATH
# PKGINFO_FILE		PkgInfo file in product wrapper, copied from _PKGINFO_FILE_PATH
# HDRRULE, HDRSCAN	Target specific header scanning information
# FLAGS			Target specific compilation flags
# HEADER_SEARCH_PATHS, FRAMEWORK_SEARCH_PATHS	Target specific search paths
#
# Build phase variables:
# BUILD_PHASE		Target for current build phase
# PREVIOUS_BUILD_PHASE	Target for previous build phase
# BUILD_PHASE_PRODUCTS	Products of current build phase
# PHASE_TARGETS		List of all phase targets for conflict checks

# Source and resource handling rules by extension
.h_RULE		= ProcessHeader ;
.nib_RULE	= ProcessResource ;
.rtf_RULE	= ProcessResource ;
.exe_RULE	= ProcessResource ;
.java_RULE	= ProcessUsingJavaCompiler ;
.applescript_RULE	= ProcessAppleScript ;
.s_RULE		= ProcessC ;
.c_RULE		= ProcessC ;
.adb_RULE	= ProcessC ; # unsupported
.ads_RULE	= ProcessC ; # unsupported
.f_RULE		= ProcessC ; # unsupported
.C_RULE		= ProcessCplusplus ;
.cc_RULE	= ProcessCplusplus ;
.cp_RULE	= ProcessCplusplus ;
.cpp_RULE	= ProcessCplusplus ;
.CPP_RULE       = ProcessCplusplus ;
.cxx_RULE	= ProcessCplusplus ;
.CXX_RULE	= ProcessCplusplus ;
# !!!:cmolick:20020226 note: .C++ not accepted by c++ compiler driver
.c++_RULE	= ProcessCplusplus ;
.m_RULE		= ProcessC ;
.mm_RULE	= ProcessCplusplus ;
.M_RULE		= ProcessCplusplus ;
.exp_RULE	= ProcessExportsFile ;
.defs_RULE	= ProcessUsingMig ;
.mig_RULE	= ProcessUsingMig ;
.l_RULE		= ProcessUsingLex ;
.lm_RULE	= ProcessUsingLex ;
.LM_RULE	= ProcessUsingLex ;
.lmm_RULE	= ProcessUsingLex ;
.lpp_RULE	= ProcessUsingLex ;
.LPP_RULE	= ProcessUsingLex ;
.lxx_RULE	= ProcessUsingLex ;
.LXX_RULE	= ProcessUsingLex ;
.y_RULE		= ProcessUsingYacc ;
.ym_RULE	= ProcessUsingYacc ;
.YM_RULE	= ProcessUsingYacc ;
.ymm_RULE	= ProcessUsingYacc ;
.ypp_RULE	= ProcessUsingYacc ;
.YPP_RULE	= ProcessUsingYacc ;
.yxx_RULE	= ProcessUsingYacc ;
.YXX_RULE	= ProcessUsingYacc ;
.x_RULE		= ProcessUsingRPCGen ;
.jobs_RULE      = ProcessUsingBridget ;
.framework_RULE = ProcessFrameworkOrLibrary ;
.r_RULE		= ProcessRezFile ;
.rsrc_RULE	= ProcessRezFile ;
.RSRC_RULE	= ProcessRezFile ;
.ppob_RULE	= ProcessRezFile ;

# Set the initial list of phase targets to empty
PHASE_TARGETS = ;

# PhaseTarget <phase target variable> <product> <phase name>
# Sets up the given phase target variable based on the target
# and phase name and uses the list of phase targets to attempt
# avoid collisions between targets for phases with the same name.
rule PhaseTarget
{
    local PHASE_SUFFIXES = 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 ;
    local PHASE_TARGET = $(2:G=$(3)) ;
    if $(PHASE_TARGET) in $(PHASE_TARGETS) {
        # attempt differentiation by adding last nonmatching suffix
        for PHASE_SUFFIX in $(PHASE_SUFFIXES) {
            ALTERNATE_PHASE_TARGET = $(2:G=$(3)$(PHASE_SUFFIX)) ;
            if ! $(ALTERNATE_PHASE_TARGET) in $(PHASE_TARGETS) {
                PHASE_TARGET = $(ALTERNATE_PHASE_TARGET) ;
            }
        }
    }
    PHASE_TARGETS += $(PHASE_TARGET) ;
    $(1) = $(PHASE_TARGET) ;
    NOTFILE $(PHASE_TARGET) ;
}

# BuildPhase <phase> <product> <previous phase>
# Set up product (and variant hack) dependence on phase
# and phase dependence on previous phase
# and defines an action to indicate phase completion
rule BuildPhase
{
    # retain a list of all phases
    _BUILD_PHASES += $(1) ;
    # retain name for action echo
    PHASE_NAME on $(1) = $(1:G) ;
    # this build phase depends on the previous phase
    if $(3) {
        DEPENDS $(1) : $(3) ;
    }
    # phase required for parent target
    DEPENDS $(2) : $(1) ;
}
actions BuildPhase
{
    $(ECHO) Completed phase "$(PHASE_NAME)" for "$(1)"
}

# DerivedFiles <derived-files>
# Locates derived files in the derived file directory,
# sees the derived paths with the derived file directory if necessary,
# creates derived subpaths and ads them to derived paths as necessary,
# and makes the derived file depend on all derived paths.
rule DerivedFiles
{
    local DERIVED_FILE ;
    for DERIVED_FILE in $(1) {
        # record any derived headers
        if $(DERIVED_FILE:S) = ".h" {
            DERIVED_HEADERS += $(DERIVED_FILE) ;
        }
        # derived file is a build phase product
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(DERIVED_FILE) ;
        }
        # make and depend on containing directory
        LOCATE on $(DERIVED_FILE) = $(DERIVED_FILE_DIR) ;
        if ! $(DERIVED_PATHS) {
            DERIVED_PATHS = $(DERIVED_FILE_DIR) ;
        }
        local DIR = $(DERIVED_FILE_DIR)$(/)$(DERIVED_FILE:D) ;
        if ! ( $(DIR) in $(DERIVED_PATHS) ) {
            Mkdir $(DIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(DIR) ;
            }
            DERIVED_PATHS += $(DIR) ;
        }
        DEPENDS $(DERIVED_FILE) : $(DERIVED_PATHS) ;
    }
}

# ProductFile <product-file>
# The product file location is set to BUILD_DIR.
# If the reference and containing directory are not already
# in the list of product files, then they are added.  They also
# become build phase products unless phasing is turned off.
rule ProductFile
{
    LOCATE on $(1) = $(TARGET_BUILD_DIR) ;
    if ! $(1) in $(PRODUCT_FILES) {
        PRODUCT_FILES += $(1) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(1) ;
        }
    }
}

# ProductFileAside <file>
# Same as ProductFile, but default location is ASIDE_DIR.
rule ProductFileAside
{
    LOCATE on $(1) = $(ASIDE_DIR) ;
    if ! $(1) in $(PRODUCT_FILES) {
        PRODUCT_FILES += $(1) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(1) ;
        }
    }
}

# SetModeOwnerAndGroup <nonfile gristed target> : <base target>
# Uses given nonfile gristed target to set mode, owner, and group
# of the base product
rule SetModeOwnerAndGroup
{
    NOTFILE $(1) ;
    LOCATE on $(1) = $(TARGET_BUILD_DIR) ;
    POST_PHASE_PRODUCTS += $(1) ;
    if $(INSTALL_MODE_FLAG) {
        SetMode $(1) : $(2) ;
    }
    if $(INSTALL_OWNER) {
        if $(INSTALL_GROUP) {
            SetOwnerAndGroup $(1) : $(2) ;
        }
        else {
            SetOwner $(1) : $(2) ;
        }
    }
    else if $(INSTALL_GROUP) {
        SetGroup $(1) : $(2) ;
    }
}
actions SetMode
{
     $(CHMOD) -RH $(INSTALL_MODE_FLAG) "$(2:G=)"
}
actions SetOwner
{
    $(CHOWN) -RH $(INSTALL_OWNER) "$(2:G=)"
}
actions SetGroup
{
    $(CHOWN) -RH :$(INSTALL_GROUP) "$(2:G=)"
}
actions SetOwnerAndGroup
{
    $(CHOWN) -RH $(INSTALL_OWNER):$(INSTALL_GROUP) "$(2:G=)"
}

rule NoOp
{
    if $(_BUILD_PHASING) = YES {
        PhaseTarget BUILD_PHASE : $(1) : NoOp ;
        BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
        PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
    }
}

# ProcessHeaders <product> <headers>
#
# Process individual headers, call Interfacer to generate headers,
# precompile and assemble implicitly included headers as necessary,
# and run headerdoc.
rule ProcessHeaders
{
    if ( headers in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {

        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : CopyHeaders ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        for FILE in $(2) {
            if $(_BUILD_PHASING) = YES {
                ProcessHeader $(BUILD_PHASE) : $(FILE) ;
            }
            else {
                ProcessHeader $(1) : $(FILE) ;
            }
        }
        
        # conditionally gather documentation generated from headers
        if build in $(BUILD_COMPONENTS) && $(GATHERHEADERDOC) && $(GENERATE_HEADERDOC) = YES && $(HEADERDOC_DIR) && HEADERDOC_TARGETS {
            GATHERED_HEADERDOC_TARGET = masterTOC.html ;
            LOCATE on $(GATHERED_HEADERDOC_TARGET) = $(HEADERDOC_DIR) ;
            DEPENDS $(GATHERED_HEADERDOC_TARGET) : $(HEADERDOC_DIR) ;
            DEPENDS $(GATHERED_HEADERDOC_TARGET) : $(HEADERDOC_TARGETS) ;
            GatheredHeaderDoc $(GATHERED_HEADERDOC_TARGET) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(GATHERED_HEADERDOC_TARGET) ;
            }
        }
    }
    # generate interfacer derived headers
    if headers in $(BUILD_COMPONENTS) && $(GENERATE_HEADERS) = YES {
        InterfacerHeaders $(1) ;
    }
    # :mferris:20011107 Only do IMPLICITLY_INCLUDED_HEADERS business if we are actually building.  No need to do this for installhdrs, and currently, we cannot handle the precompiling aspect of this during installhdrs.  If we ever support building framework precomps (ie if we ever have to invoke the compiler during installhdrs), this needs to be revisited.
    if ( build in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        # if we have a prefix file, and if we're supposed to precompile it, we do so using either GCC 3's PFE mechanism or using cpp-precomp
        if ( $(PREFIX_HEADER) != ""  &&  $(PRECOMPILE_PREFIX_HEADER) = YES ) {
            PFE_FILE_C_DIALECTS default = "c" "objective-c" "c++" "objective-c++" ;
            PRECOMP_DESTINATION_DIR default = $(TEMP_DIR)$(/)PrefixHeaders ;
            Mkdir $(PRECOMP_DESTINATION_DIR) ;
            PRODUCT_FILES += $(PRECOMP_DESTINATION_DIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(PRECOMP_DESTINATION_DIR) ;
            }
            if $(USE_GCC3_PFE_SUPPORT) = YES {
                # We need to precompile the prefix file, and we're using GCC 3.  This means that we need to make an arbitrary number of PFE files, one per language-and-architecture combination.  PFE_FILE_C_DIALECTS gives the languages and ARCHS gives the architectures (although PFE_FILE_C_DIALECTS is only used _inside_ the action of MakePFEFile -- from Jam's perspective, we treat each architecture's PFE file as an atomic unit).  The "effective prefix file" is set to nothing, since we won't be passing a -include directive.  The "EFFECTIVE_PFE_FILE_$(ARCH)" is set to the produced PFE file.
                for ARCH in $(ARCHS) {
                    EFFECTIVE_PFE_FILE_$(ARCH) = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER:BS="-$(ARCH).pfe") ;
                    MakePFEFile $(EFFECTIVE_PFE_FILE_$(ARCH)) : $(PREFIX_HEADER) ;
                    PRODUCT_FILES += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                    if $(_BUILD_PHASING) = YES {
                        BUILD_PHASE_PRODUCTS += $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
                    }
                }
                EFFECTIVE_PREFIX_HEADER = ;  # because with a PFE file, we don't actually pass a -include argument
            }
            else {
                # We need to precompile the prefix file, and we're not using GCC 3.  This means that we create a header stub in a special directory under the TEMP_DIR, precompile that for both C and C++, and then pass the prefix file in the -include.  The "effective prefix file" is set to the prefix file stub.
                local PREFIX_HEADER_STUB = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER:BS) ;
                DEPENDS $(PREFIX_HEADER_STUB) : $(PRECOMP_DESTINATION_DIR) ;
                AbsolutePathImportStub $(PREFIX_HEADER_STUB) : $(PREFIX_HEADER) ;
                INCLUDES $(PREFIX_HEADER_STUB) : $(PREFIX_HEADER) ;
                if ( "c" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c" in $(PFE_FILE_C_DIALECTS) ) {
                    C_PRECOMP_FILE_DESTINATION_PATH = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER_STUB:BS="-gcc3.p") ;
                    PrecompileHeader $(C_PRECOMP_FILE_DESTINATION_PATH) : $(PREFIX_HEADER_STUB) ;
                    PRODUCT_FILES += $(C_PRECOMP_FILE_DESTINATION_PATH) ;
                    if $(_BUILD_PHASING) = YES {
                        BUILD_PHASE_PRODUCTS += $(C_PRECOMP_FILE_DESTINATION_PATH) ;
                    }
                }
                if ( "c++" in $(PFE_FILE_C_DIALECTS) )  ||  ( "objective-c++" in $(PFE_FILE_C_DIALECTS) ) {
                    CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH = $(PRECOMP_DESTINATION_DIR)$(/)$(PREFIX_HEADER_STUB:BS="-gcc3.pp") ;
                    PrecompileHeader $(CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH) : $(PREFIX_HEADER_STUB) ;
                    PRODUCT_FILES += $(CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH) ;
                    if $(_BUILD_PHASING) = YES {
                        BUILD_PHASE_PRODUCTS += $(CPLUSPLUS_PRECOMP_FILE_DESTINATION_PATH) ;
                    }
                }
                EFFECTIVE_PREFIX_HEADER = $(PREFIX_HEADER_STUB) ;
            }
        }
        else {
            EFFECTIVE_PREFIX_HEADER = $(PREFIX_HEADER) ;
        }
    }
    # phase end logic
    # THIS *MUST* COME *AFTER* ALL OTHER WORK FOR THIS PHASE!!!
    # cmolick:20020213 ideally this should be within action conditionals,
    #  but that is difficult now that there are three disjointed ones,
    #  so checking to see if the build phase is defined is a hack
    #  the problem of bad DEPENDS here on clean for now.
    if $(_BUILD_PHASING) = YES && $(BUILD_PHASE) {
        if $(BUILD_PHASE_PRODUCTS) {
            DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
        }
        PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
    }
}

# CreateMasterImplicitHeader <master implicit header path>
rule CreateMasterImplicitHeader
{
    # Creation of this header depends on all the header copies
    for HEADER_COPY in $(IMPLICITLY_INCLUDED_HEADER_COPIES) {
        DEPENDS $(1) : $(HEADER_COPY) ;
    }
    # Master implicit header depends on destination dir
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
}
actions CreateMasterImplicitHeader
{
    $(RM) -f "$(1)"
    $(TOUCH) "$(1)"
    $(ECHO) "/* Generated master implicit inclusion header */" >> "$(1)"
    for header in "$(IMPLICITLY_INCLUDED_HEADER_COPIES)"
    do
        $(ECHO) "#include \"$header\"" >> "$(1)"
    done
}

# ProcessHeader <product or phase> <header>
#
# Clone header and generate headerdoc from header as necessary,
# and copy header to subfolders of product as appropriate.
rule ProcessHeader
{
    if source in $(BUILD_COMPONENTS) {
        local HEADER_SOURCE_COPY ;
        local HEADER_SOURCE_DIR ;
        # make directory first if necessary
        if $(2:D) {
            HEADER_SOURCE_DIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(HEADER_SOURCE_DIR) ;
            HEADER_SOURCE_COPY = $(HEADER_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(HEADER_SOURCE_COPY) : $(HEADER_SOURCE_DIR) ;
        }
        else {
            HEADER_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(HEADER_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        Cp $(HEADER_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(HEADER_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        # Scan this header to see if it includes other headers.
        if $(ENABLE_HEADER_SCANNING) != NO && $(INDEX_BASED_HEADER_DEPENDENCIES) != YES {
            HDRRULE on $(2) = ProcessC.HdrRule ;
            HDRSCAN on $(2) = $(HDRPATTERN) ;
        }
        # Set search path for header so dependence analysis will find it
        SEARCH on $(2:D=) += $(2:D) ;

        # Clone header to project header directory unless it was derived
        if ! $(2) in $(DERIVED_HEADERS) && $(CLONE_HEADERS) = YES {
            CloneHeader $(1) : $(2) : $(PROJECT_HEADER_DIR) ;
        }
        # conditionally generate documentation from headers
        if $(GENERATE_HEADERDOC) = YES && $(HEADERDOC_DIR) {
            HEADERDOC_TARGET = $(2:B)$(/)toc.html ;
            LOCATE on $(HEADERDOC_TARGET) = $(HEADERDOC_DIR) ;
            HeaderDoc $(HEADERDOC_TARGET) : $(2) ;
            DEPENDS $(HEADERDOC_TARGET) : $(HEADERDOC_DIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(HEADERDOC_TARGET) ;
            }
            HEADERDOC_TARGETS += $(HEADERDOC_TARGET) ;
        }
    }
    local ATTRIBUTES = $($(2)_ATTRIBUTES) ;
    local HEADER_ATTRIBUTE ;
    for HEADER_ATTRIBUTE in $(ATTRIBUTES) {
        switch $(HEADER_ATTRIBUTE) {
            case Project :
                # Define option as valid, but take no action
            case Public :
                HAS_PUBLIC_HEADERS = YES ;
                # Create a public header directory
                if ! $(PUBLIC_HEADER_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(PUBLIC_HEADER_DIR) ;
                    ProductFile $(PUBLIC_HEADER_DIR) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PUBLIC_HEADER_DIR default = $(PUBLIC_HEADER_DIR:G=aside) ;
                        Mkdir $(ASIDE_PUBLIC_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PUBLIC_HEADER_DIR) ;
                    }
                }
                # Create symlink to public header dir in versioned frameworks
                if $(PUBLIC_HEADER_LINK)
                  && ! $(PUBLIC_HEADER_LINK) in $(PRODUCT_FILES) {
                    SymLink $(PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
                    DEPENDS $(PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_DIR) ;
                    ProductFile $(PUBLIC_HEADER_LINK) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PUBLIC_HEADER_LINK default = $(PUBLIC_HEADER_LINK:G=aside) ;
                        SymLink $(ASIDE_PUBLIC_HEADER_LINK) : $(PUBLIC_HEADER_LINK_PATH) ;
                        DEPENDS $(ASIDE_PUBLIC_HEADER_LINK) : $(ASIDE_PUBLIC_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PUBLIC_HEADER_LINK) ;
                    }
                    NOUPDATE $(PUBLIC_HEADER_LINK) ;
                }
                # Public headers get stub "clones" put in the public header dir
                if build in $(BUILD_COMPONENTS) && $(CLONE_HEADERS) = YES {
                    CloneHeader $(1) : $(2) : $(PUBLIC_HEADER_CLONE_DIR) ;
                }
                if headers in $(BUILD_COMPONENTS) {
                    if $(PUBLIC_HEADER_DIR) {
                        local HEADER_COPY = $(PUBLIC_HEADER_DIR)$(/)$(2:BS:G=) ;
                        #DEPENDS $(PUBLIC_HEADER_DIR:G=populated) : $(2) ;
                        #PBXCp $(PUBLIC_HEADER_DIR:G=populated) : $(2) ;
                        #ProductFile $(PUBLIC_HEADER_DIR:G=populated) ;
                        DEPENDS $(HEADER_COPY) : $(2) ;
                        PBXCp $(HEADER_COPY) : $(2) ;
                        ProductFile $(HEADER_COPY) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_HEADER_COPY = $(HEADER_COPY:G=aside) ;
                            #DEPENDS $(ASIDE_PUBLIC_HEADER_DIR:G=aside-populated) : $(2) ;
                            #PBXCp $(ASIDE_PUBLIC_HEADER_DIR:G=aside-populated) : $(2) ;
                            #ProductFileAside $(ASIDE_PUBLIC_HEADER_DIR:G=aside-populated) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(2) ;
                            PBXCp $(ASIDE_HEADER_COPY) : $(2) ;
                            ProductFileAside $(ASIDE_HEADER_COPY) ;
                        }
                    }
                    else {
                        ECHO warning: public header $(2) ignored because PUBLIC_HEADER_DIR has no value ;
                    }
                }
            case Private :
                HAS_PRIVATE_HEADERS = YES ;
                # create a private header directory
                if ! $(PRIVATE_HEADER_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(PRIVATE_HEADER_DIR) ;
                    ProductFile $(PRIVATE_HEADER_DIR) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PRIVATE_HEADER_DIR default = $(PRIVATE_HEADER_DIR:G=aside) ;
                        Mkdir $(ASIDE_PRIVATE_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PRIVATE_HEADER_DIR) ;
                    }
                }
                # accompanying link in versioned frameworks
                if $(PRIVATE_HEADER_LINK)
                  && ! $(PRIVATE_HEADER_LINK) in $(PRODUCT_FILES) {
                    SymLink $(PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
                    DEPENDS $(PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_DIR) ;
                    ProductFile $(PRIVATE_HEADER_LINK) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                        ASIDE_PRIVATE_HEADER_LINK default = $(PRIVATE_HEADER_LINK:G=aside) ;
                        SymLink $(ASIDE_PRIVATE_HEADER_LINK) : $(PRIVATE_HEADER_LINK_PATH) ;
                        DEPENDS $(ASIDE_PRIVATE_HEADER_LINK) : $(ASIDE_PRIVATE_HEADER_DIR) ;
                        ProductFileAside $(ASIDE_PRIVATE_HEADER_LINK) ;
                    }
                    NOUPDATE $(PRIVATE_HEADER_LINK) ;
                }
                # Private headers get stub "clones" put in private header dir
                if build in $(BUILD_COMPONENTS) && $(CLONE_HEADERS) = YES {
                    CloneHeader $(1) : $(2) : $(PRIVATE_HEADER_CLONE_DIR) ;
                }
                if headers in $(BUILD_COMPONENTS) {
                    if $(PRIVATE_HEADER_DIR) {
                        local HEADER_COPY = $(PRIVATE_HEADER_DIR)$(/)$(2:BS:G=) ;
                        #DEPENDS $(PRIVATE_HEADER_DIR:G=populated) : $(2) ;
                        #PBXCp $(PRIVATE_HEADER_DIR:G=populated) : $(2) ;
                        #ProductFile $(PRIVATE_HEADER_DIR:G=populated) ;
                        DEPENDS $(HEADER_COPY) : $(2) ;
                        PBXCp $(HEADER_COPY) : $(2) ;
                        ProductFile $(HEADER_COPY) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_HEADER_COPY = $(HEADER_COPY:G=aside) ;
                            #DEPENDS $(ASIDE_PRIVATE_HEADER_DIR:G=aside-populated) : $(2) ;
                            #PBXCp $(ASIDE_PRIVATE_HEADER_DIR:G=aside-populated) : $(2) ;
                            #ProductFileAside $(ASIDE_PRIVATE_HEADER_DIR:G=aside-populated) ;
                            DEPENDS $(ASIDE_HEADER_COPY) : $(2) ;
                            PBXCp $(ASIDE_HEADER_COPY) : $(2) ;
                            ProductFileAside $(ASIDE_HEADER_COPY) ;
                        }
                    }
                    else {
                        ECHO warning: private header $(2) ignored because PRIVATE_HEADER_DIR has no value ;
                    }
                }
            case * :
                if $(HEADER_ATTRIBUTE) != AbsolutePath {
                    ECHO jam: warning: Ignoring unknown header attribute $(HEADER_ATTRIBUTE) ;
                }
        }
    }
}

rule PrecompileHeader
{
    DEPENDS $(1) : $(2) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) $(OTHER_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
        FLAGS on $(1) += $(OTHER_CFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if ( $(USE_GCC3) = YES ) {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(OS) in MACOS DARWIN {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if $(1:S) = .pp {
        # Hack: gcc3 doesn't support Objective-C++ yet (as of dec 10 2001)
        if $(USE_GCC3) = YES {
            FLAGS on $(1) += -x c++ ;
        }
        else {
            FLAGS on $(1) += -x objective-c++ ;
        }
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(TEMP_DIR)$(/)ImplicitHeaderPrecompile$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions PrecompileHeader
{
    $(CC) -precomp -o "$(1)" "-F$(FRAMEWORK_SEARCH_PATHS)" "-I$(HEADER_SEARCH_PATHS)" $(ARCH_FLAGS) "$(FLAGS)" $(GLOBAL_CFLAGS) "-I$(DERIVED_PATHS)" "-I$(SOURCE_ROOT)" "$(PREFIX_HEADER_CFLAGS)" "$(OTHER_PRECOMP_CFLAGS)" "$(2)"
}

rule MakePFEFile
{
    DEPENDS $(1) : $(2) ;
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        KERNEL_COMPILE_OPTIONS += -fapple-kext ;
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) $(OTHER_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) ;    # We must compile with the extension-specific build flags
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
        FLAGS on $(1) += $(OTHER_CFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if $(USE_GCC3) = YES {
        FLAGS on $(1) += -fmessage-length=0 ;
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(2:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    ARCH on $(1) = $(ARCH) ;
    Mkdir $(PRECOMP_DESTINATION_DIR) ;
    DEPENDS $(1) : $(PRECOMP_DESTINATION_DIR) ;
    SEARCH on $(2) = $(SOURCE_ROOT) ;
}
actions MakePFEFile
{
    for c_dialect in $(PFE_FILE_C_DIALECTS) ; do dummy_file=`mktemp /tmp/.null-XXXXXXXX`; $(CC:Q) -c -x ${c_dialect} -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) "$(FLAGS)" $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) -I$(SOURCE_ROOT:Q) $(PREFIX_HEADER_CFLAGS:Q) $(OTHER_PRECOMP_CFLAGS:Q) $(2:Q) -o ${dummy_file} --dump-pch $(1:Q) ; exit_code=$? ; rm ${dummy_file} ; if [ ${exit_code} != 0 ] ; then exit ${exit_code} ; fi ; done
}


# ProcessResources <product> <bundle resources>
#
# Process individual resource files, copy property list settings file,
# and write the package info file if appropriate.
rule ProcessResources
{
    if ( build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : CopyResources ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        for FILE in $(2) {
            if $(_BUILD_PHASING) = YES {
                ProcessResource $(BUILD_PHASE) : $(FILE) ;
            }
            else {
                ProcessResource $(1) : $(FILE) ;
            }
        }
        # product settings, version settings, and package info written only during build
        if build in $(BUILD_COMPONENTS) {
            # product settings property list
            if $(_INFO_PLIST_FILE_PATH)
             && $(PURE_JAVA) != YES {
                # if available and not pure java
                if $(PRODUCT_TYPE) = Framework {
                    INFO_PLIST_FILE default = $(RESOURCE_DIR)$(/)Info.plist ;
                    if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(RESOURCE_DIR) ;
                        ProductFile $(RESOURCE_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                            Mkdir $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAside $(ASIDE_RESOURCE_DIR) ;
                        }
                    }
                    DEPENDS $(INFO_PLIST_FILE) : $(RESOURCE_DIR) ;
                    if $(RESOURCE_LINK)
                     && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
                        SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                        ProductFile $(RESOURCE_LINK) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                            SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                            ProductFileAside $(ASIDE_RESOURCE_LINK) ;
                        }
                    }
                    DEPENDS $(INFO_PLIST_FILE) : $(RESOURCE_LINK) ;
                }
                else {
                    if $(BUNDLE_STYLE) = SHALLOW {
                        INFO_PLIST_FILE default = $(1:G=)$(/)Info.plist ;
                    }
                    else {
                        INFO_PLIST_FILE default = $(1:G=)$(/)Contents$(/)Info.plist ;
                    }
                    INFO_PLIST_DIR = $(INFO_PLIST_FILE:D) ;
                    if ! $(INFO_PLIST_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(INFO_PLIST_DIR) ;
                        ProductFile $(INFO_PLIST_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_INFO_PLIST_DIR default = $(INFO_PLIST_DIR:G=aside) ;
                            Mkdir $(ASIDE_INFO_PLIST_DIR) ;
                            ProductFileAside $(ASIDE_INFO_PLIST_DIR) ;
                        }
                    }
                    DEPENDS $(INFO_PLIST_FILE) : $(INFO_PLIST_DIR) ;
                }
                Cp $(INFO_PLIST_FILE) : $(_INFO_PLIST_FILE_PATH) ;
                ProductFile $(INFO_PLIST_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_INFO_PLIST_FILE default = $(INFO_PLIST_FILE:G=aside) ;
                    DEPENDS $(ASIDE_INFO_PLIST_FILE) : $(ASIDE_INFO_PLIST_DIR) ;
                    Cp $(ASIDE_INFO_PLIST_FILE) : $(PRODUCT_SETTINGS_PATH) ;
                    ProductFileAside $(ASIDE_INFO_PLIST_FILE) ;
                }
            }
            # version settings property list
            if $(_VERSION_PLIST_FILE_PATH)
             && $(PURE_JAVA) != YES {
                # if available and not pure java
                if $(PRODUCT_TYPE) = Framework {
	            VERSION_PLIST_FILE default = $(RESOURCE_DIR)$(/)version.plist ;
                    if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(RESOURCE_DIR) ;
                        ProductFile $(RESOURCE_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                            Mkdir $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAside $(ASIDE_RESOURCE_DIR) ;
                        }
                    }
                    DEPENDS $(VERSION_PLIST_FILE) : $(RESOURCE_DIR) ;
                    # create accompanying link in the case of versioned frameworks
                    if $(RESOURCE_LINK)
                     && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
                        SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                        ProductFile $(RESOURCE_LINK) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                            DEPENDS $(ASIDE_RESOURCE_LINK) : $(ASIDE_RESOURCE_DIR) ;
                            SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                            ProductFileAside $(ASIDE_RESOURCE_LINK) ;
                        }
                    }
                    DEPENDS $(VERSION_PLIST_FILE) : $(RESOURCE_LINK) ;
                }
                else {
                    if $(BUNDLE_STYLE) = SHALLOW {
                        VERSION_PLIST_FILE default = $(1:G=)$(/)Contents$(/)version.plist ;
                    }
                    else {
                        VERSION_PLIST_FILE default = $(1:G=)$(/)Contents$(/)version.plist ;
                    }
                    VERSION_PLIST_DIR = $(VERSION_PLIST_FILE:D) ;
                    if ! $(VERSION_PLIST_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(VERSION_PLIST_DIR) ;
                        ProductFile $(VERSION_PLIST_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_VERSION_PLIST_DIR default = $(VERSION_PLIST_DIR) ;
                            Mkdir $(ASIDE_VERSION_PLIST_DIR) ;
                            ProductFileAside $(ASIDE_VERSION_PLIST_DIR) ;
                        }
                    }
                    DEPENDS $(VERSION_PLIST_FILE) : $(VERSION_PLIST_DIR) ;
                }
                Cp $(VERSION_PLIST_FILE) : $(_VERSION_PLIST_FILE_PATH) ;
                ProductFile $(VERSION_PLIST_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_VERSION_PLIST_FILE default = $(VERSION_PLIST_FILE:G=aside) ;
                    Cp $(ASIDE_VERSION_PLIST_FILE) : $(VERSION_PLIST_FILE) ;
                    DEPENDS $(ASIDE_VERSION_PLIST_FILE) : $(ASIDE_VERSION_PLIST_DIR) ;
                    ProductFileAside $(ASIDE_VERSION_PLIST_FILE) ;
                }
            }
            # development settings property list
            # This plist gets copied into the bundle if we are doing a development build or removed from the symroot otherwise.  Right now, "development build" means that the ACTION is "build" (as opposed to "install").
            if $(DEVELOPMENT_SETTINGS_PATH)
             && $(PURE_JAVA) != YES && $(ACTION) = build {
                # if available and not pure java
                if $(PRODUCT_TYPE) = Framework {
	            DEVELOPMENT_PLIST_FILE default = $(RESOURCE_DIR)$(/)pbdevelopment.plist ;
                    if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(RESOURCE_DIR) ;
                        ProductFile $(RESOURCE_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                            Mkdir $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAsides $(ASIDE_RESOURCE_DIR) ;
                        }
                    }
                    DEPENDS $(DEVELOPMENT_PLIST_FILE) : $(RESOURCE_DIR) ;
                    # create accompanying link in the case of versioned frameworks
                    if $(RESOURCE_LINK)
                      && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
                        SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                        ProductFile $(RESOURCE_LINK) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                            SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                            DEPENDS $(ASIDE_RESOURCE_LINK) : $(ASIDE_RESOURCE_DIR) ;
                            ProductFileAside $(ASIDE_RESOURCE_LINK) ;
                        }
                    }
                    DEPENDS $(DEVELOPMENT_PLIST_FILE) : $(RESOURCE_LINK) ;
                }
                else {
                    if $(BUNDLE_STYLE) = SHALLOW {
                        DEVELOPMENT_PLIST_FILE default = $(1:G=)$(/)pbdevelopment.plist ;
                    }
                    else {
                        DEVELOPMENT_PLIST_FILE default = $(1:G=)$(/)Contents$(/)pbdevelopment.plist ;
                    }
                    DEVELOPMENT_PLIST_DIR = $(DEVELOPMENT_PLIST_FILE:D) ;
                    if ! $(DEVELOPMENT_PLIST_DIR) in $(PRODUCT_FILES) {
                        Mkdir $(DEVELOPMENT_PLIST_DIR) ;
                        ProductFile $(DEVELOPMENT_PLIST_DIR) ;
                        if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                            ASIDE_DEVELOPMENT_PLIST_DIR default = $(DEVELOPMENT_PLIST_DIR:G=aside) ;
                            Mkdir $(ASIDE_DEVELOPMENT_PLIST_DIR) ;
                            ProductFileAsides $(ASIDE_DEVELOPMENT_PLIST) ;
                        }
                    }
                    DEPENDS $(DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_PLIST_DIR) ;
                }
                Cp $(DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_SETTINGS_PATH) ;
                ProductFile $(DEVELOPMENT_PLIST_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_DEVELOPMENT_PLIST_FILE default = $(DEVELOPMENT_PLIST_FILE:G=aside) ;
                    Cp $(ASIDE_DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_SETTINGS_PATH) ;
                    DEPENDS $(ASIDE_DEVELOPMENT_PLIST_FILE) : $(DEVELOPMENT_PLIST_DIR) ;
                    ProductFileAside $(ASIDE_DEVELOPMENT_PLIST_FILE) ;
                }
            }
            # Write package info file with type and creator if available
            # and if not framework or oldest layout or pure java
            if $(_PKGINFO_FILE_PATH)
             && ( $(PRODUCT_TYPE) != Framework
             && $(PRODUCT_TYPE) != Bundle
             && $(PURE_JAVA) != YES || $(GENERATE_PKGINFO_FILE) = YES ) {
                if $(BUNDLE_STYLE) = SHALLOW || $(PRODUCT_TYPE) = Framework {
                    PKGINFO_FILE default = $(1:G=)$(/)PkgInfo ;
                }
                else {
                    PKGINFO_FILE default = $(1:G=)$(/)Contents$(/)PkgInfo ;
                }
                PKGINFO_DIR = $(PKGINFO:D) ;
                if ! $(PKGINFO_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(PKGINFO_DIR) ;
                    ProductFile $(PKGINFO_DIR) ;
                    if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATIN) = YES {
                        ASIDE_PKGINFO_DIR default = $(PKGINFO_DIR:G=aside) ;
                        Mkdir $(ASIDE_PKGINFO_DIR) ;
                        ProductFileAside $(ASIDE_PKGINFO_DIR) ;
                    }
                }
                Cp $(PKGINFO_FILE) : $(_PKGINFO_FILE_PATH) ;
                ProductFile $(PKGINFO_FILE) ;
                if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                    ASIDE_PKGINFO_FILE default = $(PKGINFO_FILE:G=aside) ;
                    DEPENDS $(ASIDE_PKGINFO_FILE) : $(ASIDE_PKGINFO_DIR) ;
                    Cp $(ASIDE_PKGINFO_FILE) : $(_PKGINFO_FILE_PATH) ;
                    ProductFileAside $(ASIDE_PKGINFO_FILE) ;
                }
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

# ProcessResource <product or phase> <bundle resource>
#
# Copies resources to nonlocalized or localized folders as appropriate
rule ProcessResource
{
    if source in $(BUILD_COMPONENTS) {
        local RESOURCE_SOURCE_COPY ;
        local RESOURCE_SOURCE_DIR ;
        # make directory first if necessary
        if $(2:D) {
            RESOURCE_SOURCE_DIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(RESOURCE_SOURCE_DIR) ;
            RESOURCE_SOURCE_COPY = $(RESOURCE_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(RESOURCE_SOURCE_COPY) : $(RESOURCE_SOURCE_DIR) ;
        }
        else {
            RESOURCE_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(RESOURCE_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        # copy resource to source location
        Cp $(RESOURCE_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(RESOURCE_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        local REGION = $($(2)_REGION) ;
        local SPECIFIC_REGION ;
        # resource directory must exist
        if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
            Mkdir $(RESOURCE_DIR) ;
            ProductFile $(RESOURCE_DIR) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_RESOURCE_DIR default = $(RESOURCE_DIR:G=aside) ;
                Mkdir $(ASIDE_RESOURCE_DIR) ;
                ProductFileAside $(ASIDE_RESOURCE_DIR) ;
            }
        }
        # create accompanying link in the case of versioned frameworks
        if $(RESOURCE_LINK)
         && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
            SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
            ProductFile $(RESOURCE_LINK) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_RESOURCE_LINK default = $(RESOURCE_LINK:G=aside) ;
                SymLink $(ASIDE_RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
                DEPENDS $(ASIDE_RESOURCE_LINK) : $(ASIDE_RESOURCE_DIR) ;
                ProductFileAside $(ASIDE_RESOURCE_LINK) ;
            }
        }
        if ! $(REGION)
         || ( $(BUNDLE_STYLE) = SHALLOW && $(REGION) = $(DEVELOPMENT_LANGUAGE) ) {
            # non-localized resource
            # or development language resource for shallow bundle
            local NONLOCALIZED_RESOURCE_DIR NONLOCALIZED_RESOURCE ;
            NONLOCALIZED_RESOURCE_DIR = $(RESOURCE_DIR) ;
            if ! $(NONLOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                Mkdir $(NONLOCALIZED_RESOURCE_DIR) ;
                ProductFile $(NONLOCALIZED_RESOURCE_DIR) ;
            }
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_NONLOCALIZED_RESOURCE_DIR = $(NONLOCALIZED_RESOURCE_DIR:G=aside) ;
                if ! $(ASIDE_NONLOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(ASIDE_NONLOCALIZED_RESOURCE_DIR) ;
                    ProductFileAside $(ASIDE_NONLOCALIZED_RESOURCE_DIR) ;
                }
            }
            NONLOCALIZED_RESOURCE = $(NONLOCALIZED_RESOURCE_DIR)$(/)$(2:BS) ;
            #DEPENDS $(NONLOCALIZED_RESOURCE_DIR:G=populated) : $(2) ;
            #PBXCp $(NONLOCALIZED_RESOURCE_DIR:G=populated) : $(2) ;
            #ProductFile $(NONLOCALIZED_RESOURCE_DIR:G=populated) ;
            DEPENDS $(NONLOCALIZED_RESOURCE) : $(2) ;
            PBXCp $(NONLOCALIZED_RESOURCE) : $(2) ;
            ProductFile $(NONLOCALIZED_RESOURCE) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_NONLOCALIZED_RESOURCE = $(NONLOCALIZED_RESOURCE:G=aside) ;
                #DEPENDS $(ASIDE_NONLOCALIZED_RESOURCE_DIR:G=aside-populated) : $(2) ;
                #PBXCp $(ASIDE_NONLOCALIZED_RESOURCE_DIR:G=aside-populated) : $(2) ;
                #ProductFileAside $(ASIDE_NONLOCALIZED_RESOURCE_DIR:G=aside-populated) ;
                DEPENDS $(ASIDE_NONLOCALIZED_RESOURCE) : $(2) ;
                PBXCp $(ASIDE_NONLOCALIZED_RESOURCE) : $(2) ;
                ProductFileAside $(ASIDE_NONLOCALIZED_RESOURCE) ;
            }
        } else for SPECIFIC_REGION in $(REGION) {
            # for each localization of a resource (only one ever expected)
            local LOCALIZED_RESOURCE_DIR LOCALIZED_RESOURCE ;
            LOCALIZED_RESOURCE_DIR = $(RESOURCE_DIR)$(/)$(SPECIFIC_REGION:S=.lproj) ;
            # localized resource directory must exist
            if ! $(LOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                Mkdir $(LOCALIZED_RESOURCE_DIR) ;
                ProductFile $(LOCALIZED_RESOURCE_DIR) ;
            }
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_LOCALIZED_RESOURCE_DIR = $(LOCALIZED_RESOURCE_DIR:G=aside) ;
                if ! $(ASIDE_LOCALIZED_RESOURCE_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(ASIDE_LOCALIZED_RESOURCE_DIR) ;
                    ProductFileAside $(ASIDE_LOCALIZED_RESOURCE_DIR) ;
                }
            }
            LOCALIZED_RESOURCE = $(LOCALIZED_RESOURCE_DIR)$(/)$(2:BS) ;
            #DEPENDS $(LOCALIZED_RESOURCE_DIR:G=populated) : $(2) ;
            #PBXCp $(LOCALIZED_RESOURCE_DIR:G=populated) : $(2) ;
            #ProductFile $(LOCALIZED_RESOURCE_DIR:G=populated) ;
            DEPENDS $(LOCALIZED_RESOURCE) : $(2) ;
            PBXCp $(LOCALIZED_RESOURCE) : $(2) ;
            ProductFile $(LOCALIZED_RESOURCE) ;
            if $(INSTALLED_PRODUCT_ASIDES) = YES && $(DEPLOYMENT_LOCATION) = YES {
                ASIDE_LOCALIZED_RESOURCE = $(LOCALIZED_RESOURCE:G=aside) ;
                #DEPENDS $(ASIDE_LOCALIZED_RESOURCE_DIR:G=aside-populated) : $(2) ;
                #PBXCp $(ASIDE_LOCALIZED_RESOURCE_DIR:G=aside-populated) : $(2) ;
                #ProductFileAside $(ASIDE_LOCALIZED_RESOURCE_DIR:G=aside-populated) ;
                DEPENDS $(ASIDE_LOCALIZED_RESOURCE) : $(2) ;
                PBXCp $(ASIDE_LOCALIZED_RESOURCE) : $(2) ;
                ProductFileAside $(ASIDE_LOCALIZED_RESOURCE) ;
            }
        }
    }
}

actions CopyProjectFiles
{
    if [ -d $(2) ]; then
        $(CP) -pRP $(2) $(1)
    elif [ -d $(2:S=.pbxproj) ]; then
        $(CP) -pRP $(2:S=.pbxproj) $(1)
    fi
}

# ProcessSources <product> <source files>
#
# Process individual source files and generate versioning stub,
# kernel module stub, and use Interfacer to make exports and glue
rule ProcessSources
{
    if build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : DeriveAndCompileSources ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        # copy project files if copying source
        if source in $(BUILD_COMPONENTS) {
            local PROJECT_FILES = $(SOURCE_ROOT)/$(PROJECT).pbproj ;
            local LEGACY_PROJECT_FILES = $(SOURCE_ROOT)/$(PROJECT).pbxproj ;
            local PROJECT_FILES_COPY = $(INSTALL_ROOT)/$(PROJECT).pbproj ;
            CopyProjectFiles $(PROJECT_FILES_COPY) : $(PROJECT_FILES) : $(LEGACY_PROJECT_FILES) ;
            DEPENDS $(PROJECT_FILES_COPY) : $(INSTALL_ROOT) ;
            Mkdir $(INSTALL_ROOT) ;
            DEPENDS $(PROJECT_FILES_COPY) : $(PROJECT_FILES) ;
            NOCARE $(PROJECT_FILES) ;
            DEPENDS $(PROJECT_FILES_COPY) : $(LEGACY_PROJECT_FILES) ;
            NOCARE $(LEGACY_PROJECT_FILES) ;
            BUILD_PHASE_PRODUCTS += $(PROJECT_FILES_COPY) ;
        }
        for FILE in $(2) {
            if $(_BUILD_PHASING) = YES {
                ProcessSource $(BUILD_PHASE) : $(FILE) ;
            }
            else {
                ProcessSource $(1) : $(FILE) ;
            }
        }
        # any build component implies handling: header cloning, versioning,
        # kernel module generation, and interfacer usage
        if build in $(BUILD_COMPONENTS) {
            # generate versioning system derived sources
            if $(VERSIONING_SYSTEM) {
                local RULE = VersioningSystem_$(VERSIONING_SYSTEM) ;
                $(RULE) $(1) ;
            }
            # generate kernel module or extension info source
            if $(KERNEL_MODULE) = YES {
                KernelModuleGeneratedSource $(1) ;
            }
            # generate interfacer derived sources
            if $(GENERATE_EXPORT_SETS_AND_GLUE) = YES {
                InterfacerExportSetsAndGlue $(1) ;
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
                # product reference link must be in place before any compiles
                if $(PRODUCT_REFERENCE) {
                    DEPENDS $(BUILD_PHASE_PRODUCTS) : $(PRODUCT_REFERENCE) ;
                }
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
        # Actually copy headers (over clones) only when compiles are finished
    }
}

# ProcessSource <product> <source file>
#
# Call ProcessFile to process a source file with the correct
# extension-specific rule, and start header scanning.
rule ProcessSource
{
    # scan non-Java for header file references in any source
    if $(2:S) != ".java" {
        if $(ENABLE_HEADER_SCANNING) != NO && $(INDEX_BASED_HEADER_DEPENDENCIES) != YES {
            HDRRULE on $(2) = ProcessC.HdrRule ;
            HDRSCAN on $(2) = $(HDRPATTERN) ;
        }
    }
    ProcessFile $(1) : $(2) ;
}

rule ProcessFiles
{
    local FILE ;
    for FILE in $(2) {
        ProcessFile $(1) : $(FILE) ;
    }
}

rule ProcessFile
{
    local SOURCE_COPY ;
    local SOURCE_SUBDIR ;
    if source in $(BUILD_COMPONENTS) {
        # copy to source location
        # make directory first if necessary
        if $(2:D) {
            SOURCE_SUBDIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(SOURCE_SUBDIR) ;
            SOURCE_COPY = $(SOURCE_SUBDIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(SOURCE_SUBDIR) ;
            }
        }
        else {
            SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        Cp $(SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        # process file with rule based on the file suffix
        local EXCLUDED_OSS = $($(2)_EXCLUDED_OSS) ;
        local INCLUDED_OSS = $($(2)_INCLUDED_OSS) ;
        local RULE = $($(2:S)_RULE) ;

        if $(EXCLUDED_OSS) && ( $(OS) in $(EXCLUDED_OSS) ) {
            # do nothing -- file excluded from build
        } else if $(INCLUDED_OSS) && ! ( $(OS) in $(INCLUDED_OSS) ) {
            # do nothing -- file excluded from build
        } else if $(RULE) {
            $(RULE) $(1) : $(2) ;
        } else {
            ECHO jam: warning: no rule for file $(2) ;
        }
    }
}

# ProcessFrameworksAndLibraries <product> <linked files>
#
# Link object files and/or archive classes
rule ProcessFrameworksAndLibraries
{
    if ( build in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : LinkWithFrameworksAndLibraries ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = $(INNER_PRODUCT) ;
        }
        for VARIANT in $(BUILD_VARIANTS) {
	# add to linked files, including java .jar files even when there are no native object files!
        # This was never questioned, but the long comment was added after this
        # step was repeatedly moved outside this block by integration errors.
	LINKED_FILES_$(VARIANT) += $(2) ;

        # only link if there are object files
        if $(OBJECT_FILES_$(VARIANT)) {
            if ! ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC ) {
                GENERATE_MASTER_OBJECT_FILE default = YES ;
            }
            # define products
            if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Library {
                # simple product
                INNER_PRODUCT default = $(1:G=) ;
                INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT)$(VARIANT_SUFFIX_$(VARIANT)) ;
                INNER_PRODUCT_LINK_$(VARIANT) default = ;
                ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
                if $(DEPLOYMENT_POSTPROCESSING) = YES {
                    SetModeOwnerAndGroup $(INNER_PRODUCT:G=ModeOwnerGroup) : $(INNER_PRODUCT) ;
                }
            }
            else {
                if $(PRODUCT_TYPE) = Framework {
                    # versioned bundle
                    INNER_PRODUCT default = $(1:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)$(1:BG=) ;
                    INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK default = $(1:G=)$(/)$(1:BG=) ;
                    INNER_PRODUCT_LINK_$(VARIANT) default = $(INNER_PRODUCT_LINK)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK_PATH default = Versions$(/)Current$(/)$(1:BG=) ;
                    INNER_PRODUCT_LINK_PATH_$(VARIANT) default = $(INNER_PRODUCT_LINK_PATH)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                }
                else {
                    # standard bundle
                    if $(BUNDLE_STYLE) = SHALLOW {
                        INNER_PRODUCT default = $(1:G=)$(/)$(1:BG=) ;
                    }
                    else {
                        INNER_PRODUCT default = $(1:G=)$(/)Contents$(/)MacOS$(/)$(1:BG=) ;
                    }
                    INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT)$(VARIANT_SUFFIX_$(VARIANT))$(TOOL_SUFFIX) ;
                    INNER_PRODUCT_LINK_$(VARIANT) default = ;
                }
                # inner product should always be ready before the link to it
                if $(INNER_PRODUCT_LINK_$(VARIANT)) {
                    DEPENDS $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                }
                # inner product directory needed for all bundle types
                INNER_PRODUCT_DIR_$(VARIANT) = $(INNER_PRODUCT_$(VARIANT):D) ;
                if ! $(INNER_PRODUCT_DIR_$(VARIANT)) in $(PRODUCT_FILES) {
                    Mkdir $(INNER_PRODUCT_DIR_$(VARIANT)) ;
                    ProductFile $(INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
                if $(INNER_PRODUCT_$(VARIANT)) && $(INNER_PRODUCT_DIR_$(VARIANT)) {
                    DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
                # optionally make inner product dir aside
                if $(ASIDE_DIR) {
                    ASIDE_INNER_PRODUCT_DIR_$(VARIANT) = $(INNER_PRODUCT_DIR_$(VARIANT):G=aside) ;
                    if ! $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) in $(PRODUCT_FILES) {
                        Mkdir $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                        ProductFileAside $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                    }
                }
            }
            # Link inner product
            # There are three kinds of linking that may be done,
            # and three link rules that may be used:
            # Linking a master object file that may be edited
            # is the first case assumed to be the most common,
            # linking using a master object file and
            # architecture-specific exports files is supported,
            # as is basic linking.
            # The link rules can be used to construct a static library,
            # a dynamic library, or a directly launchable executable.
            # Finally, static libraries need to have ranlib run after all else.
	    LINK_FILE_LIST_$(VARIANT) on $(INNER_PRODUCT_$(VARIANT)) = $(FILE_LIST_$(VARIANT)) ;
            if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
                # stand alone executable
                if $(GENERATE_MASTER_OBJECT_FILE) = YES || $(EXPORTED_SYMBOLS_FILE) {
                    ProcessSingleObjectLink $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : StandaloneExecutable ;
                }
                else {
                    for ARCH in $(ARCHS) {
                        THIN_MASTER_OBJECT_FILE default = $(EXPORTED_SYMBOLS_FILE_$(ARCH)) ;
                    }
                    if $(THIN_MASTER_OBJECT_FILE) {
                        ProcessLinkWithArchitectureSpecificEditing $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : StandaloneExecutable ;
                    }
                    else {
                        StandaloneExecutable $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) ;
                    }
                }
            }
            else {
                if $(LIBRARY_STYLE) = STATIC && $(KERNEL_MODULE) != YES {
                    # static library
                    if $(GENERATE_MASTER_OBJECT_FILE) = YES || $(EXPORTED_SYMBOLS_FILE) {
                        ProcessSingleObjectLink $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : StaticLibrary ;
                    }
                    else {
                        for ARCH in $(ARCHS) {
                            THIN_MASTER_OBJECT_FILE default = $(EXPORTED_SYMBOLS_FILE_$(ARCH)) ;
                        }
                        if $(THIN_MASTER_OBJECT_FILE) {
                            ProcessLinkWithArchitectureSpecificEditing $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : StaticLibrary ;
                        }
                        else {
                            StaticLibrary $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) ;
                        }
                    }
                }
                else {
                    # dylibs, bundles, frameworks, and kernel extensions
                    if $(GENERATE_MASTER_OBJECT_FILE) = YES || $(EXPORTED_SYMBOLS_FILE) {
                        ProcessSingleObjectLink $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : DynamicLibrary ;
                    }
                    else {
                        # use architecture-specific exported symbols file if provided
                        for ARCH in $(ARCHS) {
                            THIN_MASTER_OBJECT_FILE default = $(EXPORTED_SYMBOLS_FILE_$(ARCH)) ;
                        }
                        if $(THIN_MASTER_OBJECT_FILE) {
                            ProcessLinkWithArchitectureSpecificEditing $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) : DynamicLibrary ;
                        }
                        else {
                            DynamicLibrary $(INNER_PRODUCT_$(VARIANT)) : $(LINKED_FILES_$(VARIANT)) ;
                        }
                    }
                }
            }
            ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
            DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(TARGET_BUILD_DIR) ;
            # optionally copy inner product aside
            if $(ASIDE_DIR) {
                ASIDE_INNER_PRODUCT_$(VARIANT) = $(INNER_PRODUCT_$(VARIANT):G=aside) ;
                ProductFileAside $(ASIDE_INNER_PRODUCT_$(VARIANT)) ;
                Cp $(ASIDE_INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                if $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) {
                    DEPENDS $(ASIDE_INNER_PRODUCT_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
            }
            # preen
            if $(DEPLOYMENT_POSTPROCESSING) = YES && $(UNSTRIPPED_PRODUCT) != YES {
                STRIPPED_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT_$(VARIANT):G=strip) ;
                DEPENDS $(STRIPPED_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                if $(PRODUCT_TYPE) != Tool && $(PRODUCT_TYPE) != Application {
                    STRIPFLAGS default = -S ;
                }
                Strip $(STRIPPED_PRODUCT_$(VARIANT)) ;
                if $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC {
                    Ranlib $(STRIPPED_PRODUCT_$(VARIANT)) ;
                }
                ProductFile $(STRIPPED_PRODUCT_$(VARIANT)) ;
            }
            # make inner product symlink, if any
            if $(INNER_PRODUCT_LINK_$(VARIANT)) {
                SymLink $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                ProductFile $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                DEPENDS $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                # optionally copy inner product link aside
                if $(ASIDE_DIR) {
                    ASIDE_INNER_PRODUCT_LINK_$(VARIANT) = $(INNER_PRODUCT_LINK_$(VARIANT):G=aside) ;
                    ProductFileAside $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) ;
                    SymLink $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                    DEPENDS $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_$(VARIANT)) ;
                    DEPENDS $(ASIDE_INNER_PRODUCT_LINK_$(VARIANT)) : $(ASIDE_INNER_PRODUCT_DIR_$(VARIANT)) ;
                }
            }
            # static libraries must have ranlib run on them after all else
            if $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC {
                RANLIB_INNER_PRODUCT_$(VARIANT) default = $(INNER_PRODUCT_$(VARIANT):G=ranlib) ;
                # ranlib depends on link, strip, modeownergroup
                DEPENDS $(RANLIB_INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_$(VARIANT)) ;
                if $(STRIPPED_PRODUCT_$(VARIANT)) {
                    DEPENDS $(RANLIB_INNER_PRODUCT_$(VARIANT)) : $(STRIPPED_PRODUCT_$(VARIANT)) ;
                }
                ProductFile $(RANLIB_INNER_PRODUCT_$(VARIANT)) ;
            }
            # Basic link options determine if this is kext, bundle, or library
            if $(KERNEL_MODULE) = YES {
                MODULE_OBJECT_PATH = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(MODULE_OBJECT_FILE_$(VARIANT)) ;
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -static -nostdlib -r -lkmodc++ "$(MODULE_OBJECT_PATH)" -lkmod -lcc_kext ;
            }
            else {
                if $(PREBINDING) = YES
                 && $(PRODUCT_TYPE) != Bundle
                 && ! ( $(PRODUCT_TYPE) = Library && ( $(LIBRARY_STYLE) = BUNDLE || $(LIBRARY_STYLE) = STATIC ) ) {
                    FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -prebind ;
                }
                if $(PRODUCT_TYPE) = Bundle
                 || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = BUNDLE ) {
                    FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -bundle ;
                } else {
                    if $(PRODUCT_TYPE) = Framework
                     || ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = DYNAMIC ) {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -dynamiclib ;
                    }
                    else {
                        if $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = STATIC {
                            FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -static ;
                        }
                    }
                }
                # Dynamic library link options set version and installed name
                if ( $(PRODUCT_TYPE) = Library && $(LIBRARY_STYLE) = DYNAMIC )
                 || $(PRODUCT_TYPE) = Framework {
                    if $(DYLIB_COMPATIBILITY_VERSION) {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -compatibility_version "$(DYLIB_COMPATIBILITY_VERSION)" ;
                    }
                    if $(DYLIB_CURRENT_VERSION) {
                        FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += -current_version "$(DYLIB_CURRENT_VERSION)" ;
                    }
                    if $(INSTALL_PATH) {
                        DYLIB_INSTALLED_NAME_$(VARIANT) default = $(INSTALL_PATH)$(/)$(INNER_PRODUCT_$(VARIANT):G=) ;
                        INSTALLED_NAME_FLAG on $(INNER_PRODUCT_$(VARIANT)) = -install_name \"`echo \"$(DYLIB_INSTALLED_NAME_$(VARIANT))\" | $(SED) 's!//*!/!g'`\" ;
                    }
                }
            }
            # other link options
            OTHER_LDFLAGS_$(VARIANT) default = $(OTHER_LDFLAGS) ;
            if $(OTHER_LDFLAGS_$(VARIANT)) {
                FLAGS.o on $(INNER_PRODUCT_$(VARIANT)) += $(OTHER_LDFLAGS_$(VARIANT)) ;
            }
        }
        else {
            # no object files present, indicating pure Java
            if $(PRODUCT_TYPE) = Framework {
                if $(CURRENT_VERSION_LINK) {
                    INNER_PRODUCT_$(VARIANT) default = $(1:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)$(1:B)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK_$(VARIANT) default = $(1:G=)$(/)$(1:BG=)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    INNER_PRODUCT_LINK_PATH_$(VARIANT) default = Versions$(/)Current$(/)$(1:BG=)$(VARIANT_SUFFIX_$(VARIANT))$(DYNAMIC_LIBRARY_SUFFIX) ;
                    # inner product link
                    SymLink $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                    ProductFile $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                    NOUPDATE $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                }
                else  {
                    INNER_PRODUCT_$(VARIANT) default = $(1:G=)$(/)$(1:BG=)_$(VARIANT)$(DYNAMIC_LIBRARY_SUFFIX) ;
                }
                ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
                if $(DYLIB_COMPATIBILITY_VERSION) {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -compatibility_version "$(DYLIB_COMPATIBILITY_VERSION)" ;
                }
                else {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -compatibility_version 1 ;
                }
                if $(DYLIB_CURRENT_VERSION) {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -current_version "$(DYLIB_CURRENT_VERSION)" ;
                }
                else {
                    DYLIB_VERSION_FLAGS on $(INNER_PRODUCT_$(VARIANT)) += -current_version 1 ;
                }
                if $(INSTALL_PATH) {
                    FRAMEWORK_INSTALLED_NAME_$(VARIANT) default = $(INSTALL_PATH)$(/)$(INNER_PRODUCT_$(VARIANT):G=) ;
                    INSTALLED_NAME_FLAG on $(INNER_PRODUCT_$(VARIANT)) = -install_name \"`echo \"$(FRAMEWORK_INSTALLED_NAME_$(VARIANT))\" | $(SED) 's!//*!/!g'`\" ;
                }
                GenerateFrameworkStub $(INNER_PRODUCT_$(VARIANT)) ;
                INNER_PRODUCT_DIR = $(INNER_PRODUCT_$(VARIANT):D) ;
                if ! $(INNER_PRODUCT_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(INNER_PRODUCT_DIR) ;
                    ProductFile $(INNER_PRODUCT_DIR) ;
                    DEPENDS $(INNER_PRODUCT_$(VARIANT)) : $(INNER_PRODUCT_DIR) ;
                }
                if $(INNER_PRODUCT_LINK_$(VARIANT)) {
                    SymLink $(INNER_PRODUCT_LINK_$(VARIANT)) : $(INNER_PRODUCT_LINK_PATH_$(VARIANT)) ;
                    NOUPDATE $(INNER_PRODUCT_LINK_$(VARIANT)) ; 
                    ProductFile $(INNER_PRODUCT_LINK_$(VARIANT)) ;
                }
            }
        }
        # Java processing compatible with the presense of object files
        if $(COMPILED_JAVA) {
            # provide stub executable if necessary
            if $(JAVA_ONLY) = YES {
                INNER_PRODUCT_$(VARIANT) default = $(1:G=)$(/)Contents$(/)MacOS$(/)$(1:BG=) ;
                # must first make subfolder and depend on that
                INNER_PRODUCT_SUBDIR = $(INNER_PRODUCT_$(VARIANT):D) ;
                if ! $(INNER_PRODUCT_SUBDIR) in $(PRODUCT_FILES) {
                    Mkdir $(INNER_PRODUCT_SUBDIR) ;
                    ProductFile $(INNER_PRODUCT_SUBDIR) ;
                }
                Cp $(INNER_PRODUCT_$(VARIANT)) : $(JAVA_APP_STUB) ;
                ProductFile $(INNER_PRODUCT_$(VARIANT)) ;
            }
        }
        # Add jar/zip files that are in the link phase to the classpath
        if $(OTHER_JAVA_CLASS_PATH) {
            export LINKED_CLASS_ARCHIVES = :"$(OTHER_JAVA_CLASS_PATH)" ;
        }
        else {
            export LINKED_CLASS_ARCHIVES = "" ;
        }
        for JAVA_CLASS_SEARCH_PATH in $(JAVA_CLASS_SEARCH_PATHS) {
            LINKED_CLASS_ARCHIVES = "$(LINKED_CLASS_ARCHIVES):$(JAVA_CLASS_SEARCH_PATH)" ;
        }
        local ARCHIVE ;
        
        for ARCHIVE in $(LINKED_FILES_$(VARIANT)) {
            switch $(ARCHIVE) {
            case *.framework :
                local FW_SUBDIR ;
                for FW_SUBDIR in $(JAVA_FRAMEWORK_RESOURCES_DIRS) {
                    LINKED_CLASS_ARCHIVES = $(LINKED_CLASS_ARCHIVES):$(ARCHIVE)$(/)$(FW_SUBDIR)$(/)Java ;
                    JAVA_FRAMEWORK_JARS += $(ARCHIVE)$(/)$(FW_SUBDIR)$(/)Java ;
                }
            case *.jar :
                LINKED_CLASS_ARCHIVES = $(LINKED_CLASS_ARCHIVES):$(ARCHIVE) ;
                if Merge in $($(ARCHIVE)_ATTRIBUTES) {
                    # merge archive contents by unpacking them into hierarchy
                    local DESTINATION_TARGET = $(CLASS_FILE_DIR:G=Unarchive$(ARCHIVE)) ;
                    NOTFILE $(DESTINATION_TARGET) ;
                    DEPENDS $(DESTINATION_TARGET) : $(JAVA_COMPILE_TARGET) ;
                    if $(MERGED_ARCHIVES) {
                        MERGED_ARCHIVES += $(DESTINATION_TARGET) ;
                    }
                    else {
                        MERGED_ARCHIVES = $(DESTINATION_TARGET) ;
                    }
                    Unarchive $(DESTINATION_TARGET) : $(ARCHIVE) ;
                }
            case *.zip :
                LINKED_CLASS_ARCHIVES = $(LINKED_CLASS_ARCHIVES):$(ARCHIVE) ;
                if Merge in $($(ARCHIVE)_ATTRIBUTES) {
                    # merge archive contents by unpacking them into hierarchy
                    local DESTINATION_TARGET = $(CLASS_FILE_DIR:G=Unarchive$(ARCHIVE)) ;
                    NOTFILE $(DESTINATION_TARGET) ;
                    DEPENDS $(DESTINATION_TARGET) : $(JAVA_COMPILE_TARGET) ;
                    if $(MERGED_ARCHIVES) {
                        MERGED_ARCHIVES += $(DESTINATION_TARGET) ;
                    }
                    else {
                        MERGED_ARCHIVES = $(DESTINATION_TARGET) ;
                    }
                    Unarchive $(DESTINATION_TARGET) : $(ARCHIVE) ;
                }
            }
        }
        # generate an archive if there are compiled or merged classes
        if $(COMPILED_JAVA) || $(MERGED_ARCHIVES) || $(COPIED_JAVA_RESOURCES) {
	    if $(JAVA_ARCHIVE_CLASSES) != NO {
	        # java archive suffix applies to applications and frameworks
	        if $(JAVA_ARCHIVE_TYPE) = JAR {
		    CLASS_ARCHIVE_SUFFIX default = .jar ;
	        }
	        else {
		    if $(JAVA_ARCHIVE_TYPE) = ZIP {
		        CLASS_ARCHIVE_SUFFIX default = .zip ;
		    }
	        }
	        if ( $(PRODUCT_TYPE) = Bundle
                  || $(PRODUCT_TYPE) = Application
                  || $(PRODUCT_TYPE) = Framework ) {
                    # Assume bundled products with object files are Cocoa
		    CLASS_ARCHIVE default = $(RESOURCE_DIR)$(/)Java$(/)$(1:B)$(CLASS_ARCHIVE_SUFFIX) ;
                    ProductFile $(CLASS_ARCHIVE) ;
	        }
	        else {
                    CLASS_ARCHIVE default = $(1:B:G=)$(CLASS_ARCHIVE_SUFFIX) ;
                    # It is critical for the class archive to be declared
                    # a product file before any symlinks to it are made
                    # which would conditionally involved declaring the
                    # symbolic link content to not be a file.
                    ProductFile $(CLASS_ARCHIVE) ;
                    # ref. w/suffix for tool or library in deployment location
                    if $(DEPLOYMENT_LOCATION) = YES {
                        _ARCHIVE_REFERENCE default = $(BUILT_PRODUCTS_DIR:G=ArchiveRef)$(/)$(CLASS_ARCHIVE) ;
                        SymLink $(_ARCHIVE_REFERENCE) : $(CLASS_ARCHIVE) ;
                        DEPENDS $(_ARCHIVE_REFERENCE) : $(BUILT_PRODUCTS_DIR) ;
                        DEPENDS $(1) : $(_ARCHIVE_REFERENCE) ;
                    }
                    # Make a link to the product without extension
                    # to allow for references missing extension.
                    _SUFFIX_FREE_ARCHIVE_REFERENCE = $(CLASS_ARCHIVE:S=) ;
                    LOCATE on $(_SUFFIX_FREE_ARCHIVE_REFERENCE) = $(TARGET_BUILD_DIR) ;
                    SymLink $(_SUFFIX_FREE_ARCHIVE_REFERENCE) : $(CLASS_ARCHIVE) ;
                    DEPENDS $(_SUFFIX_FREE_ARCHIVE_REFERENCE) : $(TARGET_BUILD_DIR) ;
                    DEPENDS $(1) : $(_SUFFIX_FREE_ARCHIVE_REFERENCE) ;
    	        }
                # class archive depends on target build dir
                DEPENDS $(CLASS_ARCHIVE) : $(TARGET_BUILD_DIR) ;
                # class archive depends on class archive dir (if defined)
                CLASS_ARCHIVE_DIR = $(CLASS_ARCHIVE:D:G=) ;
                if $(CLASS_ARCHIVE_DIR) && ! $(CLASS_ARCHIVE_DIR) in $(PRODUCT_FILES) {
                    Mkdir $(CLASS_ARCHIVE_DIR) ;
                    ProductFile $(CLASS_ARCHIVE_DIR) ;
                }
	        # class files unknown, so archive depends on java compile log
	        ClassArchive $(CLASS_ARCHIVE) : $(CLASS_FILE_DIR) ;
	        if $(MERGED_ARCHIVES) {
                    DEPENDS $(CLASS_ARCHIVE) : $(MERGED_ARCHIVES) ;
                }
                if $(COMPILED_JAVA) {
                    DEPENDS $(CLASS_ARCHIVE) : $(JAVA_COMPILE_TARGET) ;
                }
                if $(COPIED_JAVA_RESOURCES) {
                    DEPENDS $(CLASS_ARCHIVE) : $(COPIED_JAVA_RESOURCES) ;
                }
	    }
            if $(JAVA_ARCHIVE_CLASSES) != YES {
                # !!!:cmolick:20020123 product class file dir not always made?!
                Mkdir $(PRODUCT_CLASS_FILE_DIR) ;
                ProductFile $(PRODUCT_CLASS_FILE_DIR) ;
                Ditto $(PRODUCT_CLASS_FILE_DIR) : $(CLASS_FILE_DIR) ;
	        if $(MERGED_ARCHIVES) {
                    DEPENDS $(PRODUCT_CLASS_FILE_DIR) : $(MERGED_ARCHIVES) ;
                }
                else {
                    DEPENDS $(PRODUCT_CLASS_FILE_DIR) : $(JAVA_COMPILE_TARGET) ;
                }
            }
        }
	# Export the path to the inner product, if any.
	export INNER_PRODUCT_SUBPATH = $(INNER_PRODUCT:G=) ;
	# Build phasing bookkeeping
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
    }
}

rule ProcessFrameworkOrLibrary
{
    for VARIANT in $(BUILD_VARIANTS) {
    LINKED_FILES_$(VARIANT) += $(2) ;
    }
}

# ProcessRezFiles <product> <rez and resmerger input files>
#
# Processes Rez and ResMerger input files, or if there are none
# and type and creator are set uses SetFile to set type and creator.
rule ProcessRezFiles
{
    if ( build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) )
     && ( $(ARCHS) || $(NULL_BUILD_IF_NO_VALID_ARCH) != YES ) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : RezResourceManagerFiles ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        if $(2) {
            for FILE in $(2) {
                if $(_BUILD_PHASING) = YES {
                    ProcessRezFile $(BUILD_PHASE) : $(FILE) ;
                }
                else {
                    ProcessRezFile $(1) : $(FILE) ;
                }
            }
        }
        else {
            if ( $(MACOS_TYPE) || $(MACOS_CREATOR) ) && $(REZ_EXECUTABLE) = YES {
                local RESOURCE_FORK = $(INNER_PRODUCT:G=ResourceFork) ;
                if ! $(INNER_PRODUCT) in $(PRESERVE_RESOURCES) {
                     PRESERVE_RESOURCES += $(INNER_PRODUCT) ;
                }
                ProductFile $(RESOURCE_FORK) ;
                if $(ALWAYS_REZ) = YES {
                    ALWAYS $(RESOURCE_FORK) ;
                }
                SetFile $(RESOURCE_FORK) ;
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

# ProcessRezFile <product or phase> <rez or resmerger input file>
#
# Sets up the compile of one Rez or ResMerger input file.
# RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR	folder for resource collectors
# RESOURCE_MANAGER_RESOURCE_COLLECTOR		resource collector
# RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)	localized collector
# RESOURCE_MANAGER_RESOURCE			final resource destination
# RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR	localized final folder
# RESOURCE_MANAGER_RESOURCE_$(REGION)		localized final destination
rule ProcessRezFile
{
    if source in $(BUILD_COMPONENTS) {
        local REZ_SOURCE_COPY ;
        local REZ_SOURCE_DIR ;
        # make directory first if necessary
        if $(2:D) {
            REZ_SOURCE_DIR = $(SOURCE_DIR)/$(2:D:G=) ;
            Mkdir $(REZ_SOURCE_DIR) ;
            REZ_SOURCE_COPY = $(REZ_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(REZ_SOURCE_COPY) : $(REZ_SOURCE_DIR) ;
        }
        else {
            REZ_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(REZ_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        # copy rez files to source location
        Cp $(REZ_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(REZ_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        local REGION = $($(2)_REGION) ;
        # scan for header files
        if $(ENABLE_HEADER_SCANNING) != NO && $(INDEX_BASED_HEADER_DEPENDENCIES) != YES {
            HDRRULE on $(2) = ProcessC.HdrRule ;
            HDRSCAN on $(2) = $(HDRPATTERN) ;
        }
        # all resources require a folder to hold any collector
        if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) {
            RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR = $(TEMP_DIR)$(/)ResourceManagerResources ;
            Mkdir $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
            ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
        }
        if $(REZ_EXECUTABLE) = YES {
            # Optionally accumulate ResourceManager resources
            # on a resource fork of the executable
            PRESERVE_RESOURCES += $(INNER_PRODUCT) ;
            if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) {
                RESOURCE_MANAGER_RESOURCE_COLLECTOR = $(INNER_PRODUCT:BG=ResourceManagerResourceCollector) ;
                DEPENDS $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
            }
            if $(2:S) = ".r" {
                RezCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
            } else {
                ResMergerCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
            }
            # The collector must be declared a product file
            # only after the first Collector rule invocation
            # to correctly initialize the collector.
            ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
            # location must be set after ProductFile invocation
            LOCATE on $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) = $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
            if ! $(RESOURCE_MANAGER_RESOURCE) {
                RESOURCE_MANAGER_RESOURCE = $(INNER_PRODUCT:G=ResourceManagerResource) ;
                ProductFile $(RESOURCE_MANAGER_RESOURCE) ;
                ResMergerProduct $(RESOURCE_MANAGER_RESOURCE) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
            }
        }
        else {
            # By default ResourceManager resources are stored in data forks
            # as Resources/<product>.rsrc files if non localized, or 
            # Resources/<region>.lproj/Localized.rsrc files if localized.
            if $(REGION) {
                # localized resource collector
                if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) {
                    RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION) = $(REGION).rsrc ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
                }
                if $(2:S) = ".r" {
                    RezCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) : $(2) ;
                } else {
                    ResMergerCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) : $(2) ;
                }
                # collector declared product after first Collector rule invocation
                ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) ;
                # set location only after ProductFile invocation
                LOCATE on $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) = $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
                # localized resource folder
                RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR = $(RESOURCE_DIR)$(/)$(REGION).lproj ;
                Mkdir $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                ProductFile $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                # localized resource
                if ! $(RESOURCE_MANAGER_RESOURCE_$(REGION)) {
                    RESOURCE_MANAGER_RESOURCE_$(REGION) = $(RESOURCE_DIR)$(/)$(REGION).lproj$(/)Localized.rsrc ;
                    ProductFile $(RESOURCE_MANAGER_RESOURCE_$(REGION)) ;
                    # folder for localized resource
                    RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR = $(RESOURCE_DIR)$(/)$(REGION).lproj ;
                    Mkdir $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                    ProductFile $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) : $(RESOURCE_DIR) ;
                    # get product from collector
                    ResMergerProduct $(RESOURCE_MANAGER_RESOURCE_$(REGION)) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_$(REGION)) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_$(REGION)) : $(RESOURCE_MANAGER_RESOURCE_$(REGION)_DIR) ;
                }
            }
            else {
                # nonlocalized resource collector
                if ! $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) {
                    RESOURCE_MANAGER_RESOURCE_COLLECTOR = $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR)$(/)$(1:S=.rsrc:G=) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR_DIR) ;
                }
                if $(2:S) = ".r" {
                    RezCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
                } else {
                    ResMergerCollector $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) : $(2) ;
                }
                # collector declared product after Collector rule invocation
                ProductFile $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
                # nonlocalized resource
                if ! $(RESOURCE_MANAGER_RESOURCE) {
                    RESOURCE_MANAGER_RESOURCE = $(RESOURCE_DIR)$(/)$(1:S=.rsrc:G=) ;
                    ProductFile $(RESOURCE_MANAGER_RESOURCE) ;
                    # get product from collector
                    ResMergerProduct $(RESOURCE_MANAGER_RESOURCE) : $(RESOURCE_MANAGER_RESOURCE_COLLECTOR) ;
                    DEPENDS $(RESOURCE_MANAGER_RESOURCE) : $(RESOURCE_DIR) ;
                    if $(ALWAYS_REZ) = YES {
                        ALWAYS $(RESOURCE_MANAGER_RESOURCE) ;
                    }
                }
            }

            if ! $(RESOURCE_DIR) in $(PRODUCT_FILES) {
                Mkdir $(RESOURCE_DIR) ;
                ProductFile $(RESOURCE_DIR) ;
            }
        }
        # create accompanying link in the case of versioned frameworks
        if $(RESOURCE_LINK) 
         && ! $(RESOURCE_LINK) in $(PRODUCT_FILES) {
            SymLink $(RESOURCE_LINK) : $(RESOURCE_LINK_PATH) ;
            ProductFile $(RESOURCE_LINK) ;
        }
    }
}

rule ProcessScriptBuildPhaseFiles
{
    if build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) {
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : Script ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        if build in $(BUILD_COMPONENTS)
         || ( headers in $(BUILD_COMPONENTS) && $(INSTALLHDRS_SCRIPT_PHASE) = YES ) {
            SEARCH on $(2) = $(SOURCE_ROOT) $(TEMP_ROOT) ;
            PHASE_SCRIPT_EXECUTION = $(2:G=Execution) ;
            NOTFILE $(PHASE_SCRIPT_EXECUTION) ;
            ALWAYS $(PHASE_SCRIPT_EXECUTION) ;
            DEPENDS $(1) : $(PHASE_SCRIPT_EXECUTION) ;
            PhaseScriptExecution $(PHASE_SCRIPT_EXECUTION) : $(2) ;
            if ! $(PHASE_SCRIPT_EXECUTION) in $(PRODUCT_FILES) {
                if $(_BUILD_PHASING) = YES {
                    BUILD_PHASE_PRODUCTS += $(PHASE_SCRIPT_EXECUTION) ;
                }
            }
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

rule PhaseScriptExecution
{
    JAMSHOULDSETENV on $(1) = YES ;
    DEPENDS $(1) : $(2) ;
}
actions exportvars PhaseScriptExecution
{
    echo "=== Script ==="
    cat "$(2)"
    echo "--- Output ---"
    "$(2)"
    _result=$?
    echo "=== Exit code: ${_result} ==="
    exit ${_result}
}

rule ProcessCopyFiles
{
    if $(_BUILD_PHASING) = YES {
        PhaseTarget BUILD_PHASE : $(1) : CopyFiles ;
        BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
        BUILD_PHASE_PRODUCTS = ;
    }
    if build in $(BUILD_COMPONENTS)
     || ( headers in $(BUILD_COMPONENTS) && $(INSTALLHDRS_COPY_PHASE) = YES ) {
        SEARCH on $(2) = $(SOURCE_ROOT) ;
        for FILE in $(2) {
            ProcessCopyFile $(1) : $(FILE) : $(COPYFILES_DESTINATION_PATH) ;
        }
    }
    if $(_BUILD_PHASING) = YES {
        if $(BUILD_PHASE_PRODUCTS) {
            DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
        }
        PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
    }
}

rule ProcessCopyFile
{
    if source in $(BUILD_COMPONENTS) {
        local SOURCE_COPY ;
        local SOURCE_SUBDIR ;
        # copy files to source location
        # make directory first if necessary
        if $(2:D) {
            SOURCE_SUBDIR = $(2:D:G=SourceCopy) ;
            Mkdir $(SOURCE_SUBDIR) ;
            SOURCE_COPY = $(SOURCE_SUBDIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_SUBDIR) ;
        }
        else {
            SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        Cp $(SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) || headers in $(BUILD_COMPONENTS) {
        local DESTINATION_DIR = $(3) ;
        if ! $(DESTINATION_DIR) in $(PRODUCT_FILES) {
            Mkdir $(DESTINATION_DIR) ;
            ProductFile $(DESTINATION_DIR) ;
        }
        local DESTINATION_BASE = $(2:BS) ;
        local DESTINATION default = $(3)$(/)$(DESTINATION_BASE) ;
        DEPENDS $(DESTINATION) : $(DESTINATION_DIR) ;
        DEPENDS $(DESTINATION) : $(2) ;
        ProductFile $(DESTINATION) ;
        LOCATE on $(DESTINATION) = $(DESTINATION_DIR) ;
        RobustCp $(DESTINATION) : $(2) ;
    }
}

rule ProcessJavaResourceFiles
{
    if build in $(BUILD_COMPONENTS) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : JavaArchiveFiles ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        LOCATE on $(2) = $(SOURCE_ROOT) ;
        for FILE in $(2) {
            ProcessJavaResourceFile $(1) : $(FILE) : $(CLASS_FILE_DIR) ;
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

rule ProcessJavaResourceFile
{
    local ARCHIVE_PATH ;
    local ARCHIVE_DESTINATION ;
    local ARCHIVE_DESTINATION_FILE ;

    # copy any other reference - formulate destination first
    if $($(2)_JAVA_ARCHIVE_SUBDIR) {
        ARCHIVE_DESTINATION_DIR = $(3)$(/)$($(2)_JAVA_ARCHIVE_SUBDIR) ;
    }
    else {
        # if there's no setting, just copy the file to the root of the archive.
        ARCHIVE_DESTINATION_DIR = $(3) ;
    }
    ARCHIVE_DESTINATION_FILE = $(ARCHIVE_DESTINATION_DIR)/$(2:BS) ;
    Mkdir $(ARCHIVE_DESTINATION_DIR) ;
    ProductFile $(ARCHIVE_DESTINATION_DIR) ;
    PBXCp $(ARCHIVE_DESTINATION_FILE:G=populated) : $(2) ;
    ProductFile $(ARCHIVE_DESTINATION_FILE:G=populated) ;

    # copied content depends on source
    DEPENDS $(ARCHIVE_DESTINATION_FILE) : $(2) ;
    # set contents present for archival flag by making COPIED_JAVA_RESOURCES nonempty
    COPIED_JAVA_RESOURCES += $(2) ;
}

# Following rules are used by ProcessSource
# to attend to specific types of source file.

rule ProcessUsingJavaCompiler
{
    # Because what class files will be generated by the java compiler
    # can't be known in advance, an abstract target is used for this step.
    if $(JAVA_COMPILE_TARGET) = "" {
        JAVA_COMPILE_TARGET = $(1:G=CompileJava) ;
        NOTFILE $(JAVA_COMPILE_TARGET) ;
        DEPENDS $(1) : $(JAVA_COMPILE_TARGET) ;
        DEPENDS $(JAVA_COMPILE_TARGET) : $(CLASS_FILE_DIR) ;
        # bridge derived java to be generated and compiled first
        if $(JAVA_BRIDGE_COMPILE_TARGET) {
            DEPENDS $(JAVA_COMPILE_TARGET) : $(JAVA_BRIDGE_COMPILE_TARGET) ;
        }
    }
    
    export JAVA_SOURCE_PATH default = $(SOURCE_ROOT)$(/)$(JAVA_SOURCE_SUBDIR) ;

    # start with the compiler-specific flags.
    if $(JAVA_COMPILER:B) = jikes {
        export JAVAC_FLAGS = $(JIKES_DEFAULT_FLAGS) ;
    }
    else if $(JAVA_COMPILER:B) = javac {
        export JAVAC_FLAGS = $(JAVAC_DEFAULT_FLAGS) ;
    }
    else {
        export JAVAC_FLAGS = ;
    }
    
    if $(JAVA_COMPILER_DISABLE_WARNINGS) = YES {
        JAVAC_FLAGS += "-nowarn" ;
    }
    if $(JAVA_COMPILER_DEPRECATED_WARNINGS) = YES {
        JAVAC_FLAGS += "-deprecation" ;
    }
    JAVAC_FLAGS += $(JAVA_COMPILER_FLAGS) ;

    if $(JAVA_COMPILER_TARGET_VM_VERSION) {
        if $(JAVA_COMPILER:B) = jikes {
            ECHO warning: Target VM version not supported by jikes ;
        }
        else {
            JAVAC_FLAGS += "-target "$(JAVA_COMPILER_TARGET_VM_VERSION) ;
        }
    }
    
    if $(JAVA_COMPILER_DEBUGGING_SYMBOLS) = YES {
        JAVAC_FLAGS += "-g" ;
    }
    
    if $(JAVAC_SOURCE_FILE_ENCODING) {
        JAVAC_FLAGS += -encoding "$(JAVAC_SOURCE_FILE_ENCODING)" ;
    }

    if $(JAVA_USE_DEPENDENCIES) = "NO" || ( ! $($(2)_JAVA_IMPORTS) && empty$($(2)_JAVA_IMPORTS) != empty ) {
        # With no dependence, or dependence info usage off
        # build with combinded compiler invocations but no file list
        DEPENDS $(JAVA_COMPILE_TARGET) : $(2) ;
        ALWAYS $(JAVA_COMPILE_TARGET) ;
        JAVAC_FLAGS on $(JAVA_COMPILE_TARGET) = $(JAVAC_FLAGS) ;
        JAVA_COMPILER on $(JAVA_COMPILE_TARGET) = $(JAVA_COMPILER) ;
        if $(JAVA_COMPILER:B) = jikes {
	    JavaCompile.jikes $(JAVA_COMPILE_TARGET) : $(2) ;
        }
        else {
	    JavaCompile.default $(JAVA_COMPILE_TARGET) : $(2) ;
        }
        COMPILED_JAVA += $(2) ;
        if ! $(JAVA_COMPILE_TARGET) in $(PRODUCT_FILES) {
            ProductFile $(JAVA_COMPILE_TARGET) ;
        }
    }
    else {
        # Using dependence info, set up file list for java compiles
        JAVA_FILE_LIST default = $(TEMP_DIR)$(/)JavaFileList ;
        # define and act on target to clear list
        if ! $(CLEAR_JAVA_FILE_LIST) {
            CLEAR_JAVA_FILE_LIST = $(JAVA_FILE_LIST:G=ClearFileList) ;
            ClearJavaFileList $(CLEAR_JAVA_FILE_LIST) ;
            DEPENDS $(JAVA_COMPILE_TARGET) : $(CLEAR_JAVA_FILE_LIST) ;
        }
        # set up compile target to use file list
        if ! $(JAVA_COMPILE_TARGET) in $(PRODUCT_FILES) {
            JAVAC_FLAGS on $(JAVA_COMPILE_TARGET) = $(JAVAC_FLAGS) ;
            JAVA_COMPILER on $(JAVA_COMPILE_TARGET) = $(JAVA_COMPILER) ;
            JAVA_FILE_LIST_REFERENCE = @$(JAVA_FILE_LIST) ;
            NOTFILE $(JAVA_FILE_LIST_REFERENCE) ;
            if $(JAVA_COMPILER:B) = jikes {
	        JavaCompile.jikes $(JAVA_COMPILE_TARGET) : $(JAVA_FILE_LIST_REFERENCE) ;
            }
            else {
	        JavaCompile.default $(JAVA_COMPILE_TARGET) : $(JAVA_FILE_LIST_REFERENCE) ;
            }
            ProductFile $(JAVA_COMPILE_TARGET) ;
        }
        # set up class file dependence used to add java files to compile list
        local CLASS_FILE ;
        # use the main class, if it's there
        if $($(2)_MAIN_CLASS) {
            CLASS_FILE = $(CLASS_FILE_DIR)$(/)$($(2)_MAIN_CLASS) ;
        }
        else {
            local JAVA_SOURCE ;
            RemovePrefixPath JAVA_SOURCE : $(JAVA_SOURCE_SUBDIR) : $(2) ;
            CLASS_FILE = $(CLASS_FILE_DIR)$(/)$(JAVA_SOURCE:S=.class) ;
        }
        DEPENDS $(CLASS_FILE) : $(2) ;
        if $($(2)_JAVA_IMPORTS) {
            DEPENDS $(CLASS_FILE) : $($(2)_JAVA_IMPORTS) ;
            DEPENDS $(CLEAR_JAVA_FILE_LIST) : $($(2)_JAVA_IMPORTS) ;
        }
        DEPENDS $(JAVA_COMPILE_TARGET) : $(CLASS_FILE) ;
        JAVA_FILE_LIST on $(CLASS_FILE) = $(JAVA_FILE_LIST) ;
        AppendToJavaFileList $(CLASS_FILE) : $(2) ;
        DEPENDS $(CLEAR_JAVA_FILE_LIST) : $(2) ;
        COMPILED_JAVA += $(2) ;
    }
}

actions quietly together piecemeal ClearJavaFileList
{
    $(RM) -rf "$(JAVA_FILE_LIST)" && $(TOUCH) "$(JAVA_FILE_LIST)"
}

# Appends reference to list only if not already present
actions quietly together piecemeal AppendToJavaFileList
{
    _grep_result=`/usr/bin/grep -e \""$(2)"\" "$(JAVA_FILE_LIST)"`
    if [ "x$_grep_result" = "x" ]
      then $(ECHO) \""$(2)"\" >> "$(JAVA_FILE_LIST)"
    fi
}

actions together piecemeal JavaCompile.default {
    frameworkjars=""
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath`
    $(JAVA_COMPILER) $(JAVAC_FLAGS) -sourcepath "$(JAVA_SOURCE_PATH)" -classpath "$classpath" -d "$(CLASS_FILE_DIR)" '$(2)'
}
actions together piecemeal JavaCompile.jikes {
    frameworkjars=""
    for i in `echo $(JAVA_FRAMEWORK_JARS)/*.jar $(JAVA_FRAMEWORK_JARS)/*.zip ` ; do if [ -f "$i" ] ; then frameworkjars="$frameworkjars":"$i" ; fi ; done
    classpath="$(CLASS_FILE_DIR)$(LINKED_CLASS_ARCHIVES)$frameworkjars:"`$(JAVACONFIG) DefaultClasspath`
    $(JAVA_COMPILER) $(JAVAC_FLAGS) -sourcepath "$(JAVA_SOURCE_PATH)" -classpath "$classpath" -d "$(CLASS_FILE_DIR)" '$(2)'
}

rule ProcessApplescripts
{
    if build in $(BUILD_COMPONENTS) || source in $(BUILD_COMPONENTS) {
        local FILE ;
        if $(_BUILD_PHASING) = YES {
            PhaseTarget BUILD_PHASE : $(1) : CompileAppleScripts ;
            BuildPhase $(BUILD_PHASE) : $(1) : $(PREVIOUS_BUILD_PHASE) ;
            BUILD_PHASE_PRODUCTS = ;
        }
        if $(CONTEXTNAME) = ""
        {
            for FILE in $(2) {
                if $(_BUILD_PHASING) = YES {
                    ProcessAppleScript $(BUILD_PHASE) : $(FILE) : $(FILE) ;
                }
                else {
                    ProcessAppleScript $(1) : $(FILE) : $(FILE) ;
                }
            }
        }
        else
        {
            ProcessAppleScript $(1) : $(2) : $(CONTEXTNAME) ;
        }
        if $(_BUILD_PHASING) = YES {
            if $(BUILD_PHASE_PRODUCTS) {
                DEPENDS $(BUILD_PHASE) : $(BUILD_PHASE_PRODUCTS) ;
            }
            PREVIOUS_BUILD_PHASE = $(BUILD_PHASE) ;
        }
    }
}

rule ProcessAppleScript
{
    if source in $(BUILD_COMPONENTS) {
        # make directory first if necessary
        if $(2:D) {
            SCRIPT_SOURCE_DIR = $(2:D:G=) ;
            Mkdir $(SCRIPT_SOURCE_DIR) ;
            SCRIPT_SOURCE_COPY = $(SCRIPT_SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SCRIPT_SOURCE_COPY) : $(SCRIPT_SOURCE_DIR) ;
        }
        else {
            SCRIPT_SOURCE_COPY = $(SOURCE_DIR)/$(2:D=:G=) ;
            DEPENDS $(SCRIPT_SOURCE_COPY) : $(SOURCE_DIR) ;
            Mkdir $(SOURCE_DIR) ;
        }
        # copy script to source location
        Cp $(SCRIPT_SOURCE_COPY) : $(2) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(SCRIPT_SOURCE_COPY) ;
        }
    }
    if build in $(BUILD_COMPONENTS) {
        if $(2) = $(3) {
            # third argument is a file (ignore subfolder for result)
            APPLESCRIPT_FILE = $(APPLESCRIPTS_DIR)$(/)$(3:BS=.scpt) ;
        }
        else {
            # third argument is a context name
            APPLESCRIPT_FILE = $(APPLESCRIPTS_DIR)$(/)$(3:S=.scpt) ;
        }
        DEPENDS $(APPLESCRIPT_FILE) : $(APPLESCRIPTS_DIR) ;
        if ! $(APPLESCRIPTS_DIR) in $(PRODUCT_FILES) {
            Mkdir $(APPLESCRIPTS_DIR) ;
            ProductFile $(APPLESCRIPTS_DIR) ;
        }
        DEPENDS $(APPLESCRIPT_FILE) : $(2) ;
        OTHER_OSAFLAGS on $(APPLESCRIPT_FILE) = $(OTHER_OSAFLAGS) ;
        OSACompile $(APPLESCRIPT_FILE) : $(2) ;
        ProductFile $(APPLESCRIPT_FILE) ;
    }
}

actions OSACompile
{
    $(OSAC) -d -i $(SYSTEM_LIBRARY_DIR)/Frameworks/AppleScriptKit.framework -U "$(2:BS)" -o "$(1)" $(OTHER_OSAFLAGS) "$(2)"
}

rule ProcessC
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
#!!!:needs to be a product file without LOCATE
#            ProductFile $(OBJECT_SUBDIR) ;
            PRODUCT_FILES += $(OBJECT_SUBDIR) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_CFLAGS = $(PER_ARCH_CFLAGS_$(ARCH)) ;
        if $(JAVA_BRIDGET_TARGET) {
            DEPENDS $(OBJECT_FILE) : $(JAVA_BRIDGET_TARGET) ;
        }
        CompileC $(OBJECT_FILE) : $(2) ;
        if $(2:BS) != $(VECTOR_STUB:BS) {
            # add object file to object files and phase products
            # unless it is the compiled generated vector stub
            OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
            }
        }
        LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
        if $(2) = $(MODULE_INFO_FILE) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            # object file is added to linked files
            # unless it is the compiled generated vector stub
            if $(2:BS) != $(VECTOR_STUB:BS) {
                LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
            }
        }
    }
    }
}

rule ProcessCplusplus
{
    for VARIANT in $(BUILD_VARIANTS) {
    for ARCH in $(ARCHS) {
        local OBJECT_FILE ;
        local OBJECT_SUBDIR = $(OBJECT_FILE_DIR_$(VARIANT))$(/)$(ARCH) ;
        # $(2)_UNIQUENAME is defined only if the basename of the file isn't unique within the target.
        if $($(2)_UNIQUENAME) {
            OBJECT_FILE = $($(2)_UNIQUENAME:G=$(VARIANT)-$(ARCH)).o ;
        }
        else {
            OBJECT_FILE = $(2:D=:S=:G=$(VARIANT)-$(ARCH)).o ;
        }
        DEPENDS $(OBJECT_FILE) : $(OBJECT_SUBDIR) ;
        if ! $(OBJECT_SUBDIR) in $(PRODUCT_FILES) {
            Mkdir $(OBJECT_SUBDIR) ;
            # !!!:cmolick:20010727 should be a ProductFile
            if $(_BUILD_PHASING) = YES {
                BUILD_PHASE_PRODUCTS += $(OBJECT_SUBDIR) ;
            }
        }
        ARCH on $(OBJECT_FILE) = $(ARCH) ;
        PER_ARCH_CPLUSPLUSFLAGS_$(ARCH) default = $(PER_ARCH_CFLAGS_$(ARCH)) ;
        PER_ARCH_CPLUSPLUSFLAGS = $(PER_ARCH_CPLUSPLUSFLAGS_$(ARCH)) ;
        CompileCplusplus $(OBJECT_FILE) : $(2) ;
        OBJECT_FILES_$(VARIANT) += $(OBJECT_FILE) ;
        OBJECT_FILES_$(VARIANT)_$(ARCH) += $(OBJECT_FILE) ;
        if $(_BUILD_PHASING) = YES {
            BUILD_PHASE_PRODUCTS += $(OBJECT_FILE) ;
        }
        if $(2) = $(MODULE_INFO_FILE_$(VARIANT)) {
            MODULE_OBJECT_FILE_$(VARIANT) = $(OBJECT_FILE) ;
            LOCATE on $(MODULE_OBJECT_FILE_$(VARIANT)) = $(OBJECT_SUBDIR) ;
            DEPENDS $(1) : $(MODULE_OBJECT_FILE_$(VARIANT)) ;
        }
        else {
            LOCATE on $(OBJECT_FILE) = $(OBJECT_SUBDIR) ;
            LINKED_FILES_$(VARIANT) += $(OBJECT_FILE) ;
        }
    }
    }
}

HDRPATTERN = "^[	 ]*#[	 ]*include[	 ]*[<\"](.*)[\">].*$" ;
HDRPATTERN += "^[	 ]*#[	 ]*import[	 ]*[<\"](.*)[\">].*$" ;

rule ProcessC.HdrRule
{
    # header reference in subdirectory source may be to header in that subdirectory
    local LOCAL_HEADERS = $(2:D=$(1:D)) ;
    # or header reference may be to elsewhere
    local FOREIGN_HEADERS = $(2) ;
    # compiled sources may include headers in subdirectories
    INCLUDES $(1) : $(LOCAL_HEADERS) $(FOREIGN_HEADERS) ;
    # headers not found are ignored
    NOCARE $(LOCAL_HEADERS) $(FOREIGN_HEADERS) ;
}

rule CompileC
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        local KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -msoft-float ;
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) $(OTHER_CFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CFLAGS) $(OTHER_CFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if $(USE_GCC3) = YES {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;

    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CFLAGS) ;
    # Add variant-specific flags
    local _VARIANT_FLAGS = $($(CC:BS)_$(VARIANT)_FLAGS) ;
    if $(_VARIANT_FLAGS) {
        FLAGS on $(1) += $(_VARIANT_FLAGS) ;
    }
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(INDEX_GENERATION_PIPE_NAME) != "" {
        FLAGS on $(1) += "-fgen-index=$(INDEX_GENERATION_PIPE_NAME)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        PREFIX_HEADER_CFLAGS on $(1) = --load-pch "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
        DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
        DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
    }
}

actions CompileC
{
    $(CC:Q) -c -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) "$(FLAGS)" $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_CFLAGS:Q) $(2:Q) -o $(1:Q)
}

rule CompileCplusplus
{
    # object file depends on the source file
    DEPENDS $(1) : $(2) ;
    # Initialize the flags, and set search paths to nothing
    if $(KERNEL_MODULE) = YES {
        local KERNEL_FRAMEWORK = $(SYSTEM_LIBRARY_DIR)/Frameworks/Kernel.framework ;
        local KERNEL_HEADERS = $(KERNEL_FRAMEWORK)/Headers ;
        local KERNEL_INCLUDE_PATHS = $(KERNEL_HEADERS) $(KERNEL_HEADERS)/bsd $(KERNEL_FRAMEWORK)/PrivateHeaders ;
        #!!!:cmolick:20020228 different default flags for gcc3 kext builds
        if $(USE_GCC3) = YES {
            KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -fno-rtti -fno-exceptions -fcheck-new -msoft-float -fapple-kext ;
        }
        else {
            KERNEL_COMPILE_OPTIONS = -fno-builtin -finline -fno-keep-inline-functions -force_cpusubtype_ALL -fno-rtti -fno-exceptions -fcheck-new -fvtable-thunks -msoft-float ;
            if $(MODULE_IOKIT) = YES {
                KERNEL_COMPILE_OPTIONS += -findirect-virtual-calls ;
            }
        }
        if $(ARCH) in ppc {
            KERNEL_COMPILE_OPTIONS += -mlong-branch ;
        }
        local KERNEL_DEFINITIONS = -DKERNEL -DKERNEL_PRIVATE -DDRIVER_PRIVATE -DAPPLE -DNeXT ;
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS) -fno-common -nostdinc $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) $(OTHER_CPLUSPLUSFLAGS) -I$(KERNEL_INCLUDE_PATHS) -I$(PROJECT_HEADER_DIR) $(KERNEL_COMPILE_OPTIONS) -static $(KERNEL_DEFINITIONS) ;
        GLOBAL_CFLAGS on $(1) = ;
    }
    else {
        FLAGS on $(1) = -arch $(ARCH) $(PER_ARCH_CPLUSPLUSFLAGS) -fno-common -fpascal-strings $(OPTIMIZATION_CFLAGS) $(WARNING_CPLUSPLUSFLAGS) ;
        if $(2:S) = .CPP {
            FLAGS on $(1) += -x c++ ;
        }
        FLAGS on $(1) += $(OTHER_CPLUSPLUSFLAGS) ;
    }
    FLAGS on $(1) += -pipe ;
    if ( $(USE_GCC3) = YES ) {
        FLAGS on $(1) += -fmessage-length=0 ;
        if $(PRODUCT_TYPE) = Tool || $(PRODUCT_TYPE) = Application {
            USE_DYNAMIC_NO_PIC default = YES ;
        } else {
            USE_DYNAMIC_NO_PIC default = NO ;
        }
        if $(USE_DYNAMIC_NO_PIC) = YES {
            FLAGS on $(1) += -mdynamic-no-pic ;
        }
    }
    # seed search paths with target-wide values
    HEADER_SEARCH_PATHS on $(1) = $(HEADER_SEARCH_PATHS) ;
    FRAMEWORK_SEARCH_PATHS on $(1) = $(FRAMEWORK_SEARCH_PATHS) ;
    # If the source file is in a subdirectory, then search that
    # subdirectory for headers
    if $(2:D) {
        HEADER_SEARCH_PATHS on $(1) += $(2:D) ;
    }
    # We must compile with the extension-specific build flags
    FLAGS on $(1) += $($(2:S)_CC_FLAGS) ;
    # Add variant-specific flags
    local _VARIANT_FLAGS = $($(CC:BS)_$(VARIANT)_FLAGS) ;
    if $(_VARIANT_FLAGS) {
        FLAGS on $(1) += $(_VARIANT_FLAGS) ;
    }
    # Add debug flags, if appropriate.
    if $(DEBUGGING_SYMBOLS) = YES {
        FLAGS on $(1) += -g ;
    }
    # Add profiling flags, if appropriate.
    if $(PROFILING_CODE) = YES {
        FLAGS on $(1) += -pg ;
    }
    # Pass the trusted-precomp file name to the compiler to keep track
    # of which precompiled headers it has already sanity checked.
    if $(OS) in MACOS DARWIN  &&  $(EFFECTIVE_PFE_FILE_$(ARCH)) = "" {
        FLAGS on $(1) += -precomp-trustfile $(PRECOMP_TRUSTFILE) ;
    }
    if $(CPP_HEADERMAP_FILE) {
        FLAGS on $(1) += "-Wp,-header-mapfile,$(CPP_HEADERMAP_FILE)" ;
    }
    if YES in $(GENERATE_CPP_ILOG_FILES) {
        local INCLUSION_LOG_FILE default = $(OBJECT_FILE_DIR)-$(VARIANT)$(/)$(ARCH)$(/)$(1:DB).ilog ;
        FLAGS on $(1) += "-Wp,-inclusion-log-file,$(INCLUSION_LOG_FILE)" ;
    }
    if $(EFFECTIVE_PFE_FILE_$(ARCH)) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        PREFIX_HEADER_CFLAGS on $(1) = --load-pch "$(EFFECTIVE_PFE_FILE_$(ARCH))" ;
        DEPENDS $(1) : $(EFFECTIVE_PFE_FILE_$(ARCH)) ;
    }
    if $(EFFECTIVE_PREFIX_HEADER) != ""  &&  $(SUPPRESS_PREFIX_HEADER) != YES {
        PREFIX_HEADER_CFLAGS on $(1) += -include "$(EFFECTIVE_PREFIX_HEADER)" ;
        DEPENDS $(1) : $(EFFECTIVE_PREFIX_HEADER) ;
    }
    _LD_FOR_LINKING = $(LDPLUSPLUS) ;
}

actions CompileCplusplus
{
    $(CPLUSPLUS:Q) -c -F$(FRAMEWORK_SEARCH_PATHS:Q) -I$(HEADER_SEARCH_PATHS:Q) "$(FLAGS)" $(GLOBAL_CFLAGS) -I$(DERIVED_PATHS:Q) $(PREFIX_HEADER_CFLAGS:Q) $(2:Q) -o $(1:Q)
}

VECTOR_SUFFIX default = ;
rule ProcessExportsFile
{
    if $(CFM_BRIDGE) = YES {
        local DYLIB_INSTALLED_NAME ;
        VECTOR_STUB default = $(DERIVED_FILE_DIR)$(/)$(1:B)Vector.s ;
        VECTOR_OBJECT_FILE default = $(TEMP_DIR)$(/)$(1:B)Vector.o ;
        if $(VECTOR_SUFFIX) {
            VECTOR_FRAGMENT_NAME default = CFMPriv_$(1:B)$(VECTOR_SUFFIX) ;
        }
        else {
            VECTOR_FRAGMENT_NAME default = CFMPriv_$(1:B) ;
        }
        DEPENDS $(VECTOR_STUB) : $(CURRENT_VERSION_DIR) ;
        DEPENDS $(VECTOR_STUB) : $(DERIVED_FILE_DIR) ;
        Mkdir $(CURRENT_VERSION_DIR) ;
        if $(INSTALL_PATH) {
            DYLIB_INSTALLED_NAME default = $(INSTALL_PATH)$(/)$(1:G=)$(/)Versions$(/)$(FRAMEWORK_VERSION)$(/)$(1:B:G=) ;
            if $(DYNAMIC_LIBRARY_SUFFIX) {
                DYLIB_INSTALLED_NAME = $(DYLIB_INSTALLED_NAME)$(DYNAMIC_LIBRARY_SUFFIX) ;
            }
        }
        DYLIB_INSTALLED_NAME on $(1) = $(DYLIB_INSTALLED_NAME) ;
        GenerateVectorLibraryIntermediates $(VECTOR_STUB) $(VECTOR_OBJECT_FILE) : $(2) ;
        BUILD_PHASE_PRODUCTS += $(VECTOR_STUB) ;
    }
}

rule ProcessUsingMig
{
    local TEMP_FILES ;
    local FILE_BASE = $(2:B) ;
    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
# was    if $(MACH_SERVER) != YES || $(MACH_CLIENT_AND_SERVER) = YES {
    if Client in $($(2)_ATTRIBUTES) {
        TEMP_FILES = $(FILE_BASE).h $(FILE_BASE)User.c ;
    }
# was    if $(MACH_SERVER) = YES || $(MACH_CLIENT_AND_SERVER) = YES {
    if Server in $($(2)_ATTRIBUTES) {
        TEMP_FILES += $(FILE_BASE)Server.h $(FILE_BASE)Server.c ;
    }
    if Client in $($(2)_ATTRIBUTES) || Server in $($(2)_ATTRIBUTES) {
        Mig $(TEMP_FILES) : $(2) ;
        DerivedFiles $(TEMP_FILES) ;
        ProcessFiles $(1) : $(TEMP_FILES) ;
    }
}

rule ProcessUsingLex
{
    local TEMP_FILES ;
    local FILE_BASE = $(2:B) ;
    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    switch $(2:S) {
        case ".l" : TEMP_FILES += $(FILE_BASE).c ;
        case ".lm" : TEMP_FILES += $(FILE_BASE).m ;
        case ".LM" : TEMP_FILES += $(FILE_BASE).M ;
        case ".lmm" : TEMP_FILES += $(FILE_BASE).mm ;
        case ".lpp" : TEMP_FILES += $(FILE_BASE).cpp ;
        case ".LPP" : TEMP_FILES += $(FILE_BASE).CPP ;
        case ".lxx" : TEMP_FILES += $(FILE_BASE).cxx ;
        case ".LXX" : TEMP_FILES += $(FILE_BASE).CXX ;
    }
    DEPENDS $(TEMP_FILES) : $(DERIVED_FILE_DIR) ;
    Lex $(TEMP_FILES) : $(2) ;
    DerivedFiles $(TEMP_FILES) ;
    ProcessFiles $(1) : $(TEMP_FILES) ;
}

rule ProcessUsingYacc
{
    local FILE_BASE = $(2:B) ;
    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    local TEMP_FILES = $(FILE_BASE).h ;
    switch $(2:S) {
        case ".y" : TEMP_FILES += $(FILE_BASE).c ;
        case ".ym" : TEMP_FILES += $(FILE_BASE).m ;
        case ".YM" : TEMP_FILES += $(FILE_BASE).M ;
        case ".ymm" : TEMP_FILES += $(FILE_BASE).mm ;
        case ".ypp" : TEMP_FILES += $(FILE_BASE).cpp ;
        case ".YPP" : TEMP_FILES += $(FILE_BASE).CPP ;
        case ".yxx" : TEMP_FILES += $(FILE_BASE).cxx ;
        case ".YXX" : TEMP_FILES += $(FILE_BASE).CXX ;
    }
    DEPENDS $(TEMP_FILES) : $(DERIVED_FILE_DIR) ;
    Yacc $(TEMP_FILES) : $(2) ;
    DerivedFiles $(TEMP_FILES) ;
    ProcessFiles $(1) : $(TEMP_FILES) ;
}

rule ProcessUsingRPCGen
{
    local FILE_BASE = $(2:B) ;
    if AbsolutePath in $($(2)_ATTRIBUTES) {
        FILE_BASE = $(DERIVED_FILE_DIR)$(2:DB) ;
    }
    local TEMP_FILES = $(FILE_BASE).h $(FILE_BASE)_xdr.c ;
    DEPENDS $(TEMP_FILES) : $(DERIVED_FILE_DIR) ;
    RPCGen $(TEMP_FILES) : $(2) ;
    DerivedFiles $(TEMP_FILES) ;
    ProcessFiles $(1) : $(TEMP_FILES) ;
}

rule ProcessUsingBridget
{
    Bridget $(1) : $(2) ;
}
# Copyright (c) 1999-2002 Apple Computer, Inc.
# All rights reserved.

# High level rules for build actions on targets

# Actions <product>
# Defines all available build actions
rule Actions
{
    Clean clean : $(1) ;
    BuildAction build : $(1) ;
    BuildAction copysrc : $(1) ;
    NOTFILE copysrc ;
    BuildAction copyhdrs : $(1) ;
    NOTFILE copyhdrs ;
    BuildAction copyrsrcs : $(1) ;
    NOTFILE copyrsrcs ;
    BuildAction install : $(1) ;
    BuildAction installdebugonly : $(1) ;
    NOTFILE installdebug ;
    BuildAction installprofileonly : $(1) ;
    NOTFILE installprofile ;
    BuildAction installdebugprofileonly : $(1) ;
    NOTFILE installdebugprofile ;
    BuildAction installsrc : $(1) ;
    NOTFILE installsrc ;
    BuildAction installhdrs : $(1) ;
    NOTFILE installhdrs ;
    BuildAction installrsrcs : $(1) ;
    NOTFILE installrsrcs ;
}

# Clean clean : <product>
# Deletes the product and the files associated with building it
rule Clean
{
    # locate built product and remove
    local BUILT_PRODUCT = $(2:G=) ;
    LOCATE on $(BUILT_PRODUCT) = $(TARGET_BUILD_DIR) ;
    Clean.Remove clean : $(BUILT_PRODUCT) ;

    # remove temporary directories
    Clean.Remove clean : $(TEMP_DIR) ;

    # Removal of archive in case of tools that are class archives,
    # this is which don't necessarily end with TOOL_SUFFIX.
    local ARCHIVE_SUFFIX ;
    local ARCHIVE_TARGET ;
    if $(JAVA_ARCHIVE_TYPE) = JAR {
        ARCHIVE_SUFFIX default = .jar ;
    }
    if $(JAVA_ARCHIVE_TYPE) = ZIP {
        ARCHIVE_SUFFIX default = .zip ;
    }
    ARCHIVE_SUFFIX default = "" ;
    ARCHIVE_TARGET = $(2:G=)$(ARCHIVE_SUFFIX) ;
    LOCATE on $(ARCHIVE_TARGET) = $(TARGET_BUILD_DIR) ;
    Clean.RemoveArchive clean : $(ARCHIVE_TARGET) ;
    # remove project header clones for this target
    if $(PROJECT_HEADER_DIR) {
        Clean.Remove clean : $(PROJECT_HEADER_DIR) ;
    }
    if $(WRAPPER_CLONE_DIR) {
        Clean.Remove clean : $(WRAPPER_CLONE_DIR) ;
    }
    # whole project content to remove on full clean
    Clean.Remove clean : $(PRECOMP_TRUSTFILE) ;
}

actions quietly piecemeal together existing Clean.Remove 
{
    $(RM) -rf "$(2)"
}

actions Clean.RemoveArchive
{
    if [ -f "$(2)" ]; then
        $(RM) -rf "$(2)"
    fi
}

rule BuildAction
{
    local ACTION_TARGET = $(2:G=$(1)BuildAction) ;
    ACTION on $(2) = $(ACTION) ;
    DEPENDS $(1) : $(ACTION_TARGET) ;
    DEPENDS $(ACTION_TARGET) : $(2) ;
    NOTFILE $(ACTION_TARGET) ;
}

# RunVariantHackScript varianthack : <product>
# Runs /AppleInternal/Developer/Tools/AppleInternalDebugAndProfileBuild.sh,
rule RunVariantHackScript
{
    if $(RC_JASPER) || $(INTERNAL_BUILD_VARIANTS_ONLY_IN_JASPER) != YES {
        local VARIANT_HACK_TARGET = $(1:G=varianthack) ;
        DEPENDS $(1) : $(VARIANT_HACK_TARGET) ;
        NOTFILE $(VARIANT_HACK_TARGET) ;
    }
}
actions exportvars RunVariantHackScript
{
    /bin/sh /AppleInternal/Developer/Tools/AppleInternalDebugAndProfileBuilder.sh $(INTERNAL_BUILD_VARIANTS)
}
# Copyright (c) 1999,2000 Apple Computer, Inc.
# All rights reserved.

include $(JAMFILE) ;
